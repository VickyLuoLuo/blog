{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/LICENSE","path":"LICENSE","modified":0,"renderable":0},{"_id":"themes/livemylife/source/baidu_verify_code-jayy2pLM52.html","path":"baidu_verify_code-jayy2pLM52.html","modified":0,"renderable":1},{"_id":"themes/livemylife/source/google0915f5e354aeae89.html","path":"google0915f5e354aeae89.html","modified":0,"renderable":1},{"_id":"source/img/avatar/avatar.png","path":"img/avatar/avatar.png","modified":0,"renderable":0},{"_id":"source/img/avatar/fatpeople.jpg","path":"img/avatar/fatpeople.jpg","modified":0,"renderable":0},{"_id":"source/img/signature/vicky-white.png","path":"img/signature/vicky-white.png","modified":0,"renderable":0},{"_id":"themes/livemylife/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/catalog.styl","path":"css/catalog.styl","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/highlight_normal.css","path":"css/highlight_normal.css","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/livemylife.css","path":"css/livemylife.css","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/scroll.css","path":"css/scroll.css","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/search.css","path":"css/search.css","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/themecolor.css","path":"css/themecolor.css","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/top.css","path":"css/top.css","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/viewer.min.css","path":"css/viewer.min.css","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/wave.css","path":"css/wave.css","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/busuanzi.pure.mini.js","path":"js/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/catalog.js","path":"js/catalog.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/scroll.js","path":"js/scroll.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/themecolor.js","path":"js/themecolor.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/ziploader.js","path":"js/ziploader.js","modified":0,"renderable":1},{"_id":"source/img/avatar/about-me.jpg","path":"img/avatar/about-me.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/archive_bg.jpg","path":"img/header_img/archive_bg.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/categories_bg.jpg","path":"img/header_img/categories_bg.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg.jpg","path":"img/header_img/home-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/post-bg-desk.jpg","path":"img/header_img/post-bg-desk.jpg","modified":0,"renderable":0},{"_id":"source/img/scenery/about_bg.jpg","path":"img/scenery/about_bg.jpg","modified":0,"renderable":0},{"_id":"source/img/scenery/about_bg4.jpg","path":"img/scenery/about_bg4.jpg","modified":0,"renderable":0},{"_id":"themes/livemylife/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/1-work/tools/create_gitee_repo.png","path":"img/1-work/tools/create_gitee_repo.png","modified":0,"renderable":0},{"_id":"source/img/1-work/tools/import-github-repo.png","path":"img/1-work/tools/import-github-repo.png","modified":0,"renderable":0},{"_id":"source/img/header_img/post-bg-swift.jpg","path":"img/header_img/post-bg-swift.jpg","modified":0,"renderable":0},{"_id":"source/img/scenery/treat_me_to_coffee.jpg","path":"img/scenery/treat_me_to_coffee.jpg","modified":0,"renderable":0},{"_id":"themes/livemylife/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/images/beside_up.png","path":"css/images/beside_up.png","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/images/beside_up2.png","path":"css/images/beside_up2.png","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/images/beside_up_white.png","path":"css/images/beside_up_white.png","modified":0,"renderable":1},{"_id":"themes/livemylife/source/css/images/beside_up_white2.png","path":"css/images/beside_up_white2.png","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/china-contour.js","path":"js/echarts/china-contour.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/china.js","path":"js/echarts/china.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/src/chinamap.js","path":"js/src/chinamap.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/viewer/pic-viewer.js","path":"js/viewer/pic-viewer.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/viewer/viewer.min.js","path":"js/viewer/viewer.min.js","modified":0,"renderable":1},{"_id":"source/img/header_img/dawn.jpg","path":"img/header_img/dawn.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tag_bg.jpg","path":"img/header_img/tag_bg.jpg","modified":0,"renderable":0},{"_id":"themes/livemylife/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/scenery/about_bg2.jpg","path":"img/scenery/about_bg2.jpg","modified":0,"renderable":0},{"_id":"themes/livemylife/source/js/echarts/province/aomen.js","path":"js/echarts/province/aomen.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/anhui.js","path":"js/echarts/province/anhui.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/beijing.js","path":"js/echarts/province/beijing.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/gansu.js","path":"js/echarts/province/gansu.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/guangxi.js","path":"js/echarts/province/guangxi.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/guizhou.js","path":"js/echarts/province/guizhou.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/hainan.js","path":"js/echarts/province/hainan.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/henan.js","path":"js/echarts/province/henan.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/hubei.js","path":"js/echarts/province/hubei.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/hunan.js","path":"js/echarts/province/hunan.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/jiangsu.js","path":"js/echarts/province/jiangsu.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/jiangxi.js","path":"js/echarts/province/jiangxi.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/jilin.js","path":"js/echarts/province/jilin.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/liaoning.js","path":"js/echarts/province/liaoning.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/neimenggu.js","path":"js/echarts/province/neimenggu.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/ningxia.js","path":"js/echarts/province/ningxia.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/qinghai.js","path":"js/echarts/province/qinghai.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/shanghai.js","path":"js/echarts/province/shanghai.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/shanxi.js","path":"js/echarts/province/shanxi.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/shanxi1.js","path":"js/echarts/province/shanxi1.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/taiwan.js","path":"js/echarts/province/taiwan.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/tianjin.js","path":"js/echarts/province/tianjin.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/xianggang.js","path":"js/echarts/province/xianggang.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/xizang.js","path":"js/echarts/province/xizang.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/zhejiang.js","path":"js/echarts/province/zhejiang.js","modified":0,"renderable":1},{"_id":"source/img/avatar/roguerabbit.jpg","path":"img/avatar/roguerabbit.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/squirrel.jpg","path":"img/header_img/squirrel.jpg","modified":0,"renderable":0},{"_id":"themes/livemylife/source/js/echarts/province/chongqing.js","path":"js/echarts/province/chongqing.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/fujian.js","path":"js/echarts/province/fujian.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/guangdong.js","path":"js/echarts/province/guangdong.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/hebei.js","path":"js/echarts/province/hebei.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/heilongjiang.js","path":"js/echarts/province/heilongjiang.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/shandong.js","path":"js/echarts/province/shandong.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/sichuan.js","path":"js/echarts/province/sichuan.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/xinjiang.js","path":"js/echarts/province/xinjiang.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/yunnan.js","path":"js/echarts/province/yunnan.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/world.js","path":"js/echarts/world.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/comment/gitalk.js","path":"js/comment/gitalk.js","modified":0,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/echarts.min.js","path":"js/echarts/echarts.min.js","modified":0,"renderable":1},{"_id":"source/img/backup/newhome_bg.jpg","path":"img/backup/newhome_bg.jpg","modified":0,"renderable":0},{"_id":"source/img/backup/mountain.jpg","path":"img/backup/mountain.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/404_bg.jpg","path":"img/header_img/404_bg.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/lml_bg.jpg","path":"img/header_img/lml_bg.jpg","modified":0,"renderable":0},{"_id":"source/img/backup/snow.jpg","path":"img/backup/snow.jpg","modified":0,"renderable":0},{"_id":"source/img/backup/room.jpg","path":"img/backup/room.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/archive_bg2.jpg","path":"img/header_img/archive_bg2.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"ec2d37d705a85fa3eaf6f32af4c8962f5c7ef230","modified":1608694066724},{"_id":"source/CNAME","hash":"8929eb36e7c7960e964c2fea3cd9b4253ed169df","modified":1608694066725},{"_id":"source/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1608694066725},{"_id":"source/_readme.txt","hash":"bddab7042d69720ee508338cfcde9d2b1ae901bf","modified":1608694066729},{"_id":"themes/livemylife/LICENSE","hash":"c48eaae47a703282e0ffe7b91d69366452046214","modified":1608694067097},{"_id":"themes/livemylife/_config.yml","hash":"cc81f0292e6d73b86b6722dafaf507cbb331d5d8","modified":1608805318752},{"_id":"source/_posts/algorithm-dp-thinking.md","hash":"6262fb97308bb1d1faa2ba986d1fe65c204be821","modified":1629290425588},{"_id":"source/_posts/algorithm-heap.md","hash":"c2ab6bf954ca98157a7bd14a3d14c03e30f62891","modified":1608715081754},{"_id":"source/_posts/algorithm-sort.md","hash":"b900e09094f17b71f9be5349b2df8ceae8516694","modified":1608715081750},{"_id":"source/_posts/algorithm-tree.md","hash":"62e1eaba26fc8bb29ebfcc7dfd11a2886a324bc3","modified":1608715081756},{"_id":"source/_posts/centos-config.md","hash":"e1c99d5befe3aadbe05edb39c7e84489c87ffe69","modified":1629290425595},{"_id":"source/_posts/git-push-error.md","hash":"2b4ae5e39bd2d79cef30a264d8f1f5174a36f6e3","modified":1629290369707},{"_id":"source/_posts/chinamap.md","hash":"2e8a18849f57e896e53e2ed0609a1e4796f3f760","modified":1629286484648},{"_id":"source/_posts/git-push-two-repo.md","hash":"f75811e034b6cd6ea114962ff8661db68c756838","modified":1629290425580},{"_id":"source/_posts/git-reset.md","hash":"2c843890d2d18783e07a8cb83be3074e94450580","modified":1629289967092},{"_id":"source/_posts/io.md","hash":"eb425a7077768a0cd39d8bd25b6eb1326e7ad85b","modified":1629290425515},{"_id":"source/_posts/java-nio.md","hash":"478eab136a9c459b02fb55c1f909abfa5bf662dc","modified":1629290425526},{"_id":"source/_posts/read-test.md","hash":"2c48de686846485145693e17f559f9d433ceb042","modified":1629290442166},{"_id":"source/_posts/read-test2.md","hash":"e1e2a7fb899b4bea2da057e5fdfab40cc87b3533","modified":1629290450754},{"_id":"source/_posts/redis.md","hash":"ecd47792efb11f3deabfe9f0c5d7ad962d8b78ec","modified":1629290442174},{"_id":"source/about/index.md","hash":"714bd1b7c2b44af868e897761dc399c31c074e8c","modified":1608715081573},{"_id":"source/archive/index.md","hash":"be1a8641113cecd36eb3f4ceba7295b3741c2d4c","modified":1608715081574},{"_id":"source/categories/index.md","hash":"4558ca9ef97c01361173ee1667d213bf5b8a9fc5","modified":1608715081574},{"_id":"source/tags/index.md","hash":"ff2c4849d59872b2eb0d8c989a419547610285ab","modified":1608715081575},{"_id":"themes/livemylife/languages_to_be_added/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1608694067098},{"_id":"themes/livemylife/languages_to_be_added/default.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1608694067098},{"_id":"themes/livemylife/languages_to_be_added/en.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1608694067099},{"_id":"themes/livemylife/languages_to_be_added/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1608694067099},{"_id":"themes/livemylife/languages_to_be_added/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1608694067100},{"_id":"themes/livemylife/languages_to_be_added/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1608694067100},{"_id":"themes/livemylife/languages_to_be_added/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1608694067182},{"_id":"themes/livemylife/languages_to_be_added/zh-CN.yml","hash":"6d712d9eb6ba12213dcd76b532cd86e9da83cfa3","modified":1608694067183},{"_id":"themes/livemylife/languages_to_be_added/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1608694067184},{"_id":"themes/livemylife/layout/404.ejs","hash":"c9b488d74c21fe9f35f642a5d19a138099ddf8a8","modified":1608694067186},{"_id":"themes/livemylife/layout/about.ejs","hash":"27b5aa49173e8b6430b987f7238eed5ac3ae7a91","modified":1608694067224},{"_id":"themes/livemylife/layout/archive.ejs","hash":"65b6e00ddec5e10e750dd1c95e28e0d0431a0290","modified":1608694067225},{"_id":"themes/livemylife/layout/categories.ejs","hash":"531e24e43acb79cfab313e4dc284fab98714e335","modified":1608694067225},{"_id":"themes/livemylife/layout/index.ejs","hash":"fd0e77ae3f35f2804f5a2269e80b636ee11f3474","modified":1608694067304},{"_id":"themes/livemylife/layout/keynote.ejs","hash":"2c92a060d8bbd256cc7367aec7e29e515bd00869","modified":1608694067306},{"_id":"themes/livemylife/layout/layout.ejs","hash":"ce3295ac27847954a2512064feeb8e9e9550665a","modified":1608694067307},{"_id":"themes/livemylife/layout/page.ejs","hash":"73ebc2a229add288e6b45b367f345c6eb558025d","modified":1608694067308},{"_id":"themes/livemylife/layout/post.ejs","hash":"7ec706f0b24ee02abafb77c4326568064f6aca10","modified":1629280584201},{"_id":"themes/livemylife/layout/tags.ejs","hash":"ad71cc7761bdb63dcc03c648960f6485dcc323c3","modified":1608694067311},{"_id":"themes/livemylife/source/baidu_verify_code-jayy2pLM52.html","hash":"58fc353e353e2dedb8bcd7f9ffe62ec1b2ba81d7","modified":1608714823780},{"_id":"themes/livemylife/source/google0915f5e354aeae89.html","hash":"dacc570438035c30f92d0c9d97eacc9b0f09cc46","modified":1608714823780},{"_id":"source/img/avatar/avatar.png","hash":"e6c1c40fb523d94779d95aa2dc7bf0b4259bacf2","modified":1608694066734},{"_id":"source/img/avatar/fatpeople.jpg","hash":"04cc046c50473ab78aee784df62f05448be8b884","modified":1608694066734},{"_id":"source/img/signature/vicky-white.png","hash":"efb6c7e1ccbded551759c9997b108a20c15f0c09","modified":1608696657146},{"_id":"themes/livemylife/layout/_partial/anchorjs.ejs","hash":"073df9003dc40e09af1c27438860c22d0bc8fe60","modified":1608694067188},{"_id":"themes/livemylife/layout/_partial/catalog.ejs","hash":"7aa559af2f890b6d925c06adb3454494657078cb","modified":1615897194103},{"_id":"themes/livemylife/layout/_partial/comment.ejs","hash":"5238690d6020c059f3326e6787a7a7f388cda5d8","modified":1608694067191},{"_id":"themes/livemylife/layout/_partial/gitter.ejs","hash":"7344d3e405d6387f6a8737730d1fb78161c992ce","modified":1629281394278},{"_id":"themes/livemylife/layout/_partial/footer.ejs","hash":"bcfc78567fed2eb45257e28b061c00c406d9e53e","modified":1608697483156},{"_id":"themes/livemylife/layout/_partial/head.ejs","hash":"e66ff129dd8842a71e025a4cace3127b4fb1c97a","modified":1608694067195},{"_id":"themes/livemylife/layout/_partial/header.ejs","hash":"0c6a22ee696961f8cb7649dbd36d2e5c199a67ef","modified":1608694067208},{"_id":"themes/livemylife/layout/_partial/nav.ejs","hash":"1d032afafec7863f0b131356258d8fd517202580","modified":1608805286737},{"_id":"themes/livemylife/layout/_partial/pagination.ejs","hash":"cd61e4dbbf6020ad094c8e66ec06e8c38ebcd122","modified":1608694067211},{"_id":"themes/livemylife/layout/_partial/search.ejs","hash":"33b8585dbdcc8a9e0164aeb747cd2ccd38f9bacf","modified":1608694067212},{"_id":"themes/livemylife/layout/_partial/sidebar.ejs","hash":"bc7834dd769eeac94a76ffd9cfbb13a622861b62","modified":1608694067213},{"_id":"themes/livemylife/layout/_partial/socialshare.ejs","hash":"1b50bdbc89731a0f04732aff9286ae945ecbe8b7","modified":1608694067214},{"_id":"themes/livemylife/layout/_partial/themecolor.ejs","hash":"fd4c8f2b3f2955bb867105991d45134798915526","modified":1608694067214},{"_id":"themes/livemylife/layout/_widget/archive.ejs","hash":"dc31e6cfde1b789d8550d7bfcac5d0eeae3ac6ab","modified":1608694067215},{"_id":"themes/livemylife/layout/_widget/category.ejs","hash":"1dc1187e7a04ee4be85bf302ea2618c1dbf6a570","modified":1608694067215},{"_id":"themes/livemylife/layout/_widget/featured-tags.ejs","hash":"a313e546c29243cfd59aa2dde0b4f99287613d31","modified":1608694067216},{"_id":"themes/livemylife/layout/_widget/friends-blog.ejs","hash":"3ef1c20bf1c93e4d1f9cecd54483c827c1fb0e3b","modified":1608805781439},{"_id":"themes/livemylife/layout/_widget/short-about.ejs","hash":"895b00fc58a40a2c40e91737fd62560d938823e2","modified":1608694067223},{"_id":"themes/livemylife/layout/_widget/recent-posts.ejs","hash":"acf2843b7262c2146d9639e8620a16192e626e24","modified":1608805696433},{"_id":"themes/livemylife/layout/_widget/visitor.ejs","hash":"7013d7cf81ce9997f1dd873c54a845b35dd9a929","modified":1608805756709},{"_id":"themes/livemylife/source/css/archive.styl","hash":"bcb216ef65804c97b1a5dbe5f519fc171a13aaf1","modified":1608694067513},{"_id":"themes/livemylife/source/css/beantech.css","hash":"bce245c3c8de02a7fda56d2c3dfc4ac529fcfbba","modified":1608694067514},{"_id":"themes/livemylife/source/css/beantech.min.css","hash":"fc88e09ad39e47b4302e57416d391f9dbe49f0ab","modified":1608694067516},{"_id":"themes/livemylife/source/css/catalog.styl","hash":"822aca17c885109452cc75a9aa384d9f3c07ea81","modified":1615895781459},{"_id":"themes/livemylife/source/css/gitalk.css","hash":"646a634ac252896d9e9f4d322d782e69c66d65ae","modified":1608694067535},{"_id":"themes/livemylife/source/css/highlight.styl","hash":"831f8195f3577ba5bea374f2e24b90054d445055","modified":1608694067536},{"_id":"themes/livemylife/source/css/highlight_normal.css","hash":"9885d5fb98646ca325ac790cfba6dc8a7be75fae","modified":1608694067538},{"_id":"themes/livemylife/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1608694067539},{"_id":"themes/livemylife/source/css/livemylife.css","hash":"08e549c0aad0ff94a9fae8eb91900b03bd428eee","modified":1608694067543},{"_id":"themes/livemylife/source/css/rocket.styl","hash":"5e3b4336496e01488bbb8f0bc444b9b24560482b","modified":1608694067543},{"_id":"themes/livemylife/source/css/scroll.css","hash":"ef16ea9eeb589e9334a0f071afb5f0cdaa34d69c","modified":1629286967343},{"_id":"themes/livemylife/source/css/search.css","hash":"fea98c6afa4f0be1deedb7cb13a9cd6b3ab6e42c","modified":1608694067544},{"_id":"themes/livemylife/source/css/signature.styl","hash":"63ae8051f59d5e69544647cc4173eabc81d99aae","modified":1608694067545},{"_id":"themes/livemylife/source/css/themecolor.css","hash":"ad64c21122111a96fc7601d35596da39b5697a31","modified":1608694067545},{"_id":"themes/livemylife/source/css/top.css","hash":"7fe7d9d4434fe2bb7178e0f43977b3869b5c0fdf","modified":1608694067546},{"_id":"themes/livemylife/source/css/viewer.min.css","hash":"bb52e4168e5b740d04bcabe3833f42e98f8037da","modified":1608694067546},{"_id":"themes/livemylife/source/css/wave.css","hash":"fb939f76dc9a48d3a7e7384f64943dac710ad452","modified":1608694067546},{"_id":"themes/livemylife/source/css/widget.styl","hash":"f996466e299c68274145ba5afaca9b6d1dd83114","modified":1608694067580},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1608694067581},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1608694067583},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1608694067584},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1608694067585},{"_id":"themes/livemylife/source/js/bootstrap.min.js","hash":"313da686ebbe387064f2d1899c64ea562b81eb40","modified":1608694067586},{"_id":"themes/livemylife/source/js/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1608694067587},{"_id":"themes/livemylife/source/js/catalog.js","hash":"4e34f47053ece8c1a4ab4a8441760a3d33ea9fb8","modified":1608694067587},{"_id":"themes/livemylife/source/js/hux-blog.js","hash":"3d3c93e42a9990b2a2e6df5a08e9816f9a221e0f","modified":1608694067593},{"_id":"themes/livemylife/source/js/hux-blog.min.js","hash":"ee99af17a1a69ac8d85a695fed0349ba202789ae","modified":1608694067594},{"_id":"themes/livemylife/source/js/jquery.nav.js","hash":"bc6383fa2aa8f437978cf044a3b6f10a65114398","modified":1608694067598},{"_id":"themes/livemylife/source/js/jquery.tagcloud.js","hash":"448017ff32f75f444ed7985d10a21b3ad92ab100","modified":1608694067599},{"_id":"themes/livemylife/source/js/scroll.js","hash":"182250b3bee27de24099863f0973bb7971405464","modified":1608694067599},{"_id":"themes/livemylife/source/js/themecolor.js","hash":"af8f6d9b97f6511d55ce2266987a3540770f1f54","modified":1608694067600},{"_id":"themes/livemylife/source/js/totop.js","hash":"f796b09b4f6177c3674a8c1542a8c92e8590cb5c","modified":1608694067600},{"_id":"themes/livemylife/source/js/ziploader.js","hash":"f61a11e60be24cf0c64019ca4dc4dc49c325ed71","modified":1608694067602},{"_id":"source/img/avatar/about-me.jpg","hash":"4fc7c645f502bb38cb2a672bd95d478e8be0493a","modified":1608694066734},{"_id":"source/img/header_img/archive_bg.jpg","hash":"fc4bdf7fa98346ea35115151e4914cd1e5a946d9","modified":1608694066937},{"_id":"source/img/header_img/categories_bg.jpg","hash":"a8a46a06f566e13a919d9cbca6a66ae5a3b78b1e","modified":1608694066992},{"_id":"source/img/header_img/home-bg.jpg","hash":"6bbe3de397f929a7ca0a49c88779a4a8dd904a88","modified":1608266116630},{"_id":"source/img/header_img/post-bg-desk.jpg","hash":"6bbe3de397f929a7ca0a49c88779a4a8dd904a88","modified":1608694067071},{"_id":"source/img/scenery/about_bg.jpg","hash":"462c14b9b00ab2153e579f14cb1e44aa56704ce8","modified":1608694067076},{"_id":"source/img/scenery/about_bg4.jpg","hash":"272f0d4233aea38f32311439f8528d2b3bebd546","modified":1608694067079},{"_id":"themes/livemylife/source/css/bootstrap.min.css","hash":"1818a346630e7133a1f194669f613f613fcfa97c","modified":1608694067521},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.svg","hash":"4dcf0ab896f5417047f881de91bad10dcbda48c6","modified":1608694067583},{"_id":"themes/livemylife/source/js/bootstrap.js","hash":"5d69034fb6eded2e5961ea54dd47129a88cd5182","modified":1608694067586},{"_id":"themes/livemylife/source/js/jquery.min.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1608694067598},{"_id":"source/img/1-work/tools/create_gitee_repo.png","hash":"ebd7bd2ba944d5428c2f8b0f58e2d4477952ee63","modified":1608694066732},{"_id":"source/img/1-work/tools/import-github-repo.png","hash":"4ecfeb1dd598d0a17e278da065c38a5523823250","modified":1608694066732},{"_id":"source/img/header_img/post-bg-swift.jpg","hash":"12552e545ca35a93f0050a5417de5d302f1a4f5e","modified":1608694067072},{"_id":"source/img/scenery/treat_me_to_coffee.jpg","hash":"e307178429b98962ff3918e12427b3e7db6d10df","modified":1620811483138},{"_id":"themes/livemylife/source/css/bootstrap.css","hash":"d1a24afac31222d70b4e001e0361ef045aa42043","modified":1608694067519},{"_id":"themes/livemylife/source/css/images/beside_up.png","hash":"183d87f1a99e93fc663ec798fa8c94cb87c83bcb","modified":1608694067540},{"_id":"themes/livemylife/source/css/images/beside_up2.png","hash":"ef066ba2e93a4738df45ae05020726e066c4dd1f","modified":1608694067541},{"_id":"themes/livemylife/source/css/images/beside_up_white.png","hash":"49c5922a8de63dcf9468fbcffc70d2ec36b1b527","modified":1608694067542},{"_id":"themes/livemylife/source/css/images/beside_up_white2.png","hash":"52e9d5715def1d3d09ab076d5eb3d22916d8f7d7","modified":1608694067543},{"_id":"themes/livemylife/source/js/echarts/china-contour.js","hash":"0225cfc644a5c2637fe1ec4d4b484ac98c795f57","modified":1629188595214},{"_id":"themes/livemylife/source/js/echarts/china.js","hash":"257ce5a930299c64cb553df29e25525c0ec3e61d","modified":1629188595216},{"_id":"themes/livemylife/source/js/src/chinamap.js","hash":"37bb53e16eca9e5f0f8ff1b5581286d651aec3b4","modified":1629283176864},{"_id":"themes/livemylife/source/js/viewer/pic-viewer.js","hash":"3955cbca226b562f8dec96dc459ce22363affdde","modified":1608694067601},{"_id":"themes/livemylife/source/js/viewer/viewer.min.js","hash":"b09fff2aa41305e8975b9ef80514eb937ffa6866","modified":1608694067601},{"_id":"source/img/header_img/dawn.jpg","hash":"2e9291c0a9d255c203fb11fd4f471b28459287b0","modified":1617194884571},{"_id":"source/img/header_img/tag_bg.jpg","hash":"35131c8b7ab3943c9fe4577329cd1c412d1c4fac","modified":1608694067074},{"_id":"themes/livemylife/source/js/jquery.js","hash":"4bb763dc96da604aed08ac024a1a3f5de73eea39","modified":1608694067596},{"_id":"source/img/scenery/about_bg2.jpg","hash":"bdffbe6a94f9c5be1b9353fc2b4f28a74677939f","modified":1608694067077},{"_id":"themes/livemylife/source/js/echarts/province/aomen.js","hash":"11f222c130f9cc87e0e018683156d28b52f994c1","modified":1629188595217},{"_id":"themes/livemylife/source/js/echarts/province/anhui.js","hash":"4b7f9d4f66fea46de56b11e33a09902b41f3b189","modified":1629188595216},{"_id":"themes/livemylife/source/js/echarts/province/beijing.js","hash":"c03a45938203f6a120b560bc5795e0f9b50e306b","modified":1629188595218},{"_id":"themes/livemylife/source/js/echarts/province/gansu.js","hash":"752ffb8364d41189be3f56776cb0073c81239faf","modified":1629188595220},{"_id":"themes/livemylife/source/js/echarts/province/guangxi.js","hash":"d90d69a65e4647dc22f9dba484bf9cca251da9f8","modified":1629188595222},{"_id":"themes/livemylife/source/js/echarts/province/guizhou.js","hash":"e2bb9ee386dc1a42a7ebf946ca279f62eb031588","modified":1629188595222},{"_id":"themes/livemylife/source/js/echarts/province/hainan.js","hash":"e21dbef4bccdd6e68f5c8a8b7b3f7baea016e9fc","modified":1629188595223},{"_id":"themes/livemylife/source/js/echarts/province/henan.js","hash":"03ec5ba7f53c28a3c089df8380e2396af14ad93f","modified":1629188595226},{"_id":"themes/livemylife/source/js/echarts/province/hubei.js","hash":"646984ff668489a284fe0759dec0e39e7acde92b","modified":1629188595227},{"_id":"themes/livemylife/source/js/echarts/province/hunan.js","hash":"023b265c451fc493aaa3752a39e78b2f0a41a785","modified":1629188595228},{"_id":"themes/livemylife/source/js/echarts/province/jiangsu.js","hash":"065a6eb051ea4542945e2e252dca5cc20dc945ac","modified":1629188595229},{"_id":"themes/livemylife/source/js/echarts/province/jiangxi.js","hash":"802e96c605f0197f4aa5d3376343724e8ef9b42b","modified":1629188595230},{"_id":"themes/livemylife/source/js/echarts/province/jilin.js","hash":"def2607d79d4ab6042423959186b85376155fdb5","modified":1629188595230},{"_id":"themes/livemylife/source/js/echarts/province/liaoning.js","hash":"17e8430d6fa40a48b2e738ff662502082a2d91e5","modified":1629188595231},{"_id":"themes/livemylife/source/js/echarts/province/neimenggu.js","hash":"bcf193eeaf3dda18b60497ecc786918b8a3e96b4","modified":1629188595232},{"_id":"themes/livemylife/source/js/echarts/province/ningxia.js","hash":"605de70524801df678f15ccf496f0a57fdb04681","modified":1629188595233},{"_id":"themes/livemylife/source/js/echarts/province/qinghai.js","hash":"d7050d87ce6d9b74684b337e65eda5bba4e0fe03","modified":1629188595234},{"_id":"themes/livemylife/source/js/echarts/province/shanghai.js","hash":"76b55d3134adba18ecdc326b3beb018eb2c76c9f","modified":1629188595235},{"_id":"themes/livemylife/source/js/echarts/province/shanxi.js","hash":"c5685d23a6a79503d517118d3ffd3c7bbea56652","modified":1629188595236},{"_id":"themes/livemylife/source/js/echarts/province/shanxi1.js","hash":"b6c1e380cf5f2a316148d78c1d7f0477b090444a","modified":1629188595237},{"_id":"themes/livemylife/source/js/echarts/province/taiwan.js","hash":"7f7022d903838f93ca6f2866a38b31163c9b281a","modified":1629188595239},{"_id":"themes/livemylife/source/js/echarts/province/tianjin.js","hash":"652346249098d8e4a43ca21ed8d20522be6ba09c","modified":1629188595240},{"_id":"themes/livemylife/source/js/echarts/province/xianggang.js","hash":"b738ad64d347819ba4a4375a8ddc2f696d9703bb","modified":1629188595240},{"_id":"themes/livemylife/source/js/echarts/province/xizang.js","hash":"066206af5271569f1b5af8432440abe7130aa662","modified":1629188595243},{"_id":"themes/livemylife/source/js/echarts/province/zhejiang.js","hash":"06b1b0d82ce6798146960be00b197e4a113a6a20","modified":1629188595245},{"_id":"source/img/avatar/roguerabbit.jpg","hash":"3c71801016fc2b587c128d42f45438f523bb1a1a","modified":1608694066736},{"_id":"source/img/header_img/squirrel.jpg","hash":"6d9fe36a3a2d362fa2308e894088a11b39426c96","modified":1617194988485},{"_id":"themes/livemylife/source/js/echarts/province/chongqing.js","hash":"aa25fb13a753b090909a918b4df574185d87511a","modified":1629188595218},{"_id":"themes/livemylife/source/js/echarts/province/fujian.js","hash":"227f72a65a6c374fd069cc22a508626569150d55","modified":1629188595219},{"_id":"themes/livemylife/source/js/echarts/province/guangdong.js","hash":"1a2829e44a4ac909eb3809e8b5cb3e3b8c1729c6","modified":1629188595221},{"_id":"themes/livemylife/source/js/echarts/province/hebei.js","hash":"9a4d49228d1057a7ce518b14fa4410901cdaae56","modified":1629188595224},{"_id":"themes/livemylife/source/js/echarts/province/heilongjiang.js","hash":"1225f0ff7513e9e7a75000b6ff506f372d243f32","modified":1629188595225},{"_id":"themes/livemylife/source/js/echarts/province/shandong.js","hash":"97a40d871d466533fcec763535e26a5c3d408575","modified":1629188595235},{"_id":"themes/livemylife/source/js/echarts/province/sichuan.js","hash":"8af12cef60b4399637bba7d9751798fa596a328d","modified":1629188595238},{"_id":"themes/livemylife/source/js/echarts/province/xinjiang.js","hash":"ae47a9f3d1037ca4abaa903ca278a34d921778ba","modified":1629188595242},{"_id":"themes/livemylife/source/js/echarts/province/yunnan.js","hash":"cb76984339e025fdeab74a7db2d8c4c7b89e46d9","modified":1629188595244},{"_id":"themes/livemylife/source/js/echarts/world.js","hash":"f150ad7d7574de382858357c59dd21cc9b892673","modified":1629188595247},{"_id":"themes/livemylife/source/js/comment/gitalk.js","hash":"9e326313656b821751f486e31be8418e1578668a","modified":1608694067592},{"_id":"themes/livemylife/source/js/echarts/echarts.min.js","hash":"98a3a8fe7db39a99800bf68368ef7544e4f30a69","modified":1629188593729},{"_id":"source/img/backup/newhome_bg.jpg","hash":"d770c4659027f3d4fe479afb6909ed6968f56d68","modified":1608694067069},{"_id":"source/img/backup/mountain.jpg","hash":"2acefcb91238d3d17bea6c53881fb8c025ebe370","modified":1608694066764},{"_id":"source/img/header_img/404_bg.jpg","hash":"9a899c297a352c1664d0b7ec44d5fbc0c8c048fd","modified":1608694066935},{"_id":"source/img/header_img/lml_bg.jpg","hash":"c572aa5a4ed446f43c898c3864bf8b144844ef35","modified":1608694067046},{"_id":"source/img/backup/snow.jpg","hash":"0cf9fb6a4fdad42dcc936dc9e90cfd3e5b7b8cef","modified":1608694066882},{"_id":"source/img/backup/room.jpg","hash":"e2b6831e4cdbb323c5d680ef053e414926119bec","modified":1608694066842},{"_id":"source/img/header_img/archive_bg2.jpg","hash":"ecc208724bde2e07787a9b83191f6e1c755c1422","modified":1608694066990},{"_id":"public/sitemap.xml","hash":"76a4c75c2586ea00dd25d2776c256dc6944d3ab5","modified":1629290457187},{"_id":"public/searchVersion.json","hash":"2b1144fd626a0bc3c189e7091aeb8feee7ae2bbd","modified":1629290457187},{"_id":"public/baidusitemap.xml","hash":"4137437052c3d120534a944b569012f0a173a53f","modified":1629290457187},{"_id":"public/404.html","hash":"a1cedbcfab41a5182c004199a3e088e6f66a58d0","modified":1629290457187},{"_id":"public/tags/index.html","hash":"d7e6a9b5b94159a0ee4ab37afa73ff92e33e9a1c","modified":1629290457187},{"_id":"public/categories/index.html","hash":"4a63f92abbb6708c8b437c71c5d22d610fdfb829","modified":1629290457187},{"_id":"public/2021/08/18/6186.html","hash":"d740f950272c7756190c1a7da6ad774caba23ba6","modified":1629290457187},{"_id":"public/2021/08/18/9f70.html","hash":"8f90170cfce6577526aed2011b74e5bec570a00c","modified":1629290457187},{"_id":"public/2021/08/17/86e5.html","hash":"4a1f554094322b554ad1f8b84cef74ff2e63bb65","modified":1629290457187},{"_id":"public/2021/05/12/f6ae.html","hash":"1031de081198841aec0e919b6357cc5c3e452acb","modified":1629290457187},{"_id":"public/2021/03/31/57bd.html","hash":"1dd8eeadd232c812b15ece2c65819eb646266cd0","modified":1629290457187},{"_id":"public/2021/03/24/1af5.html","hash":"39b21cd5e837cf1808e6c107f833893e05a786bc","modified":1629290457187},{"_id":"public/2021/03/18/a10a.html","hash":"f8094722504f9d4d0aefa3b5008b898a4eb27e01","modified":1629290457187},{"_id":"public/2021/03/16/130.html","hash":"eae83af8ec13250ec73a9f0703f6d1b13bb2d6a9","modified":1629290457187},{"_id":"public/2020/12/22/73b3.html","hash":"e14b7319f71e89e9794105d5d6e2f0251d356450","modified":1629290457187},{"_id":"public/2020/12/21/211a.html","hash":"b3cec023e6d074485010aad912c583d1c54be50d","modified":1629290457187},{"_id":"public/2020/12/21/c608.html","hash":"4a591c386d63bf9d2ef0ec0d566511cb8b8e38ef","modified":1629290457187},{"_id":"public/2020/12/20/c15d.html","hash":"4f01df39983b308968a2f11db08ed8012cb5a211","modified":1629290457187},{"_id":"public/2020/12/19/7b21.html","hash":"59d1c5251069fd676aa1cdbb6b4a6639f622dee9","modified":1629290457187},{"_id":"public/2020/12/18/1af5.html","hash":"6c719a4a6ca9777aa30e9554a727d5b455807326","modified":1629290457187},{"_id":"public/about/index.html","hash":"4cd20e012631742c4ced770a5d871d32c5b30d6e","modified":1629290457187},{"_id":"public/archive/index.html","hash":"d6628dea95d0fb86fe7bdd88f655a729bdddd3fc","modified":1629290457187},{"_id":"public/categories/work/index.html","hash":"37889295916c27218399ccca126046b36c93a269","modified":1629290457187},{"_id":"public/categories/work/archives/2/index.html","hash":"73886b7e97425a24c8be5f5a4eb7ee6de7600730","modified":1629290457187},{"_id":"public/categories/life/index.html","hash":"e54c21793335351045c9ed110c64aab080172fb1","modified":1629290457187},{"_id":"public/index.html","hash":"f6bacb4fc1d441c6564f27d6e2b646525716ec29","modified":1629290457187},{"_id":"public/archives/2/index.html","hash":"a6fc1b0ef050d24cd75aae92a5fdee9899343226","modified":1629290457187},{"_id":"public/tags/algorithm/index.html","hash":"887d3e8d30e1cac012a69fecb32fd07a680692e4","modified":1629290457187},{"_id":"public/tags/tools/index.html","hash":"135d78bdc8bbcd211edd4fc521f7bd3ee8e64f62","modified":1629290457187},{"_id":"public/tags/git/index.html","hash":"19d2368e4b01c9fee4e0aec8bed9570486239334","modified":1629290457187},{"_id":"public/tags/map/index.html","hash":"ba83d8bf5944de9c75102c594ee13f3debf1fe43","modified":1629290457187},{"_id":"public/tags/finance/index.html","hash":"29806daf525fcf604d5bb66afdece5e38ddb5ce4","modified":1629290457187},{"_id":"public/tags/IO/index.html","hash":"2e68df381c76c1431c1e97582d0ee1ffc3f5ca7b","modified":1629290457187},{"_id":"public/archives/index.html","hash":"3432bc74408e9c5fd15307ea2f7f3fd1d59aadb0","modified":1629290457187},{"_id":"public/archives/archives/2/index.html","hash":"95669392213f72c2b0faf688edab4a3c005419e7","modified":1629290457187},{"_id":"public/archives/2020/index.html","hash":"468005eaa7920de8f1ee5209b3f7e6ab219f2d2c","modified":1629290457187},{"_id":"public/archives/2020/12/index.html","hash":"fa72e88c538c70dd5f538e5a07028a98a16afc88","modified":1629290457187},{"_id":"public/archives/2021/index.html","hash":"2f248651532016767f3cbb5ca6d2f7a68b1d0b41","modified":1629290457187},{"_id":"public/archives/2021/03/index.html","hash":"c2e6c8fd746ebfae6503729f0552241b0e303c84","modified":1629290457187},{"_id":"public/archives/2021/05/index.html","hash":"c43898dd8bfe5047e1c20e0414b6f878c2649a07","modified":1629290457187},{"_id":"public/archives/2021/08/index.html","hash":"e7a3f9ddd1099c9c943a40dd2c55242f8efaa3fc","modified":1629290457187},{"_id":"public/CNAME","hash":"8929eb36e7c7960e964c2fea3cd9b4253ed169df","modified":1629290457187},{"_id":"public/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1629290457187},{"_id":"public/img/avatar/avatar.png","hash":"e6c1c40fb523d94779d95aa2dc7bf0b4259bacf2","modified":1629290457187},{"_id":"public/img/avatar/fatpeople.jpg","hash":"04cc046c50473ab78aee784df62f05448be8b884","modified":1629290457187},{"_id":"public/img/signature/vicky-white.png","hash":"efb6c7e1ccbded551759c9997b108a20c15f0c09","modified":1629290457187},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1629290457187},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1629290457187},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1629290457187},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1629290457187},{"_id":"public/img/1-work/tools/create_gitee_repo.png","hash":"ebd7bd2ba944d5428c2f8b0f58e2d4477952ee63","modified":1629290457187},{"_id":"public/img/1-work/tools/import-github-repo.png","hash":"4ecfeb1dd598d0a17e278da065c38a5523823250","modified":1629290457187},{"_id":"public/css/images/beside_up.png","hash":"183d87f1a99e93fc663ec798fa8c94cb87c83bcb","modified":1629290457187},{"_id":"public/css/images/beside_up_white.png","hash":"49c5922a8de63dcf9468fbcffc70d2ec36b1b527","modified":1629290457187},{"_id":"public/css/images/beside_up2.png","hash":"ef066ba2e93a4738df45ae05020726e066c4dd1f","modified":1629290457187},{"_id":"public/css/images/beside_up_white2.png","hash":"52e9d5715def1d3d09ab076d5eb3d22916d8f7d7","modified":1629290457187},{"_id":"public/img/avatar/about-me.jpg","hash":"4fc7c645f502bb38cb2a672bd95d478e8be0493a","modified":1629290457187},{"_id":"public/img/header_img/archive_bg.jpg","hash":"fc4bdf7fa98346ea35115151e4914cd1e5a946d9","modified":1629290457187},{"_id":"public/img/header_img/categories_bg.jpg","hash":"a8a46a06f566e13a919d9cbca6a66ae5a3b78b1e","modified":1629290457187},{"_id":"public/img/header_img/home-bg.jpg","hash":"6bbe3de397f929a7ca0a49c88779a4a8dd904a88","modified":1629290457187},{"_id":"public/img/header_img/post-bg-desk.jpg","hash":"6bbe3de397f929a7ca0a49c88779a4a8dd904a88","modified":1629290457187},{"_id":"public/img/scenery/about_bg.jpg","hash":"462c14b9b00ab2153e579f14cb1e44aa56704ce8","modified":1629290457187},{"_id":"public/img/scenery/about_bg4.jpg","hash":"272f0d4233aea38f32311439f8528d2b3bebd546","modified":1629290457187},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"4dcf0ab896f5417047f881de91bad10dcbda48c6","modified":1629290457187},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1629290457187},{"_id":"public/css/catalog.css","hash":"2062bf4e5b219654e0d4bf470f5eef1be213da95","modified":1629290457187},{"_id":"public/css/highlight.css","hash":"03d1f0a648e9bdf7b1f57d217313cbac5d0c7eb1","modified":1629290457187},{"_id":"public/css/highlight_normal.css","hash":"6a40a9a0f268fb17d9002cb49a16946444ef5f34","modified":1629290457187},{"_id":"public/css/livemylife.css","hash":"dbf2b89627f55e7f8ef12730e822319859f25767","modified":1629290457187},{"_id":"public/css/rocket.css","hash":"ec8abdba1cdd362d03fd8ffe182213aa4cbd449c","modified":1629290457187},{"_id":"public/css/scroll.css","hash":"ba16b97532dd6aaec66a82f3c33cc989d361fa7a","modified":1629290457187},{"_id":"public/css/search.css","hash":"a941f2f3d05d43e0a1517ae6923e848638b9ff7c","modified":1629290457187},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1629290457187},{"_id":"public/css/top.css","hash":"0303375fbe2ca942cd3d86f31d12fef9bf5785af","modified":1629290457187},{"_id":"public/css/viewer.min.css","hash":"0e045aa3df1be7d138caa701ec3aa623ccc7a52d","modified":1629290457187},{"_id":"public/css/wave.css","hash":"041f3b4a78e2840ba17679cea05fb14bb646722f","modified":1629290457187},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1629290457187},{"_id":"public/js/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1629290457187},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1629290457187},{"_id":"public/js/catalog.js","hash":"059f3f31492e5b1a9dddf422a48c32969d247415","modified":1629290457187},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1629290457187},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1629290457187},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1629290457187},{"_id":"public/js/scroll.js","hash":"265a4c4fc33b5b44b620db64ff31d2bc05d233e9","modified":1629290457187},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1629290457187},{"_id":"public/js/themecolor.js","hash":"8295e112233778d8f20c31b06c19659f60edbb22","modified":1629290457187},{"_id":"public/js/echarts/china-contour.js","hash":"46069d796fb1dd191cdd6a0806570700ae9c0347","modified":1629290457187},{"_id":"public/js/src/chinamap.js","hash":"37bb53e16eca9e5f0f8ff1b5581286d651aec3b4","modified":1629290457187},{"_id":"public/js/viewer/pic-viewer.js","hash":"9bf7c37cce781628346803ed7ce8f02623c2d013","modified":1629290457187},{"_id":"public/js/echarts/province/aomen.js","hash":"8558d9a5bf394a03d93ea85159c828d23b9b56d6","modified":1629290457187},{"_id":"public/js/echarts/province/ningxia.js","hash":"c25daa696558129fe018ff7c5de6126eabfda663","modified":1629290457187},{"_id":"public/js/echarts/province/shanghai.js","hash":"456974123ab5ed51993e6e7fba8f200f556c0751","modified":1629290457187},{"_id":"public/js/echarts/province/xianggang.js","hash":"c34ca0c6974964b776ab64aff135a6630dac86ed","modified":1629290457187},{"_id":"public/js/echarts/province/tianjin.js","hash":"c0f4bb6ae03bd3175203fd9cd70983059a3a636f","modified":1629290457187},{"_id":"public/baidu_verify_code-jayy2pLM52.html","hash":"58fc353e353e2dedb8bcd7f9ffe62ec1b2ba81d7","modified":1629290457187},{"_id":"public/google0915f5e354aeae89.html","hash":"dacc570438035c30f92d0c9d97eacc9b0f09cc46","modified":1629290457187},{"_id":"public/css/beantech.css","hash":"c192d3170301f774fa4c2185dc125cb3d6ec4929","modified":1629290457187},{"_id":"public/css/gitalk.css","hash":"51783fd60dff05e8e339ff83b41504538662f6ca","modified":1629290457187},{"_id":"public/css/beantech.min.css","hash":"66f124242893cae4517119e39e75d7f23eef01ae","modified":1629290457187},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1629290457187},{"_id":"public/css/themecolor.css","hash":"725b0e534f7c6c80e2e9a47d1c93ee9f03d7458a","modified":1629290457187},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1629290457187},{"_id":"public/js/ziploader.js","hash":"9c25324caf53b56cb68839dcfb34e61e5a6a63f3","modified":1629290457187},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1629290457187},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1629290457187},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1629290457187},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1629290457187},{"_id":"public/js/echarts/china.js","hash":"0aaf91ed666621d0aa269d4ee5e1c0a9dc06235e","modified":1629290457187},{"_id":"public/js/viewer/viewer.min.js","hash":"ae5380974b6fb8b0e15356c8418186c6c0821222","modified":1629290457187},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1629290457187},{"_id":"public/js/echarts/province/anhui.js","hash":"a17708654277222014c1ba7005dd58bc7b6d54ce","modified":1629290457187},{"_id":"public/js/echarts/province/gansu.js","hash":"e030cf4fbe48b2467176771dbee9adc4111f47de","modified":1629290457187},{"_id":"public/js/echarts/province/beijing.js","hash":"1f33aeb4ff666ceefa75c304f3f853f5dd3591a1","modified":1629290457187},{"_id":"public/js/echarts/province/guangxi.js","hash":"31ed274566e6369e568be67588033f43c2e902be","modified":1629290457187},{"_id":"public/js/echarts/province/guizhou.js","hash":"9eac20cb6f36e717d364ca2c4860292b8fe1128e","modified":1629290457187},{"_id":"public/js/echarts/province/hunan.js","hash":"b49abde15a3e60ae3898c0f2f5989c7a759c20c2","modified":1629290457187},{"_id":"public/js/echarts/province/hubei.js","hash":"4797d4615ee167b8711091ab4eea1e97a4c545bd","modified":1629290457187},{"_id":"public/js/echarts/province/jiangsu.js","hash":"15a2820d2b1829614befd24fde73b69568ff7d4f","modified":1629290457187},{"_id":"public/js/echarts/province/jiangxi.js","hash":"dc078183c43df9e91cfb46b02e9e7fdcb7a96ca3","modified":1629290457187},{"_id":"public/js/echarts/province/jilin.js","hash":"737c4416708b1ef3b49be328ed7a9896439df1d3","modified":1629290457187},{"_id":"public/js/echarts/province/hainan.js","hash":"10b313c1fdfe1a966163c92c333a766e10e96d27","modified":1629290457187},{"_id":"public/js/echarts/province/neimenggu.js","hash":"f26fcccdce99132d24c54f99d52179a11b30269a","modified":1629290457187},{"_id":"public/js/echarts/province/qinghai.js","hash":"25dd767a0d1ddbea6db57f0ab86ab315215dec1d","modified":1629290457187},{"_id":"public/js/echarts/province/liaoning.js","hash":"250fbaa3cb8297139e348249243eab6b277d24b6","modified":1629290457187},{"_id":"public/js/echarts/province/henan.js","hash":"a7c25e0f04470c5da5f36d70738156c35228ef7e","modified":1629290457187},{"_id":"public/js/echarts/province/taiwan.js","hash":"1a18b39463a2a15dfb96d1823f84bd91b0099a04","modified":1629290457187},{"_id":"public/js/echarts/province/shanxi.js","hash":"da043410b84996e2fc7c27b8010497ad45a9e464","modified":1629290457187},{"_id":"public/js/echarts/province/xizang.js","hash":"9e51acbff27c6b4664dbaf37adcfb851e8acd025","modified":1629290457187},{"_id":"public/js/echarts/province/chongqing.js","hash":"55661b00c1bfc3d505466c6b3c9a06df826ffa45","modified":1629290457187},{"_id":"public/js/echarts/province/shanxi1.js","hash":"d16d41750d066776846329dd44691d39cc9a133e","modified":1629290457187},{"_id":"public/js/echarts/province/fujian.js","hash":"9c125baa9912134be8b28336ef70cdec842f195a","modified":1629290457187},{"_id":"public/js/echarts/province/guangdong.js","hash":"e199d2277a076aafea04e8531ed621b792ae63cd","modified":1629290457187},{"_id":"public/js/echarts/province/heilongjiang.js","hash":"bd0453fc68288a5f1886ce233a54823377e73132","modified":1629290457187},{"_id":"public/js/echarts/province/zhejiang.js","hash":"4768c4a4aee38ff6f2568fe8c7b33a3555145220","modified":1629290457187},{"_id":"public/js/echarts/province/shandong.js","hash":"2f8035028a27dc47fe85bb8c8f3700c08c546a55","modified":1629290457187},{"_id":"public/js/echarts/province/sichuan.js","hash":"917d59cccf0a4eb98ae71f3e4ef5b5e508415352","modified":1629290457187},{"_id":"public/js/echarts/province/xinjiang.js","hash":"f432c61109275274fac2c20e69103f6c96f287c9","modified":1629290457187},{"_id":"public/js/echarts/province/yunnan.js","hash":"183aeee5c67ea236a51bf31ad1e89aeb2feacd4b","modified":1629290457187},{"_id":"public/js/echarts/world.js","hash":"7c57299eabf0e80868d447830ddfef1290695193","modified":1629290457187},{"_id":"public/js/echarts/province/hebei.js","hash":"d76f7ffba58d553d50acba3114c9cc776d0d59e4","modified":1629290457187},{"_id":"public/img/scenery/treat_me_to_coffee.jpg","hash":"e307178429b98962ff3918e12427b3e7db6d10df","modified":1629290457187},{"_id":"public/img/header_img/post-bg-swift.jpg","hash":"12552e545ca35a93f0050a5417de5d302f1a4f5e","modified":1629290457187},{"_id":"public/img/header_img/dawn.jpg","hash":"2e9291c0a9d255c203fb11fd4f471b28459287b0","modified":1629290457187},{"_id":"public/js/comment/gitalk.js","hash":"9256bc4b8f7341f60083da291d5c7c9f0fe5f1bd","modified":1629290457187},{"_id":"public/js/echarts/echarts.min.js","hash":"eec6c0cc35c819602747de4574b4d77a773ae6bc","modified":1629290457187},{"_id":"public/img/header_img/tag_bg.jpg","hash":"35131c8b7ab3943c9fe4577329cd1c412d1c4fac","modified":1629290457187},{"_id":"public/img/header_img/squirrel.jpg","hash":"6d9fe36a3a2d362fa2308e894088a11b39426c96","modified":1629290457187},{"_id":"public/img/avatar/roguerabbit.jpg","hash":"3c71801016fc2b587c128d42f45438f523bb1a1a","modified":1629290457187},{"_id":"public/img/scenery/about_bg2.jpg","hash":"bdffbe6a94f9c5be1b9353fc2b4f28a74677939f","modified":1629290457187},{"_id":"public/img/backup/newhome_bg.jpg","hash":"d770c4659027f3d4fe479afb6909ed6968f56d68","modified":1629290457187},{"_id":"public/img/backup/mountain.jpg","hash":"2acefcb91238d3d17bea6c53881fb8c025ebe370","modified":1629290457187},{"_id":"public/img/header_img/404_bg.jpg","hash":"9a899c297a352c1664d0b7ec44d5fbc0c8c048fd","modified":1629290457187},{"_id":"public/img/header_img/lml_bg.jpg","hash":"c572aa5a4ed446f43c898c3864bf8b144844ef35","modified":1629290457187},{"_id":"public/img/backup/snow.jpg","hash":"0cf9fb6a4fdad42dcc936dc9e90cfd3e5b7b8cef","modified":1629290457187},{"_id":"public/img/backup/room.jpg","hash":"e2b6831e4cdbb323c5d680ef053e414926119bec","modified":1629290457187},{"_id":"public/img/header_img/archive_bg2.jpg","hash":"ecc208724bde2e07787a9b83191f6e1c755c1422","modified":1629290457187}],"Category":[{"name":"work","_id":"ckshhgzix0005iobf1wh2dcfr"},{"name":"life","_id":"ckshhgzji000riobf2s6lc45h"}],"Data":[],"Page":[{"layout":"404","description":"I'm sorry there is nothing that you want , but you can enjoy the scenery here ...","header-img":"img/header_img/404_bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"I'm sorry there is nothing that you want , but you can enjoy the scenery here ...\"\nheader-img: \"img/header_img/404_bg.jpg\"\n---\n","date":"2020-12-23T03:27:46.724Z","updated":"2020-12-23T03:27:46.724Z","path":"404.html","title":"","comments":1,"_id":"ckshhgzh60000iobf7hnr33zd","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","description":"Sleep early. Please.","header-img":"img/header_img/post-bg-swift.jpg","_content":"\n## Follow With Interest Blogs\n\n> Sage Renn：https://sagerenn.github.io/\n\n\n## Contact me\n\n> Email：vicky123.luo@outlook.com\n\n## Treat me to coffee\n>  If you feel that what I have written is of some value to you, I am glad that you are willing to invite me to drink coffee...\n\n<img src=\"../img/scenery/treat_me_to_coffee.jpg\" width=\"350\" alt=\"treat_me_to_coffee.jpg\"></img>\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Sleep early. Please.\"\nheader-img: \"img/header_img/post-bg-swift.jpg\"\n---\n\n## Follow With Interest Blogs\n\n> Sage Renn：https://sagerenn.github.io/\n\n\n## Contact me\n\n> Email：vicky123.luo@outlook.com\n\n## Treat me to coffee\n>  If you feel that what I have written is of some value to you, I am glad that you are willing to invite me to drink coffee...\n\n<img src=\"../img/scenery/treat_me_to_coffee.jpg\" width=\"350\" alt=\"treat_me_to_coffee.jpg\"></img>\n","updated":"2020-12-23T09:18:01.573Z","path":"about/index.html","comments":1,"_id":"ckshhgzit0002iobffg4q1ov0","content":"<h2 id=\"Follow-With-Interest-Blogs\"><a href=\"#Follow-With-Interest-Blogs\" class=\"headerlink\" title=\"Follow With Interest Blogs\"></a>Follow With Interest Blogs</h2><blockquote>\n<p>Sage Renn：<a href=\"https://sagerenn.github.io/\" target=\"_blank\" rel=\"noopener\">https://sagerenn.github.io/</a></p>\n</blockquote>\n<h2 id=\"Contact-me\"><a href=\"#Contact-me\" class=\"headerlink\" title=\"Contact me\"></a>Contact me</h2><blockquote>\n<p>Email：<a href=\"mailto:vicky123.luo@outlook.com\">vicky123.luo@outlook.com</a></p>\n</blockquote>\n<h2 id=\"Treat-me-to-coffee\"><a href=\"#Treat-me-to-coffee\" class=\"headerlink\" title=\"Treat me to coffee\"></a>Treat me to coffee</h2><blockquote>\n<p> If you feel that what I have written is of some value to you, I am glad that you are willing to invite me to drink coffee…</p>\n</blockquote>\n<p><img src=\"../img/scenery/treat_me_to_coffee.jpg\" width=\"350\" alt=\"treat_me_to_coffee.jpg\"></img></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Follow-With-Interest-Blogs\"><a href=\"#Follow-With-Interest-Blogs\" class=\"headerlink\" title=\"Follow With Interest Blogs\"></a>Follow With Interest Blogs</h2><blockquote>\n<p>Sage Renn：<a href=\"https://sagerenn.github.io/\" target=\"_blank\" rel=\"noopener\">https://sagerenn.github.io/</a></p>\n</blockquote>\n<h2 id=\"Contact-me\"><a href=\"#Contact-me\" class=\"headerlink\" title=\"Contact me\"></a>Contact me</h2><blockquote>\n<p>Email：<a href=\"mailto:vicky123.luo@outlook.com\">vicky123.luo@outlook.com</a></p>\n</blockquote>\n<h2 id=\"Treat-me-to-coffee\"><a href=\"#Treat-me-to-coffee\" class=\"headerlink\" title=\"Treat me to coffee\"></a>Treat me to coffee</h2><blockquote>\n<p> If you feel that what I have written is of some value to you, I am glad that you are willing to invite me to drink coffee…</p>\n</blockquote>\n<p><img src=\"../img/scenery/treat_me_to_coffee.jpg\" width=\"350\" alt=\"treat_me_to_coffee.jpg\"></img></p>\n"},{"layout":"tags","title":"Tags","description":"Make life better.","header-img":"img/header_img/tag_bg.jpg","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Make life better.\"\nheader-img: \"img/header_img/tag_bg.jpg\"\n---\n","date":"2020-12-23T09:18:01.575Z","updated":"2020-12-23T09:18:01.575Z","path":"tags/index.html","comments":1,"_id":"ckshhgziw0004iobf9lil9pjj","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive_bg.jpg","date":"2020-12-23T04:49:56.000Z","description":"Stay hungry, stay foolish.","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive_bg.jpg\"\ndate: 2020-12-23 12:49:56\ndescription: \"Stay hungry, stay foolish.\"\n---\n","updated":"2020-12-23T09:18:01.574Z","path":"archive/index.html","comments":1,"_id":"ckshhgzj10008iobf5d834uf2","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"categories","title":"Categories","description":"Life should be easy.","header-img":"img/header_img/categories_bg.jpg","_content":"","source":"categories/index.md","raw":"---\nlayout: \"categories\"\ntitle: \"Categories\"\ndescription: \"Life should be easy.\"\nheader-img: \"img/header_img/categories_bg.jpg\"\n---\n","date":"2020-12-23T09:18:01.574Z","updated":"2020-12-23T09:18:01.574Z","path":"categories/index.html","comments":1,"_id":"ckshhgzj3000aiobf1b7e44w8","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"动态规划问题解题思路","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":null,"abbrlink":"f6ae","subtitle":null,"_content":"\n### 动态规划问题解题思路\n\n动态规划问题一般形式是求最值，求最值问题核心是穷举，要把所有答案列举出来找最值。但是，动态规划问题存在`重叠子问题`，暴力穷举效率极低，可以使用`备忘录`或`DP table`来优化穷举过程。而且，我们可以通过寻找`最优子结构`，及通过子问题的最值得到原问题的最值。动态规划问题千变万化，只有列出正确的`状态转移方程`，才能正确的穷举，这也是最困难的地方。\n\n综上，动态规划三要素：重叠子问题、最优子结构、状态转移方程。\n\n#### 确定状态转移方程思路：\n\n**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。\n\n```java\n# 初始化 base case\ndp[0][0][...] = base\n# 进行状态转移\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] = 求最值(选择1，选择2...)\n```\n\n","source":"_posts/algorithm-dp-thinking.md","raw":"---\ntitle: 动态规划问题解题思路\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop:\ntags:\n  - algorithm\ncategories:\n  - work\nabbrlink: f6ae\nsubtitle:\n---\n\n### 动态规划问题解题思路\n\n动态规划问题一般形式是求最值，求最值问题核心是穷举，要把所有答案列举出来找最值。但是，动态规划问题存在`重叠子问题`，暴力穷举效率极低，可以使用`备忘录`或`DP table`来优化穷举过程。而且，我们可以通过寻找`最优子结构`，及通过子问题的最值得到原问题的最值。动态规划问题千变万化，只有列出正确的`状态转移方程`，才能正确的穷举，这也是最困难的地方。\n\n综上，动态规划三要素：重叠子问题、最优子结构、状态转移方程。\n\n#### 确定状态转移方程思路：\n\n**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。\n\n```java\n# 初始化 base case\ndp[0][0][...] = base\n# 进行状态转移\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] = 求最值(选择1，选择2...)\n```\n\n","slug":"algorithm-dp-thinking","published":1,"date":"2021-05-12T01:42:24.000Z","updated":"2021-08-18T12:40:25.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshhgziq0001iobff8m9bgw5","content":"<h3 id=\"动态规划问题解题思路\"><a href=\"#动态规划问题解题思路\" class=\"headerlink\" title=\"动态规划问题解题思路\"></a>动态规划问题解题思路</h3><p>动态规划问题一般形式是求最值，求最值问题核心是穷举，要把所有答案列举出来找最值。但是，动态规划问题存在<code>重叠子问题</code>，暴力穷举效率极低，可以使用<code>备忘录</code>或<code>DP table</code>来优化穷举过程。而且，我们可以通过寻找<code>最优子结构</code>，及通过子问题的最值得到原问题的最值。动态规划问题千变万化，只有列出正确的<code>状态转移方程</code>，才能正确的穷举，这也是最困难的地方。</p>\n<p>综上，动态规划三要素：重叠子问题、最优子结构、状态转移方程。</p>\n<h4 id=\"确定状态转移方程思路：\"><a href=\"#确定状态转移方程思路：\" class=\"headerlink\" title=\"确定状态转移方程思路：\"></a>确定状态转移方程思路：</h4><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 初始化 base case</span><br><span class=\"line\">dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][...] = base</span><br><span class=\"line\"># 进行状态转移</span><br><span class=\"line\"><span class=\"keyword\">for</span> 状态<span class=\"number\">1</span> in 状态<span class=\"number\">1</span>的所有取值：</span><br><span class=\"line\">    <span class=\"keyword\">for</span> 状态<span class=\"number\">2</span> in 状态<span class=\"number\">2</span>的所有取值：</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ...</span><br><span class=\"line\">            dp[状态<span class=\"number\">1</span>][状态<span class=\"number\">2</span>][...] = 求最值(选择<span class=\"number\">1</span>，选择<span class=\"number\">2</span>...)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"动态规划问题解题思路\"><a href=\"#动态规划问题解题思路\" class=\"headerlink\" title=\"动态规划问题解题思路\"></a>动态规划问题解题思路</h3><p>动态规划问题一般形式是求最值，求最值问题核心是穷举，要把所有答案列举出来找最值。但是，动态规划问题存在<code>重叠子问题</code>，暴力穷举效率极低，可以使用<code>备忘录</code>或<code>DP table</code>来优化穷举过程。而且，我们可以通过寻找<code>最优子结构</code>，及通过子问题的最值得到原问题的最值。动态规划问题千变万化，只有列出正确的<code>状态转移方程</code>，才能正确的穷举，这也是最困难的地方。</p>\n<p>综上，动态规划三要素：重叠子问题、最优子结构、状态转移方程。</p>\n<h4 id=\"确定状态转移方程思路：\"><a href=\"#确定状态转移方程思路：\" class=\"headerlink\" title=\"确定状态转移方程思路：\"></a>确定状态转移方程思路：</h4><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 初始化 base case</span><br><span class=\"line\">dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][...] = base</span><br><span class=\"line\"># 进行状态转移</span><br><span class=\"line\"><span class=\"keyword\">for</span> 状态<span class=\"number\">1</span> in 状态<span class=\"number\">1</span>的所有取值：</span><br><span class=\"line\">    <span class=\"keyword\">for</span> 状态<span class=\"number\">2</span> in 状态<span class=\"number\">2</span>的所有取值：</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ...</span><br><span class=\"line\">            dp[状态<span class=\"number\">1</span>][状态<span class=\"number\">2</span>][...] = 求最值(选择<span class=\"number\">1</span>，选择<span class=\"number\">2</span>...)</span><br></pre></td></tr></table></figure>\n\n"},{"title":"数据结构与算法---堆","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":0,"abbrlink":"73b3","date":"2020-12-21T16:00:00.000Z","subtitle":null,"_content":"### 数据结构与算法---大顶堆\n### 数据结构与算法---小顶堆\n### 数据结构与算法---优先级队列\n### 数据结构与算法---斐波那契堆\n### 数据结构与算法---二项堆\n","source":"_posts/algorithm-heap.md","raw":"---\ntitle: 数据结构与算法---堆\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop: 0\ntags:\n  - algorithm\ncategories:\n  - work\nabbrlink: 73b3\ndate: 2020-12-22 00:00:00\nsubtitle:\n---\n### 数据结构与算法---大顶堆\n### 数据结构与算法---小顶堆\n### 数据结构与算法---优先级队列\n### 数据结构与算法---斐波那契堆\n### 数据结构与算法---二项堆\n","slug":"algorithm-heap","published":1,"updated":"2020-12-23T09:18:01.754Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshhgziu0003iobfgatzggus","content":"<h3 id=\"数据结构与算法—大顶堆\"><a href=\"#数据结构与算法—大顶堆\" class=\"headerlink\" title=\"数据结构与算法—大顶堆\"></a>数据结构与算法—大顶堆</h3><h3 id=\"数据结构与算法—小顶堆\"><a href=\"#数据结构与算法—小顶堆\" class=\"headerlink\" title=\"数据结构与算法—小顶堆\"></a>数据结构与算法—小顶堆</h3><h3 id=\"数据结构与算法—优先级队列\"><a href=\"#数据结构与算法—优先级队列\" class=\"headerlink\" title=\"数据结构与算法—优先级队列\"></a>数据结构与算法—优先级队列</h3><h3 id=\"数据结构与算法—斐波那契堆\"><a href=\"#数据结构与算法—斐波那契堆\" class=\"headerlink\" title=\"数据结构与算法—斐波那契堆\"></a>数据结构与算法—斐波那契堆</h3><h3 id=\"数据结构与算法—二项堆\"><a href=\"#数据结构与算法—二项堆\" class=\"headerlink\" title=\"数据结构与算法—二项堆\"></a>数据结构与算法—二项堆</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"数据结构与算法—大顶堆\"><a href=\"#数据结构与算法—大顶堆\" class=\"headerlink\" title=\"数据结构与算法—大顶堆\"></a>数据结构与算法—大顶堆</h3><h3 id=\"数据结构与算法—小顶堆\"><a href=\"#数据结构与算法—小顶堆\" class=\"headerlink\" title=\"数据结构与算法—小顶堆\"></a>数据结构与算法—小顶堆</h3><h3 id=\"数据结构与算法—优先级队列\"><a href=\"#数据结构与算法—优先级队列\" class=\"headerlink\" title=\"数据结构与算法—优先级队列\"></a>数据结构与算法—优先级队列</h3><h3 id=\"数据结构与算法—斐波那契堆\"><a href=\"#数据结构与算法—斐波那契堆\" class=\"headerlink\" title=\"数据结构与算法—斐波那契堆\"></a>数据结构与算法—斐波那契堆</h3><h3 id=\"数据结构与算法—二项堆\"><a href=\"#数据结构与算法—二项堆\" class=\"headerlink\" title=\"数据结构与算法—二项堆\"></a>数据结构与算法—二项堆</h3>"},{"title":"VirtualBox新建Centos虚机环境配置","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":null,"abbrlink":"130","subtitle":null,"_content":"\n### 一、全局代理设置\n\n修改 /etc/profile 文件,添加下面内容:\n\n```\nhttp_proxy=http://name:pwd@ip:port\nhttps_proxy=http://name:pwd@ip:port\nftp_proxy=http://name:pwd@ip:port\nexport http_proxy\nexport https_proxy\nexport ftp_proxy\n```\n\n使全局配置生效\n\n```\n[root@lcoalhost]# source /etc/profile\n```\n\n若只针对某个用户而言,则修改 ~/.bash_profile 文件,添加相同内容;\n\n修改完成后,注销重新登录即可。\n\n### 二、yum代理设置\n\n修改 /etc/yum.conf，添加下面内容:\n\n```\nhttp_proxy=http://name:pwd@ip:port\n```\n\n保存退出后，就可以使用yum轻松的安装软件了。\n\n### 三、wget代理设置\n\n修改/etc/wgetrc，添加下面内容:\n\n```\nhttp_proxy = http://name:pwd@ip:port\nftp_proxy = http://name:pwd@ip:port\n```\n\n### 四、网络配置\n\nVirtualBox主机网络管理器中需要创建一张Host-Only网卡，并手动配置网卡地址及DHCP服务器。虚机启动时会根据dhcp服务器配置自动分配地址。\n\n虚机设置中启用两张网卡，网卡一连接方式为桥接网卡，网卡二连接方式为仅主机（Host-Only）网络。\n\n虚机中，安装net-tools依赖包：\n\n```\n[root@lcoalhost]# yum -y install net-tools\n```\n\n查看网卡是否启用（是否分配ip，是否能ping通主机）：\n\n```\n[root@lcoalhost]# ifconfig\nenp0s3: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 10.112.118.81  netmask 255.255.254.0  broadcast 10.112.119.255 \n        inet6 fe80::f41f:d:f042:d8ae  prefixlen 64  scopeid 0x20<link> \n        ether 08:00:27:fb:62:61  txqueuelen 1000  (Ethernet) //ether对应第一张网卡的mac\n        RX packets 220530  bytes 251839085 (240.1 MiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 42719  bytes 2891040 (2.7 MiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\nenp0s8: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.56.103  netmask 255.255.255.0  broadcast 192.168.56.255 // inet对应dhcp地址池中的地址\n        inet6 fe80::5ff8:c6c:90:9239  prefixlen 64  scopeid 0x20<link>\n        ether 08:00:27:96:49:8d  txqueuelen 1000  (Ethernet) //ether对应第二张网卡的mac\n        RX packets 62911  bytes 3926194 (3.7 MiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 117073  bytes 10861798 (10.3 MiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n```\n\n### 五、git代理设置\n\n```\n[root@lcoalhost]# yun -y install git\n[root@lcoalhost]# git config --global https.proxy http://name:pwd@ip:port\n[root@lcoalhost]# git config --global http.proxy http://name:pwd@ip:port\n```\n\n### 六、docker 安装\n\n1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。\n\n通过 uname -r 命令查看你当前的内核版本\n\n```\n [root@lcoalhost]# uname -r\n```\n\n2、使用 root 权限登录 Centos。确保 yum 包更新到最新。\n\n```\n[root@lcoalhost]# sudo yum update\n```\n\n\n3、卸载旧版本(如果安装过旧版本的话)\n\n```\n[root@lcoalhost]#sudo yum remove docker  docker-common docker-selinux docker-engine\n```\n\n4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的\n\n```\n[root@lcoalhost]# sudo yum install -y yum-utils device-mapper-persistent-data lvm2\n```\n\n5、设置yum源\n\n```\n[root@lcoalhost]# sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n 重新设置阿里镜像网站（有时候也很慢）\n\n```\n[root@lcoalhost]# yum-config-manager --add-repo http://mirrors.aliyun.com/dockerce/linux/centos/docker-ce.repo\n```\n\n6、可以查看所有仓库中所有docker版本，并选择特定版本安装\n\n```\n[root@lcoalhost]# yum list docker-ce --showduplicates | sort -r\n```\n\n7、安装docker\n\n```\n[root@lcoalhost]# sudo yum install docker-ce  #由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0\n[root@lcoalhost]# sudo yum install <FQPN>  # 例如：sudo yum install docker-ce-17.12.0.ce\n```\n\n8、启动并加入开机启动\n\n```\n[root@lcoalhost]# sudo systemctl start docker\n[root@lcoalhost]# sudo systemctl enable docker\n```\n\n\n9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)\n\n```\n[root@lcoalhost]# docker version\n```\n\n### 七、设置docker 代理\n\n```\n[root@lcoalhost]# mkdir -p /etc/systemd/system/docker.service.d\n[root@lcoalhost]# cat > /etc/systemd/system/docker.service.d/https-proxy.conf << EOF\n[Service]\nEnvironment=\"http://name:pwd@ip:port\" \"HTTPS_PROXY=http://name:pwd@ip:port\" \nEOF\n[root@lcoalhost]# systemctl daemon-reload\n[root@lcoalhost]# systemctl restart docker\n[root@lcoalhost]# systemctl show --property=Environment docker\n```\n\ndocker 镜像加速，docker客户端版本大于 1.10.0 ,可修改daemon配置文件/etc/docker/daemon.json来使用加速器\n\n```\n[root@lcoalhost]#sudo mkdir -p /etc/docker\n[root@lcoalhost]#sudo tee /etc/docker/daemon.json <<-'EOF'\n{\n\"registry-mirrors\": [\"https://4ld4cyzt.mirror.aliyuncs.com\"]\n}\nEOF\n[root@lcoalhost]#sudo systemctl daemon-reload\n[root@lcoalhost]#sudo systemctl restart docker\n```\n\n\n\n### 八、docker中安装Mysql\n\n拉取mysql镜像\n\n```\n[root@lcoalhost]# docker pull mysql:5.7\n5.7: Pulling from library/mysql\n123275d6e508: Already exists \n27cddf5c7140: Pull complete \nc17d442e14c9: Pull complete \n2eb72ffed068: Pull complete \nd4aa125eb616: Pull complete \n52560afb169c: Pull complete \n68190f37a1d2: Pull complete \n3fd1dc6e2990: Pull complete \n85a79b83df29: Pull complete \n35e0b437fe88: Pull complete \n992f6a10268c: Pull complete \nDigest: sha256:82b72085b2fcff073a6616b84c7c3bcbb36e2d13af838cec11a9ed1d0b183f5e\nStatus: Downloaded newer image for mysql:5.7\ndocker.io/library/mysql:5.7\n```\n\n查看镜像\n\n```\n[root@lcoalhost]# docker images\nREPOSITORY  TAG    IMAGE ID     CREATED       SIZE\nmysql       5.7    f5829c0eee9e 2 hours ago   455MB\n[root@lcoalhost]# \n```\n\n启动mysql\n\n```shell\nsudo docker run -p 3306:3306 --name mysql \\\n-v /mydata/mysql/log:/var/log/mysql \\\n-v /mydata/mysql/data:/var/lib/mysql \\\n-v /mydata/mysql/conf:/etc/mysql \\\n-e MYSQL_ROOT_PASSWORD=root \\\n-d mysql:5.7\n```\n\n修改配置\n\n```\n[root@lcoalhost]# cd /mydata/mysql/conf\n// 配置如下：\n[root@lcoalhost conf]# cat my.cnf\n[client]\ndefault-character-set=utf8\n[mysql]\ndefault-character-set=utf8\n[mysqld]\ninit_connect='SET collation_connection = utf8_unicode_ci'\ninit_connect='SET NAMES utf8'\ncharacter-set-server=utf8\ncollation-server=utf8_unicode_ci\nskip-character-set-client-handshake\nskip-name-resolve\n\n[root@lcoalhost conf]# docker restart mysql\nmysql\n[root@lcoalhost conf]# \n```\n\n进入容器查看配置是否生效：\n\n```shell\n[root@lcoalhost conf]# docker exec -it mysql /bin/bash\nroot@b3a74e031bd7:/# whereis mysql\nmysql: /usr/bin/mysql /usr/lib/mysql /etc/mysql /usr/share/mysql\n\nroot@b3a74e031bd7:/# ls /etc/mysql \nmy.cnf\nroot@b3a74e031bd7:/# cat /etc/mysql/my.cnf \n[client]\ndefault-character-set=utf8\n[mysql]\ndefault-character-set=utf8\n[mysqld]\ninit_connect='SET collation_connection = utf8_unicode_ci'\ninit_connect='SET NAMES utf8'\ncharacter-set-server=utf8\ncollation-server=utf8_unicode_ci\nskip-character-set-client-handshake\nskip-name-resolve\nroot@b3a74e031bd7:/# \n```\n\n设置mysql随docker启动\n\n```\n[root@lcoalhost ~]# docker update mysql --restart=always\nmysql\n```\n\n### 九、docker中安装Redis\n\n拉取redis镜像\n\n```shell\n[root@lcoalhost ~]# docker pull redis\nUsing default tag: latest\nlatest: Pulling from library/redis\n123275d6e508: Already exists \nf2edbd6a658e: Pull complete \n66960bede47c: Pull complete \n79dc0b596c90: Pull complete \nde36df38e0b6: Pull complete \n602cd484ff92: Pull complete \nDigest: sha256:1d0b903e3770c2c3c79961b73a53e963f4fd4b2674c2c4911472e8a054cb5728\nStatus: Downloaded newer image for redis:latest\ndocker.io/library/redis:latest\n```\n\n启动\n\n```shell\n[root@lcoalhost ~]# mkdir -p /mydata/redis/conf\n[root@lcoalhost ~]# touch /mydata/redis/conf/redis.conf\n[root@lcoalhost ~]# echo \"appendonly yes\"  >> /mydata/redis/conf/redis.conf // 开启数据持久化\n[root@lcoalhost ~]# docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \\\n -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\\n -d redis redis-server /etc/redis/redis.conf\nce7ae709711986e3f90c9278b284fe6f51f1c1102ba05f3692f0e934ceca1565\n```\n\n 连接docker中的redis\n\n```shell\n[root@lcoalhost ~]# docker exec -it redis redis-cli\n127.0.0.1:6379> set key1 v1\nOK\n127.0.0.1:6379> get key1\n\"v1\"\n```\n\n设置redis随docker启动\n\n```shell\n[root@lcoalhost ~]# docker update redis --restart=always\nredis\n```\n\n\n\n","source":"_posts/centos-config.md","raw":"---\ntitle: VirtualBox新建Centos虚机环境配置\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop:\ntags:\n  - tools\ncategories:\n  - work\nabbrlink: '130'\nsubtitle:\n---\n\n### 一、全局代理设置\n\n修改 /etc/profile 文件,添加下面内容:\n\n```\nhttp_proxy=http://name:pwd@ip:port\nhttps_proxy=http://name:pwd@ip:port\nftp_proxy=http://name:pwd@ip:port\nexport http_proxy\nexport https_proxy\nexport ftp_proxy\n```\n\n使全局配置生效\n\n```\n[root@lcoalhost]# source /etc/profile\n```\n\n若只针对某个用户而言,则修改 ~/.bash_profile 文件,添加相同内容;\n\n修改完成后,注销重新登录即可。\n\n### 二、yum代理设置\n\n修改 /etc/yum.conf，添加下面内容:\n\n```\nhttp_proxy=http://name:pwd@ip:port\n```\n\n保存退出后，就可以使用yum轻松的安装软件了。\n\n### 三、wget代理设置\n\n修改/etc/wgetrc，添加下面内容:\n\n```\nhttp_proxy = http://name:pwd@ip:port\nftp_proxy = http://name:pwd@ip:port\n```\n\n### 四、网络配置\n\nVirtualBox主机网络管理器中需要创建一张Host-Only网卡，并手动配置网卡地址及DHCP服务器。虚机启动时会根据dhcp服务器配置自动分配地址。\n\n虚机设置中启用两张网卡，网卡一连接方式为桥接网卡，网卡二连接方式为仅主机（Host-Only）网络。\n\n虚机中，安装net-tools依赖包：\n\n```\n[root@lcoalhost]# yum -y install net-tools\n```\n\n查看网卡是否启用（是否分配ip，是否能ping通主机）：\n\n```\n[root@lcoalhost]# ifconfig\nenp0s3: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 10.112.118.81  netmask 255.255.254.0  broadcast 10.112.119.255 \n        inet6 fe80::f41f:d:f042:d8ae  prefixlen 64  scopeid 0x20<link> \n        ether 08:00:27:fb:62:61  txqueuelen 1000  (Ethernet) //ether对应第一张网卡的mac\n        RX packets 220530  bytes 251839085 (240.1 MiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 42719  bytes 2891040 (2.7 MiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\nenp0s8: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.56.103  netmask 255.255.255.0  broadcast 192.168.56.255 // inet对应dhcp地址池中的地址\n        inet6 fe80::5ff8:c6c:90:9239  prefixlen 64  scopeid 0x20<link>\n        ether 08:00:27:96:49:8d  txqueuelen 1000  (Ethernet) //ether对应第二张网卡的mac\n        RX packets 62911  bytes 3926194 (3.7 MiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 117073  bytes 10861798 (10.3 MiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n```\n\n### 五、git代理设置\n\n```\n[root@lcoalhost]# yun -y install git\n[root@lcoalhost]# git config --global https.proxy http://name:pwd@ip:port\n[root@lcoalhost]# git config --global http.proxy http://name:pwd@ip:port\n```\n\n### 六、docker 安装\n\n1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。\n\n通过 uname -r 命令查看你当前的内核版本\n\n```\n [root@lcoalhost]# uname -r\n```\n\n2、使用 root 权限登录 Centos。确保 yum 包更新到最新。\n\n```\n[root@lcoalhost]# sudo yum update\n```\n\n\n3、卸载旧版本(如果安装过旧版本的话)\n\n```\n[root@lcoalhost]#sudo yum remove docker  docker-common docker-selinux docker-engine\n```\n\n4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的\n\n```\n[root@lcoalhost]# sudo yum install -y yum-utils device-mapper-persistent-data lvm2\n```\n\n5、设置yum源\n\n```\n[root@lcoalhost]# sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n 重新设置阿里镜像网站（有时候也很慢）\n\n```\n[root@lcoalhost]# yum-config-manager --add-repo http://mirrors.aliyun.com/dockerce/linux/centos/docker-ce.repo\n```\n\n6、可以查看所有仓库中所有docker版本，并选择特定版本安装\n\n```\n[root@lcoalhost]# yum list docker-ce --showduplicates | sort -r\n```\n\n7、安装docker\n\n```\n[root@lcoalhost]# sudo yum install docker-ce  #由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0\n[root@lcoalhost]# sudo yum install <FQPN>  # 例如：sudo yum install docker-ce-17.12.0.ce\n```\n\n8、启动并加入开机启动\n\n```\n[root@lcoalhost]# sudo systemctl start docker\n[root@lcoalhost]# sudo systemctl enable docker\n```\n\n\n9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)\n\n```\n[root@lcoalhost]# docker version\n```\n\n### 七、设置docker 代理\n\n```\n[root@lcoalhost]# mkdir -p /etc/systemd/system/docker.service.d\n[root@lcoalhost]# cat > /etc/systemd/system/docker.service.d/https-proxy.conf << EOF\n[Service]\nEnvironment=\"http://name:pwd@ip:port\" \"HTTPS_PROXY=http://name:pwd@ip:port\" \nEOF\n[root@lcoalhost]# systemctl daemon-reload\n[root@lcoalhost]# systemctl restart docker\n[root@lcoalhost]# systemctl show --property=Environment docker\n```\n\ndocker 镜像加速，docker客户端版本大于 1.10.0 ,可修改daemon配置文件/etc/docker/daemon.json来使用加速器\n\n```\n[root@lcoalhost]#sudo mkdir -p /etc/docker\n[root@lcoalhost]#sudo tee /etc/docker/daemon.json <<-'EOF'\n{\n\"registry-mirrors\": [\"https://4ld4cyzt.mirror.aliyuncs.com\"]\n}\nEOF\n[root@lcoalhost]#sudo systemctl daemon-reload\n[root@lcoalhost]#sudo systemctl restart docker\n```\n\n\n\n### 八、docker中安装Mysql\n\n拉取mysql镜像\n\n```\n[root@lcoalhost]# docker pull mysql:5.7\n5.7: Pulling from library/mysql\n123275d6e508: Already exists \n27cddf5c7140: Pull complete \nc17d442e14c9: Pull complete \n2eb72ffed068: Pull complete \nd4aa125eb616: Pull complete \n52560afb169c: Pull complete \n68190f37a1d2: Pull complete \n3fd1dc6e2990: Pull complete \n85a79b83df29: Pull complete \n35e0b437fe88: Pull complete \n992f6a10268c: Pull complete \nDigest: sha256:82b72085b2fcff073a6616b84c7c3bcbb36e2d13af838cec11a9ed1d0b183f5e\nStatus: Downloaded newer image for mysql:5.7\ndocker.io/library/mysql:5.7\n```\n\n查看镜像\n\n```\n[root@lcoalhost]# docker images\nREPOSITORY  TAG    IMAGE ID     CREATED       SIZE\nmysql       5.7    f5829c0eee9e 2 hours ago   455MB\n[root@lcoalhost]# \n```\n\n启动mysql\n\n```shell\nsudo docker run -p 3306:3306 --name mysql \\\n-v /mydata/mysql/log:/var/log/mysql \\\n-v /mydata/mysql/data:/var/lib/mysql \\\n-v /mydata/mysql/conf:/etc/mysql \\\n-e MYSQL_ROOT_PASSWORD=root \\\n-d mysql:5.7\n```\n\n修改配置\n\n```\n[root@lcoalhost]# cd /mydata/mysql/conf\n// 配置如下：\n[root@lcoalhost conf]# cat my.cnf\n[client]\ndefault-character-set=utf8\n[mysql]\ndefault-character-set=utf8\n[mysqld]\ninit_connect='SET collation_connection = utf8_unicode_ci'\ninit_connect='SET NAMES utf8'\ncharacter-set-server=utf8\ncollation-server=utf8_unicode_ci\nskip-character-set-client-handshake\nskip-name-resolve\n\n[root@lcoalhost conf]# docker restart mysql\nmysql\n[root@lcoalhost conf]# \n```\n\n进入容器查看配置是否生效：\n\n```shell\n[root@lcoalhost conf]# docker exec -it mysql /bin/bash\nroot@b3a74e031bd7:/# whereis mysql\nmysql: /usr/bin/mysql /usr/lib/mysql /etc/mysql /usr/share/mysql\n\nroot@b3a74e031bd7:/# ls /etc/mysql \nmy.cnf\nroot@b3a74e031bd7:/# cat /etc/mysql/my.cnf \n[client]\ndefault-character-set=utf8\n[mysql]\ndefault-character-set=utf8\n[mysqld]\ninit_connect='SET collation_connection = utf8_unicode_ci'\ninit_connect='SET NAMES utf8'\ncharacter-set-server=utf8\ncollation-server=utf8_unicode_ci\nskip-character-set-client-handshake\nskip-name-resolve\nroot@b3a74e031bd7:/# \n```\n\n设置mysql随docker启动\n\n```\n[root@lcoalhost ~]# docker update mysql --restart=always\nmysql\n```\n\n### 九、docker中安装Redis\n\n拉取redis镜像\n\n```shell\n[root@lcoalhost ~]# docker pull redis\nUsing default tag: latest\nlatest: Pulling from library/redis\n123275d6e508: Already exists \nf2edbd6a658e: Pull complete \n66960bede47c: Pull complete \n79dc0b596c90: Pull complete \nde36df38e0b6: Pull complete \n602cd484ff92: Pull complete \nDigest: sha256:1d0b903e3770c2c3c79961b73a53e963f4fd4b2674c2c4911472e8a054cb5728\nStatus: Downloaded newer image for redis:latest\ndocker.io/library/redis:latest\n```\n\n启动\n\n```shell\n[root@lcoalhost ~]# mkdir -p /mydata/redis/conf\n[root@lcoalhost ~]# touch /mydata/redis/conf/redis.conf\n[root@lcoalhost ~]# echo \"appendonly yes\"  >> /mydata/redis/conf/redis.conf // 开启数据持久化\n[root@lcoalhost ~]# docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \\\n -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\\n -d redis redis-server /etc/redis/redis.conf\nce7ae709711986e3f90c9278b284fe6f51f1c1102ba05f3692f0e934ceca1565\n```\n\n 连接docker中的redis\n\n```shell\n[root@lcoalhost ~]# docker exec -it redis redis-cli\n127.0.0.1:6379> set key1 v1\nOK\n127.0.0.1:6379> get key1\n\"v1\"\n```\n\n设置redis随docker启动\n\n```shell\n[root@lcoalhost ~]# docker update redis --restart=always\nredis\n```\n\n\n\n","slug":"centos-config","published":1,"date":"2021-03-16T11:28:51.937Z","updated":"2021-08-18T12:40:25.595Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshhgzj00007iobfgg4e2bcf","content":"<h3 id=\"一、全局代理设置\"><a href=\"#一、全局代理设置\" class=\"headerlink\" title=\"一、全局代理设置\"></a>一、全局代理设置</h3><p>修改 /etc/profile 文件,添加下面内容:</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">http_proxy</span>=http://name:pwd@ip:port</span><br><span class=\"line\"><span class=\"attribute\">https_proxy</span>=http://name:pwd@ip:port</span><br><span class=\"line\"><span class=\"attribute\">ftp_proxy</span>=http://name:pwd@ip:port</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> http_proxy</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> https_proxy</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> ftp_proxy</span><br></pre></td></tr></table></figure>\n\n<p>使全局配置生效</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># source /etc/profile</span></span><br></pre></td></tr></table></figure>\n\n<p>若只针对某个用户而言,则修改 ~/.bash_profile 文件,添加相同内容;</p>\n<p>修改完成后,注销重新登录即可。</p>\n<h3 id=\"二、yum代理设置\"><a href=\"#二、yum代理设置\" class=\"headerlink\" title=\"二、yum代理设置\"></a>二、yum代理设置</h3><p>修改 /etc/yum.conf，添加下面内容:</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http_proxy=<span class=\"string\">http:</span><span class=\"comment\">//name:pwd@ip:port</span></span><br></pre></td></tr></table></figure>\n\n<p>保存退出后，就可以使用yum轻松的安装软件了。</p>\n<h3 id=\"三、wget代理设置\"><a href=\"#三、wget代理设置\" class=\"headerlink\" title=\"三、wget代理设置\"></a>三、wget代理设置</h3><p>修改/etc/wgetrc，添加下面内容:</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http_proxy = <span class=\"string\">http:</span><span class=\"comment\">//name:pwd@ip:port</span></span><br><span class=\"line\">ftp_proxy = <span class=\"string\">http:</span><span class=\"comment\">//name:pwd@ip:port</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、网络配置\"><a href=\"#四、网络配置\" class=\"headerlink\" title=\"四、网络配置\"></a>四、网络配置</h3><p>VirtualBox主机网络管理器中需要创建一张Host-Only网卡，并手动配置网卡地址及DHCP服务器。虚机启动时会根据dhcp服务器配置自动分配地址。</p>\n<p>虚机设置中启用两张网卡，网卡一连接方式为桥接网卡，网卡二连接方式为仅主机（Host-Only）网络。</p>\n<p>虚机中，安装net-tools依赖包：</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># yum -y install net-tools</span></span><br></pre></td></tr></table></figure>\n\n<p>查看网卡是否启用（是否分配ip，是否能ping通主机）：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"symbol\">root@</span>lcoalhost]# ifconfig</span><br><span class=\"line\">enp0s3: flags=<span class=\"number\">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class=\"number\">1500</span></span><br><span class=\"line\">        inet <span class=\"number\">10.112</span><span class=\"number\">.118</span><span class=\"number\">.81</span>  netmask <span class=\"number\">255.255</span><span class=\"number\">.254</span><span class=\"number\">.0</span>  broadcast <span class=\"number\">10.112</span><span class=\"number\">.119</span><span class=\"number\">.255</span> </span><br><span class=\"line\">        inet6 fe80::f41f:d:f042:d8ae  prefixlen <span class=\"number\">64</span>  scopeid <span class=\"number\">0x20</span>&lt;link&gt; </span><br><span class=\"line\">        ether <span class=\"number\">08</span>:<span class=\"number\">00</span>:<span class=\"number\">27</span>:fb:<span class=\"number\">62</span>:<span class=\"number\">61</span>  txqueuelen <span class=\"number\">1000</span>  (Ethernet) <span class=\"comment\">//ether对应第一张网卡的mac</span></span><br><span class=\"line\">        RX packets <span class=\"number\">220530</span>  bytes <span class=\"number\">251839085</span> (<span class=\"number\">240.1</span> MiB)</span><br><span class=\"line\">        RX errors <span class=\"number\">0</span>  dropped <span class=\"number\">0</span>  overruns <span class=\"number\">0</span>  frame <span class=\"number\">0</span></span><br><span class=\"line\">        TX packets <span class=\"number\">42719</span>  bytes <span class=\"number\">2891040</span> (<span class=\"number\">2.7</span> MiB)</span><br><span class=\"line\">        TX errors <span class=\"number\">0</span>  dropped <span class=\"number\">0</span> overruns <span class=\"number\">0</span>  carrier <span class=\"number\">0</span>  collisions <span class=\"number\">0</span></span><br><span class=\"line\">enp0s8: flags=<span class=\"number\">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class=\"number\">1500</span></span><br><span class=\"line\">        inet <span class=\"number\">192.168</span><span class=\"number\">.56</span><span class=\"number\">.103</span>  netmask <span class=\"number\">255.255</span><span class=\"number\">.255</span><span class=\"number\">.0</span>  broadcast <span class=\"number\">192.168</span><span class=\"number\">.56</span><span class=\"number\">.255</span> <span class=\"comment\">// inet对应dhcp地址池中的地址</span></span><br><span class=\"line\">        inet6 fe80::<span class=\"number\">5f</span>f8:c6c:<span class=\"number\">90</span>:<span class=\"number\">9239</span>  prefixlen <span class=\"number\">64</span>  scopeid <span class=\"number\">0x20</span>&lt;link&gt;</span><br><span class=\"line\">        ether <span class=\"number\">08</span>:<span class=\"number\">00</span>:<span class=\"number\">27</span>:<span class=\"number\">96</span>:<span class=\"number\">49</span>:<span class=\"number\">8</span>d  txqueuelen <span class=\"number\">1000</span>  (Ethernet) <span class=\"comment\">//ether对应第二张网卡的mac</span></span><br><span class=\"line\">        RX packets <span class=\"number\">62911</span>  bytes <span class=\"number\">3926194</span> (<span class=\"number\">3.7</span> MiB)</span><br><span class=\"line\">        RX errors <span class=\"number\">0</span>  dropped <span class=\"number\">0</span>  overruns <span class=\"number\">0</span>  frame <span class=\"number\">0</span></span><br><span class=\"line\">        TX packets <span class=\"number\">117073</span>  bytes <span class=\"number\">10861798</span> (<span class=\"number\">10.3</span> MiB)</span><br><span class=\"line\">        TX errors <span class=\"number\">0</span>  dropped <span class=\"number\">0</span> overruns <span class=\"number\">0</span>  carrier <span class=\"number\">0</span>  collisions <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"五、git代理设置\"><a href=\"#五、git代理设置\" class=\"headerlink\" title=\"五、git代理设置\"></a>五、git代理设置</h3><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># yun -y install git</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># git config --global https.proxy http://name:pwd<span class=\"doctag\">@ip</span>:port</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># git config --global http.proxy http://name:pwd<span class=\"doctag\">@ip</span>:port</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"六、docker-安装\"><a href=\"#六、docker-安装\" class=\"headerlink\" title=\"六、docker 安装\"></a>六、docker 安装</h3><p>1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。</p>\n<p>通过 uname -r 命令查看你当前的内核版本</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># uname -r</span></span><br></pre></td></tr></table></figure>\n\n<p>2、使用 root 权限登录 Centos。确保 yum 包更新到最新。</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># sudo yum update</span></span><br></pre></td></tr></table></figure>\n\n\n<p>3、卸载旧版本(如果安装过旧版本的话)</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo yum remove docker  docker-common docker-selinux docker-engine</span></span><br></pre></td></tr></table></figure>\n\n<p>4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span></span><br></pre></td></tr></table></figure>\n\n<p>5、设置yum源</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]# sudo yum-config-manager --<span class=\"built_in\">add</span>-repo http<span class=\"variable\">s:</span>//download.docker.<span class=\"keyword\">com</span>/linux/centos/docker-<span class=\"keyword\">ce</span>.repo</span><br></pre></td></tr></table></figure>\n\n<p> 重新设置阿里镜像网站（有时候也很慢）</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]# yum-config-manager --<span class=\"built_in\">add</span>-repo http://mirrors.aliyun.<span class=\"keyword\">com</span>/dockerce/linux/centos/docker-<span class=\"keyword\">ce</span>.repo</span><br></pre></td></tr></table></figure>\n\n<p>6、可以查看所有仓库中所有docker版本，并选择特定版本安装</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]# yum <span class=\"keyword\">list</span> docker-<span class=\"keyword\">ce</span> --showduplicates | <span class=\"keyword\">sort</span> -r</span><br></pre></td></tr></table></figure>\n\n<p>7、安装docker</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[root@lcoalhost]</span># <span class=\"selector-tag\">sudo</span> <span class=\"selector-tag\">yum</span> <span class=\"selector-tag\">install</span> <span class=\"selector-tag\">docker-ce</span>  #由于<span class=\"selector-tag\">repo</span>中默认只开启<span class=\"selector-tag\">stable</span>仓库，故这里安装的是最新稳定版17<span class=\"selector-class\">.12</span><span class=\"selector-class\">.0</span></span><br><span class=\"line\"><span class=\"selector-attr\">[root@lcoalhost]</span># <span class=\"selector-tag\">sudo</span> <span class=\"selector-tag\">yum</span> <span class=\"selector-tag\">install</span> &lt;<span class=\"selector-tag\">FQPN</span>&gt;  # 例如：<span class=\"selector-tag\">sudo</span> <span class=\"selector-tag\">yum</span> <span class=\"selector-tag\">install</span> <span class=\"selector-tag\">docker-ce-17</span><span class=\"selector-class\">.12</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.ce</span></span><br></pre></td></tr></table></figure>\n\n<p>8、启动并加入开机启动</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># sudo systemctl start docker</span></span><br><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># sudo systemctl enable docker</span></span><br></pre></td></tr></table></figure>\n\n\n<p>9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># docker version</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"七、设置docker-代理\"><a href=\"#七、设置docker-代理\" class=\"headerlink\" title=\"七、设置docker 代理\"></a>七、设置docker 代理</h3><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># mkdir -p /etc/systemd/system/docker.service.d</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># cat &gt; /etc/systemd/system/docker.service.d/https-proxy.conf &lt;&lt; EOF</span></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Environment=<span class=\"string\">\"http://name:pwd@ip:port\"</span> <span class=\"string\">\"HTTPS_PROXY=http://name:pwd@ip:port\"</span> </span><br><span class=\"line\">EOF</span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># systemctl daemon-reload</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># systemctl restart docker</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># systemctl show --property=Environment docker</span></span><br></pre></td></tr></table></figure>\n\n<p>docker 镜像加速，docker客户端版本大于 1.10.0 ,可修改daemon配置文件/etc/docker/daemon.json来使用加速器</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo mkdir -p /etc/docker</span></span><br><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo tee /etc/docker/daemon.json &lt;&lt;-<span class=\"string\">'EOF'</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"string\">\"registry-mirrors\"</span>: [<span class=\"string\">\"https://4ld4cyzt.mirror.aliyuncs.com\"</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo systemctl daemon-reload</span></span><br><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo systemctl restart docker</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"八、docker中安装Mysql\"><a href=\"#八、docker中安装Mysql\" class=\"headerlink\" title=\"八、docker中安装Mysql\"></a>八、docker中安装Mysql</h3><p>拉取mysql镜像</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]# docker pull mysq<span class=\"variable\">l:5</span>.<span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">5.7</span>: Pulling from library/mysql</span><br><span class=\"line\"><span class=\"number\">123275</span>d6e508: Already <span class=\"built_in\">exists</span> </span><br><span class=\"line\"><span class=\"number\">27</span>cddf5c7140: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\">c17d442e14c9: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">2</span>eb72ffed068: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\">d4aa125eb616: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">52560</span>afb169c: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">68190</span>f37a1d2: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">3</span>fd1dc6e2990: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">85</span>a79b83df29: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">35</span>e0b437fe88: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">992</span>f6a10268c: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\">Diges<span class=\"variable\">t:</span> <span class=\"built_in\">sha256</span>:<span class=\"number\">82</span>b72085b2fcff073a6616b84c7c3bcbb36e2d13af838cec11a9ed1d0b183f5e</span><br><span class=\"line\">Statu<span class=\"variable\">s:</span> Downloaded newer image <span class=\"keyword\">for</span> mysq<span class=\"variable\">l:5</span>.<span class=\"number\">7</span></span><br><span class=\"line\">docker.io/library/mysq<span class=\"variable\">l:5</span>.<span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>查看镜像</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"symbol\">root@</span>lcoalhost]# docker images</span><br><span class=\"line\">REPOSITORY  TAG    IMAGE ID     CREATED       SIZE</span><br><span class=\"line\">mysql       <span class=\"number\">5.7</span>    f5829c0eee9e <span class=\"number\">2</span> hours ago   <span class=\"number\">455</span>MB</span><br><span class=\"line\">[<span class=\"symbol\">root@</span>lcoalhost]#</span><br></pre></td></tr></table></figure>\n\n<p>启动mysql</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -p 3306:3306 --name mysql \\</span><br><span class=\"line\">-v /mydata/mysql/log:/var/log/mysql \\</span><br><span class=\"line\">-v /mydata/mysql/data:/var/lib/mysql \\</span><br><span class=\"line\">-v /mydata/mysql/conf:/etc/mysql \\</span><br><span class=\"line\">-e MYSQL_ROOT_PASSWORD=root \\</span><br><span class=\"line\">-d mysql:5.7</span><br></pre></td></tr></table></figure>\n\n<p>修改配置</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># cd /mydata/mysql/conf</span></span><br><span class=\"line\">// 配置如下：</span><br><span class=\"line\">[root@lcoalhost conf]<span class=\"comment\"># cat my.cnf</span></span><br><span class=\"line\">[client]</span><br><span class=\"line\">default-character-<span class=\"keyword\">set</span>=utf8</span><br><span class=\"line\">[mysql]</span><br><span class=\"line\"><span class=\"keyword\">default</span>-<span class=\"built_in\">character</span>-<span class=\"keyword\">set</span>=utf8</span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\">init_connect=<span class=\"string\">'SET collation_connection = utf8_unicode_ci'</span></span><br><span class=\"line\">init_connect=<span class=\"string\">'SET NAMES utf8'</span></span><br><span class=\"line\"><span class=\"built_in\">character</span>-<span class=\"keyword\">set</span>-<span class=\"keyword\">server</span>=utf8</span><br><span class=\"line\"><span class=\"keyword\">collation</span>-<span class=\"keyword\">server</span>=utf8_unicode_ci</span><br><span class=\"line\"><span class=\"keyword\">skip</span>-<span class=\"built_in\">character</span>-<span class=\"keyword\">set</span>-<span class=\"keyword\">client</span>-handshake</span><br><span class=\"line\"><span class=\"keyword\">skip</span>-<span class=\"keyword\">name</span>-resolve</span><br><span class=\"line\"></span><br><span class=\"line\">[root@lcoalhost conf]<span class=\"comment\"># docker restart mysql</span></span><br><span class=\"line\">mysql</span><br><span class=\"line\">[root@lcoalhost conf]<span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n\n<p>进入容器查看配置是否生效：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost conf]# docker exec -it mysql /bin/bash</span><br><span class=\"line\">root@b3a74e031bd7:/# whereis mysql</span><br><span class=\"line\">mysql: /usr/bin/mysql /usr/lib/mysql /etc/mysql /usr/share/mysql</span><br><span class=\"line\"></span><br><span class=\"line\">root@b3a74e031bd7:/# ls /etc/mysql </span><br><span class=\"line\">my.cnf</span><br><span class=\"line\">root@b3a74e031bd7:/# cat /etc/mysql/my.cnf </span><br><span class=\"line\">[client]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysql]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\">init_connect='SET collation_connection = utf8_unicode_ci'</span><br><span class=\"line\">init_connect='SET NAMES utf8'</span><br><span class=\"line\">character-set-server=utf8</span><br><span class=\"line\">collation-server=utf8_unicode_ci</span><br><span class=\"line\">skip-character-set-client-handshake</span><br><span class=\"line\">skip-name-resolve</span><br><span class=\"line\">root@b3a74e031bd7:/#</span><br></pre></td></tr></table></figure>\n\n<p>设置mysql随docker启动</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost</span> ~]<span class=\"meta\"># docker update mysql --restart=always</span></span><br><span class=\"line\">mysql</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"九、docker中安装Redis\"><a href=\"#九、docker中安装Redis\" class=\"headerlink\" title=\"九、docker中安装Redis\"></a>九、docker中安装Redis</h3><p>拉取redis镜像</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost ~]# docker pull redis</span><br><span class=\"line\">Using default tag: latest</span><br><span class=\"line\">latest: Pulling from library/redis</span><br><span class=\"line\">123275d6e508: Already exists </span><br><span class=\"line\">f2edbd6a658e: Pull complete </span><br><span class=\"line\">66960bede47c: Pull complete </span><br><span class=\"line\">79dc0b596c90: Pull complete </span><br><span class=\"line\">de36df38e0b6: Pull complete </span><br><span class=\"line\">602cd484ff92: Pull complete </span><br><span class=\"line\">Digest: sha256:1d0b903e3770c2c3c79961b73a53e963f4fd4b2674c2c4911472e8a054cb5728</span><br><span class=\"line\">Status: Downloaded newer image for redis:latest</span><br><span class=\"line\">docker.io/library/redis:latest</span><br></pre></td></tr></table></figure>\n\n<p>启动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost ~]# mkdir -p /mydata/redis/conf</span><br><span class=\"line\">[root@lcoalhost ~]# touch /mydata/redis/conf/redis.conf</span><br><span class=\"line\">[root@lcoalhost ~]# echo \"appendonly yes\"  &gt;&gt; /mydata/redis/conf/redis.conf // 开启数据持久化</span><br><span class=\"line\">[root@lcoalhost ~]# docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \\</span><br><span class=\"line\"> -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\</span><br><span class=\"line\"> -d redis redis-server /etc/redis/redis.conf</span><br><span class=\"line\">ce7ae709711986e3f90c9278b284fe6f51f1c1102ba05f3692f0e934ceca1565</span><br></pre></td></tr></table></figure>\n\n<p> 连接docker中的redis</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost ~]# docker exec -it redis redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; set key1 v1</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get key1</span><br><span class=\"line\">\"v1\"</span><br></pre></td></tr></table></figure>\n\n<p>设置redis随docker启动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost ~]# docker update redis --restart=always</span><br><span class=\"line\">redis</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、全局代理设置\"><a href=\"#一、全局代理设置\" class=\"headerlink\" title=\"一、全局代理设置\"></a>一、全局代理设置</h3><p>修改 /etc/profile 文件,添加下面内容:</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">http_proxy</span>=http://name:pwd@ip:port</span><br><span class=\"line\"><span class=\"attribute\">https_proxy</span>=http://name:pwd@ip:port</span><br><span class=\"line\"><span class=\"attribute\">ftp_proxy</span>=http://name:pwd@ip:port</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> http_proxy</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> https_proxy</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> ftp_proxy</span><br></pre></td></tr></table></figure>\n\n<p>使全局配置生效</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># source /etc/profile</span></span><br></pre></td></tr></table></figure>\n\n<p>若只针对某个用户而言,则修改 ~/.bash_profile 文件,添加相同内容;</p>\n<p>修改完成后,注销重新登录即可。</p>\n<h3 id=\"二、yum代理设置\"><a href=\"#二、yum代理设置\" class=\"headerlink\" title=\"二、yum代理设置\"></a>二、yum代理设置</h3><p>修改 /etc/yum.conf，添加下面内容:</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http_proxy=<span class=\"string\">http:</span><span class=\"comment\">//name:pwd@ip:port</span></span><br></pre></td></tr></table></figure>\n\n<p>保存退出后，就可以使用yum轻松的安装软件了。</p>\n<h3 id=\"三、wget代理设置\"><a href=\"#三、wget代理设置\" class=\"headerlink\" title=\"三、wget代理设置\"></a>三、wget代理设置</h3><p>修改/etc/wgetrc，添加下面内容:</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http_proxy = <span class=\"string\">http:</span><span class=\"comment\">//name:pwd@ip:port</span></span><br><span class=\"line\">ftp_proxy = <span class=\"string\">http:</span><span class=\"comment\">//name:pwd@ip:port</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、网络配置\"><a href=\"#四、网络配置\" class=\"headerlink\" title=\"四、网络配置\"></a>四、网络配置</h3><p>VirtualBox主机网络管理器中需要创建一张Host-Only网卡，并手动配置网卡地址及DHCP服务器。虚机启动时会根据dhcp服务器配置自动分配地址。</p>\n<p>虚机设置中启用两张网卡，网卡一连接方式为桥接网卡，网卡二连接方式为仅主机（Host-Only）网络。</p>\n<p>虚机中，安装net-tools依赖包：</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># yum -y install net-tools</span></span><br></pre></td></tr></table></figure>\n\n<p>查看网卡是否启用（是否分配ip，是否能ping通主机）：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"symbol\">root@</span>lcoalhost]# ifconfig</span><br><span class=\"line\">enp0s3: flags=<span class=\"number\">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class=\"number\">1500</span></span><br><span class=\"line\">        inet <span class=\"number\">10.112</span><span class=\"number\">.118</span><span class=\"number\">.81</span>  netmask <span class=\"number\">255.255</span><span class=\"number\">.254</span><span class=\"number\">.0</span>  broadcast <span class=\"number\">10.112</span><span class=\"number\">.119</span><span class=\"number\">.255</span> </span><br><span class=\"line\">        inet6 fe80::f41f:d:f042:d8ae  prefixlen <span class=\"number\">64</span>  scopeid <span class=\"number\">0x20</span>&lt;link&gt; </span><br><span class=\"line\">        ether <span class=\"number\">08</span>:<span class=\"number\">00</span>:<span class=\"number\">27</span>:fb:<span class=\"number\">62</span>:<span class=\"number\">61</span>  txqueuelen <span class=\"number\">1000</span>  (Ethernet) <span class=\"comment\">//ether对应第一张网卡的mac</span></span><br><span class=\"line\">        RX packets <span class=\"number\">220530</span>  bytes <span class=\"number\">251839085</span> (<span class=\"number\">240.1</span> MiB)</span><br><span class=\"line\">        RX errors <span class=\"number\">0</span>  dropped <span class=\"number\">0</span>  overruns <span class=\"number\">0</span>  frame <span class=\"number\">0</span></span><br><span class=\"line\">        TX packets <span class=\"number\">42719</span>  bytes <span class=\"number\">2891040</span> (<span class=\"number\">2.7</span> MiB)</span><br><span class=\"line\">        TX errors <span class=\"number\">0</span>  dropped <span class=\"number\">0</span> overruns <span class=\"number\">0</span>  carrier <span class=\"number\">0</span>  collisions <span class=\"number\">0</span></span><br><span class=\"line\">enp0s8: flags=<span class=\"number\">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class=\"number\">1500</span></span><br><span class=\"line\">        inet <span class=\"number\">192.168</span><span class=\"number\">.56</span><span class=\"number\">.103</span>  netmask <span class=\"number\">255.255</span><span class=\"number\">.255</span><span class=\"number\">.0</span>  broadcast <span class=\"number\">192.168</span><span class=\"number\">.56</span><span class=\"number\">.255</span> <span class=\"comment\">// inet对应dhcp地址池中的地址</span></span><br><span class=\"line\">        inet6 fe80::<span class=\"number\">5f</span>f8:c6c:<span class=\"number\">90</span>:<span class=\"number\">9239</span>  prefixlen <span class=\"number\">64</span>  scopeid <span class=\"number\">0x20</span>&lt;link&gt;</span><br><span class=\"line\">        ether <span class=\"number\">08</span>:<span class=\"number\">00</span>:<span class=\"number\">27</span>:<span class=\"number\">96</span>:<span class=\"number\">49</span>:<span class=\"number\">8</span>d  txqueuelen <span class=\"number\">1000</span>  (Ethernet) <span class=\"comment\">//ether对应第二张网卡的mac</span></span><br><span class=\"line\">        RX packets <span class=\"number\">62911</span>  bytes <span class=\"number\">3926194</span> (<span class=\"number\">3.7</span> MiB)</span><br><span class=\"line\">        RX errors <span class=\"number\">0</span>  dropped <span class=\"number\">0</span>  overruns <span class=\"number\">0</span>  frame <span class=\"number\">0</span></span><br><span class=\"line\">        TX packets <span class=\"number\">117073</span>  bytes <span class=\"number\">10861798</span> (<span class=\"number\">10.3</span> MiB)</span><br><span class=\"line\">        TX errors <span class=\"number\">0</span>  dropped <span class=\"number\">0</span> overruns <span class=\"number\">0</span>  carrier <span class=\"number\">0</span>  collisions <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"五、git代理设置\"><a href=\"#五、git代理设置\" class=\"headerlink\" title=\"五、git代理设置\"></a>五、git代理设置</h3><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># yun -y install git</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># git config --global https.proxy http://name:pwd<span class=\"doctag\">@ip</span>:port</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># git config --global http.proxy http://name:pwd<span class=\"doctag\">@ip</span>:port</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"六、docker-安装\"><a href=\"#六、docker-安装\" class=\"headerlink\" title=\"六、docker 安装\"></a>六、docker 安装</h3><p>1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。</p>\n<p>通过 uname -r 命令查看你当前的内核版本</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># uname -r</span></span><br></pre></td></tr></table></figure>\n\n<p>2、使用 root 权限登录 Centos。确保 yum 包更新到最新。</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># sudo yum update</span></span><br></pre></td></tr></table></figure>\n\n\n<p>3、卸载旧版本(如果安装过旧版本的话)</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo yum remove docker  docker-common docker-selinux docker-engine</span></span><br></pre></td></tr></table></figure>\n\n<p>4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span></span><br></pre></td></tr></table></figure>\n\n<p>5、设置yum源</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]# sudo yum-config-manager --<span class=\"built_in\">add</span>-repo http<span class=\"variable\">s:</span>//download.docker.<span class=\"keyword\">com</span>/linux/centos/docker-<span class=\"keyword\">ce</span>.repo</span><br></pre></td></tr></table></figure>\n\n<p> 重新设置阿里镜像网站（有时候也很慢）</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]# yum-config-manager --<span class=\"built_in\">add</span>-repo http://mirrors.aliyun.<span class=\"keyword\">com</span>/dockerce/linux/centos/docker-<span class=\"keyword\">ce</span>.repo</span><br></pre></td></tr></table></figure>\n\n<p>6、可以查看所有仓库中所有docker版本，并选择特定版本安装</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]# yum <span class=\"keyword\">list</span> docker-<span class=\"keyword\">ce</span> --showduplicates | <span class=\"keyword\">sort</span> -r</span><br></pre></td></tr></table></figure>\n\n<p>7、安装docker</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[root@lcoalhost]</span># <span class=\"selector-tag\">sudo</span> <span class=\"selector-tag\">yum</span> <span class=\"selector-tag\">install</span> <span class=\"selector-tag\">docker-ce</span>  #由于<span class=\"selector-tag\">repo</span>中默认只开启<span class=\"selector-tag\">stable</span>仓库，故这里安装的是最新稳定版17<span class=\"selector-class\">.12</span><span class=\"selector-class\">.0</span></span><br><span class=\"line\"><span class=\"selector-attr\">[root@lcoalhost]</span># <span class=\"selector-tag\">sudo</span> <span class=\"selector-tag\">yum</span> <span class=\"selector-tag\">install</span> &lt;<span class=\"selector-tag\">FQPN</span>&gt;  # 例如：<span class=\"selector-tag\">sudo</span> <span class=\"selector-tag\">yum</span> <span class=\"selector-tag\">install</span> <span class=\"selector-tag\">docker-ce-17</span><span class=\"selector-class\">.12</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.ce</span></span><br></pre></td></tr></table></figure>\n\n<p>8、启动并加入开机启动</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># sudo systemctl start docker</span></span><br><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># sudo systemctl enable docker</span></span><br></pre></td></tr></table></figure>\n\n\n<p>9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># docker version</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"七、设置docker-代理\"><a href=\"#七、设置docker-代理\" class=\"headerlink\" title=\"七、设置docker 代理\"></a>七、设置docker 代理</h3><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># mkdir -p /etc/systemd/system/docker.service.d</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># cat &gt; /etc/systemd/system/docker.service.d/https-proxy.conf &lt;&lt; EOF</span></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Environment=<span class=\"string\">\"http://name:pwd@ip:port\"</span> <span class=\"string\">\"HTTPS_PROXY=http://name:pwd@ip:port\"</span> </span><br><span class=\"line\">EOF</span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># systemctl daemon-reload</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># systemctl restart docker</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># systemctl show --property=Environment docker</span></span><br></pre></td></tr></table></figure>\n\n<p>docker 镜像加速，docker客户端版本大于 1.10.0 ,可修改daemon配置文件/etc/docker/daemon.json来使用加速器</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo mkdir -p /etc/docker</span></span><br><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo tee /etc/docker/daemon.json &lt;&lt;-<span class=\"string\">'EOF'</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"string\">\"registry-mirrors\"</span>: [<span class=\"string\">\"https://4ld4cyzt.mirror.aliyuncs.com\"</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo systemctl daemon-reload</span></span><br><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo systemctl restart docker</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"八、docker中安装Mysql\"><a href=\"#八、docker中安装Mysql\" class=\"headerlink\" title=\"八、docker中安装Mysql\"></a>八、docker中安装Mysql</h3><p>拉取mysql镜像</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]# docker pull mysq<span class=\"variable\">l:5</span>.<span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">5.7</span>: Pulling from library/mysql</span><br><span class=\"line\"><span class=\"number\">123275</span>d6e508: Already <span class=\"built_in\">exists</span> </span><br><span class=\"line\"><span class=\"number\">27</span>cddf5c7140: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\">c17d442e14c9: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">2</span>eb72ffed068: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\">d4aa125eb616: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">52560</span>afb169c: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">68190</span>f37a1d2: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">3</span>fd1dc6e2990: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">85</span>a79b83df29: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">35</span>e0b437fe88: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">992</span>f6a10268c: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\">Diges<span class=\"variable\">t:</span> <span class=\"built_in\">sha256</span>:<span class=\"number\">82</span>b72085b2fcff073a6616b84c7c3bcbb36e2d13af838cec11a9ed1d0b183f5e</span><br><span class=\"line\">Statu<span class=\"variable\">s:</span> Downloaded newer image <span class=\"keyword\">for</span> mysq<span class=\"variable\">l:5</span>.<span class=\"number\">7</span></span><br><span class=\"line\">docker.io/library/mysq<span class=\"variable\">l:5</span>.<span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>查看镜像</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"symbol\">root@</span>lcoalhost]# docker images</span><br><span class=\"line\">REPOSITORY  TAG    IMAGE ID     CREATED       SIZE</span><br><span class=\"line\">mysql       <span class=\"number\">5.7</span>    f5829c0eee9e <span class=\"number\">2</span> hours ago   <span class=\"number\">455</span>MB</span><br><span class=\"line\">[<span class=\"symbol\">root@</span>lcoalhost]#</span><br></pre></td></tr></table></figure>\n\n<p>启动mysql</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -p 3306:3306 --name mysql \\</span><br><span class=\"line\">-v /mydata/mysql/log:/var/log/mysql \\</span><br><span class=\"line\">-v /mydata/mysql/data:/var/lib/mysql \\</span><br><span class=\"line\">-v /mydata/mysql/conf:/etc/mysql \\</span><br><span class=\"line\">-e MYSQL_ROOT_PASSWORD=root \\</span><br><span class=\"line\">-d mysql:5.7</span><br></pre></td></tr></table></figure>\n\n<p>修改配置</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># cd /mydata/mysql/conf</span></span><br><span class=\"line\">// 配置如下：</span><br><span class=\"line\">[root@lcoalhost conf]<span class=\"comment\"># cat my.cnf</span></span><br><span class=\"line\">[client]</span><br><span class=\"line\">default-character-<span class=\"keyword\">set</span>=utf8</span><br><span class=\"line\">[mysql]</span><br><span class=\"line\"><span class=\"keyword\">default</span>-<span class=\"built_in\">character</span>-<span class=\"keyword\">set</span>=utf8</span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\">init_connect=<span class=\"string\">'SET collation_connection = utf8_unicode_ci'</span></span><br><span class=\"line\">init_connect=<span class=\"string\">'SET NAMES utf8'</span></span><br><span class=\"line\"><span class=\"built_in\">character</span>-<span class=\"keyword\">set</span>-<span class=\"keyword\">server</span>=utf8</span><br><span class=\"line\"><span class=\"keyword\">collation</span>-<span class=\"keyword\">server</span>=utf8_unicode_ci</span><br><span class=\"line\"><span class=\"keyword\">skip</span>-<span class=\"built_in\">character</span>-<span class=\"keyword\">set</span>-<span class=\"keyword\">client</span>-handshake</span><br><span class=\"line\"><span class=\"keyword\">skip</span>-<span class=\"keyword\">name</span>-resolve</span><br><span class=\"line\"></span><br><span class=\"line\">[root@lcoalhost conf]<span class=\"comment\"># docker restart mysql</span></span><br><span class=\"line\">mysql</span><br><span class=\"line\">[root@lcoalhost conf]<span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n\n<p>进入容器查看配置是否生效：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost conf]# docker exec -it mysql /bin/bash</span><br><span class=\"line\">root@b3a74e031bd7:/# whereis mysql</span><br><span class=\"line\">mysql: /usr/bin/mysql /usr/lib/mysql /etc/mysql /usr/share/mysql</span><br><span class=\"line\"></span><br><span class=\"line\">root@b3a74e031bd7:/# ls /etc/mysql </span><br><span class=\"line\">my.cnf</span><br><span class=\"line\">root@b3a74e031bd7:/# cat /etc/mysql/my.cnf </span><br><span class=\"line\">[client]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysql]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\">init_connect='SET collation_connection = utf8_unicode_ci'</span><br><span class=\"line\">init_connect='SET NAMES utf8'</span><br><span class=\"line\">character-set-server=utf8</span><br><span class=\"line\">collation-server=utf8_unicode_ci</span><br><span class=\"line\">skip-character-set-client-handshake</span><br><span class=\"line\">skip-name-resolve</span><br><span class=\"line\">root@b3a74e031bd7:/#</span><br></pre></td></tr></table></figure>\n\n<p>设置mysql随docker启动</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost</span> ~]<span class=\"meta\"># docker update mysql --restart=always</span></span><br><span class=\"line\">mysql</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"九、docker中安装Redis\"><a href=\"#九、docker中安装Redis\" class=\"headerlink\" title=\"九、docker中安装Redis\"></a>九、docker中安装Redis</h3><p>拉取redis镜像</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost ~]# docker pull redis</span><br><span class=\"line\">Using default tag: latest</span><br><span class=\"line\">latest: Pulling from library/redis</span><br><span class=\"line\">123275d6e508: Already exists </span><br><span class=\"line\">f2edbd6a658e: Pull complete </span><br><span class=\"line\">66960bede47c: Pull complete </span><br><span class=\"line\">79dc0b596c90: Pull complete </span><br><span class=\"line\">de36df38e0b6: Pull complete </span><br><span class=\"line\">602cd484ff92: Pull complete </span><br><span class=\"line\">Digest: sha256:1d0b903e3770c2c3c79961b73a53e963f4fd4b2674c2c4911472e8a054cb5728</span><br><span class=\"line\">Status: Downloaded newer image for redis:latest</span><br><span class=\"line\">docker.io/library/redis:latest</span><br></pre></td></tr></table></figure>\n\n<p>启动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost ~]# mkdir -p /mydata/redis/conf</span><br><span class=\"line\">[root@lcoalhost ~]# touch /mydata/redis/conf/redis.conf</span><br><span class=\"line\">[root@lcoalhost ~]# echo \"appendonly yes\"  &gt;&gt; /mydata/redis/conf/redis.conf // 开启数据持久化</span><br><span class=\"line\">[root@lcoalhost ~]# docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \\</span><br><span class=\"line\"> -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\</span><br><span class=\"line\"> -d redis redis-server /etc/redis/redis.conf</span><br><span class=\"line\">ce7ae709711986e3f90c9278b284fe6f51f1c1102ba05f3692f0e934ceca1565</span><br></pre></td></tr></table></figure>\n\n<p> 连接docker中的redis</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost ~]# docker exec -it redis redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; set key1 v1</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get key1</span><br><span class=\"line\">\"v1\"</span><br></pre></td></tr></table></figure>\n\n<p>设置redis随docker启动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost ~]# docker update redis --restart=always</span><br><span class=\"line\">redis</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"数据结构与算法---排序","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":0,"abbrlink":"211a","date":"2020-12-20T16:00:00.000Z","subtitle":null,"_content":"### 数据结构与算法---O(n^2)排序\n#### 冒泡排序\n#### 插入排序\n#### 选择排序\n#### 希尔排序\n### 数据结构与算法---O(nlogn)排序\n#### 归并排序\n#### 快速排序\n#### 堆排序\n### 数据结构与算法---O(n)排序\n#### 计数排序\n#### 基数排序\n#### 桶排序","source":"_posts/algorithm-sort.md","raw":"---\ntitle: 数据结构与算法---排序\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop: 0\ntags:\n  - algorithm\ncategories:\n  - work\nabbrlink: 211a\ndate: 2020-12-21 00:00:00\nsubtitle:\n---\n### 数据结构与算法---O(n^2)排序\n#### 冒泡排序\n#### 插入排序\n#### 选择排序\n#### 希尔排序\n### 数据结构与算法---O(nlogn)排序\n#### 归并排序\n#### 快速排序\n#### 堆排序\n### 数据结构与算法---O(n)排序\n#### 计数排序\n#### 基数排序\n#### 桶排序","slug":"algorithm-sort","published":1,"updated":"2020-12-23T09:18:01.750Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshhgzj20009iobf97s66xyt","content":"<h3 id=\"数据结构与算法—O-n-2-排序\"><a href=\"#数据结构与算法—O-n-2-排序\" class=\"headerlink\" title=\"数据结构与算法—O(n^2)排序\"></a>数据结构与算法—O(n^2)排序</h3><h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><h4 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h4><h3 id=\"数据结构与算法—O-nlogn-排序\"><a href=\"#数据结构与算法—O-nlogn-排序\" class=\"headerlink\" title=\"数据结构与算法—O(nlogn)排序\"></a>数据结构与算法—O(nlogn)排序</h3><h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><h4 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h4><h3 id=\"数据结构与算法—O-n-排序\"><a href=\"#数据结构与算法—O-n-排序\" class=\"headerlink\" title=\"数据结构与算法—O(n)排序\"></a>数据结构与算法—O(n)排序</h3><h4 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h4><h4 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h4><h4 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"数据结构与算法—O-n-2-排序\"><a href=\"#数据结构与算法—O-n-2-排序\" class=\"headerlink\" title=\"数据结构与算法—O(n^2)排序\"></a>数据结构与算法—O(n^2)排序</h3><h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><h4 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h4><h3 id=\"数据结构与算法—O-nlogn-排序\"><a href=\"#数据结构与算法—O-nlogn-排序\" class=\"headerlink\" title=\"数据结构与算法—O(nlogn)排序\"></a>数据结构与算法—O(nlogn)排序</h3><h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><h4 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h4><h3 id=\"数据结构与算法—O-n-排序\"><a href=\"#数据结构与算法—O-n-排序\" class=\"headerlink\" title=\"数据结构与算法—O(n)排序\"></a>数据结构与算法—O(n)排序</h3><h4 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h4><h4 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h4><h4 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h4>"},{"title":"Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":null,"abbrlink":"9f70","_content":"\n#### git push错误\n\nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\n\n#### 解决方案：\n\n1. ###### 登录github → Settings → Developer settings → Personal access tokens → Generate new token\n\n2. ###### 复制新生成的token（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），执行：\n\n    ```\n    git remote set-url origin https://$new-token@github.com/$username/$repo-name.git\n    ```\n\n3. ###### 重新push即可","source":"_posts/git-push-error.md","raw":"---\ntitle: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop: \ntags:\n  - git\ncategories:\n  - work\nabbrlink: 9f70\n---\n\n#### git push错误\n\nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\n\n#### 解决方案：\n\n1. ###### 登录github → Settings → Developer settings → Personal access tokens → Generate new token\n\n2. ###### 复制新生成的token（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），执行：\n\n    ```\n    git remote set-url origin https://$new-token@github.com/$username/$repo-name.git\n    ```\n\n3. ###### 重新push即可","slug":"git-push-error","published":1,"date":"2021-08-18T12:09:05.507Z","updated":"2021-08-18T12:39:29.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshhgzj4000biobfhb1afxml","content":"<h4 id=\"git-push错误\"><a href=\"#git-push错误\" class=\"headerlink\" title=\"git push错误\"></a>git push错误</h4><p>remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</p>\n<h4 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h4><ol>\n<li><h6 id=\"登录github-→-Settings-→-Developer-settings-→-Personal-access-tokens-→-Generate-new-token\"><a href=\"#登录github-→-Settings-→-Developer-settings-→-Personal-access-tokens-→-Generate-new-token\" class=\"headerlink\" title=\"登录github → Settings → Developer settings → Personal access tokens → Generate new token\"></a>登录github → Settings → Developer settings → Personal access tokens → Generate new token</h6></li>\n<li><h6 id=\"复制新生成的token（ghp-YVupNqZjSNU0wB1xu61jqOjAOEHcs826HsTK），执行：\"><a href=\"#复制新生成的token（ghp-YVupNqZjSNU0wB1xu61jqOjAOEHcs826HsTK），执行：\" class=\"headerlink\" title=\"复制新生成的token（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），执行：\"></a>复制新生成的token（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），执行：</h6> <figure class=\"highlight dsconfig\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">git </span><span class=\"string\">remote </span><span class=\"built_in\">set-url</span> <span class=\"string\">origin </span><span class=\"string\">https:</span>//$<span class=\"string\">new-token@</span><span class=\"string\">github.</span><span class=\"string\">com/</span>$<span class=\"string\">username/</span>$<span class=\"string\">repo-name.</span><span class=\"string\">git</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><h6 id=\"重新push即可\"><a href=\"#重新push即可\" class=\"headerlink\" title=\"重新push即可\"></a>重新push即可</h6></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"git-push错误\"><a href=\"#git-push错误\" class=\"headerlink\" title=\"git push错误\"></a>git push错误</h4><p>remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</p>\n<h4 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h4><ol>\n<li><h6 id=\"登录github-→-Settings-→-Developer-settings-→-Personal-access-tokens-→-Generate-new-token\"><a href=\"#登录github-→-Settings-→-Developer-settings-→-Personal-access-tokens-→-Generate-new-token\" class=\"headerlink\" title=\"登录github → Settings → Developer settings → Personal access tokens → Generate new token\"></a>登录github → Settings → Developer settings → Personal access tokens → Generate new token</h6></li>\n<li><h6 id=\"复制新生成的token（ghp-YVupNqZjSNU0wB1xu61jqOjAOEHcs826HsTK），执行：\"><a href=\"#复制新生成的token（ghp-YVupNqZjSNU0wB1xu61jqOjAOEHcs826HsTK），执行：\" class=\"headerlink\" title=\"复制新生成的token（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），执行：\"></a>复制新生成的token（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），执行：</h6> <figure class=\"highlight dsconfig\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">git </span><span class=\"string\">remote </span><span class=\"built_in\">set-url</span> <span class=\"string\">origin </span><span class=\"string\">https:</span>//$<span class=\"string\">new-token@</span><span class=\"string\">github.</span><span class=\"string\">com/</span>$<span class=\"string\">username/</span>$<span class=\"string\">repo-name.</span><span class=\"string\">git</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><h6 id=\"重新push即可\"><a href=\"#重新push即可\" class=\"headerlink\" title=\"重新push即可\"></a>重新push即可</h6></li>\n</ol>\n"},{"title":"数据结构与算法---二叉树","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":0,"abbrlink":"c608","date":"2020-12-20T16:00:00.000Z","subtitle":null,"_content":"### 数据结构与算法---平衡二叉树\n### 数据结构与算法---二叉查找树\n### 数据结构与算法---平衡二叉查找树\n#### AVL树\n#### 红黑树\n### 数据结构与算法---完全二叉树\n### 数据结构与算法---满二叉树\n","source":"_posts/algorithm-tree.md","raw":"---\ntitle: 数据结构与算法---二叉树\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop: 0\ntags:\n  - algorithm\ncategories:\n  - work\nabbrlink: c608\ndate: 2020-12-21 00:00:00\nsubtitle:\n---\n### 数据结构与算法---平衡二叉树\n### 数据结构与算法---二叉查找树\n### 数据结构与算法---平衡二叉查找树\n#### AVL树\n#### 红黑树\n### 数据结构与算法---完全二叉树\n### 数据结构与算法---满二叉树\n","slug":"algorithm-tree","published":1,"updated":"2020-12-23T09:18:01.756Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshhgzj9000fiobf4x856558","content":"<h3 id=\"数据结构与算法—平衡二叉树\"><a href=\"#数据结构与算法—平衡二叉树\" class=\"headerlink\" title=\"数据结构与算法—平衡二叉树\"></a>数据结构与算法—平衡二叉树</h3><h3 id=\"数据结构与算法—二叉查找树\"><a href=\"#数据结构与算法—二叉查找树\" class=\"headerlink\" title=\"数据结构与算法—二叉查找树\"></a>数据结构与算法—二叉查找树</h3><h3 id=\"数据结构与算法—平衡二叉查找树\"><a href=\"#数据结构与算法—平衡二叉查找树\" class=\"headerlink\" title=\"数据结构与算法—平衡二叉查找树\"></a>数据结构与算法—平衡二叉查找树</h3><h4 id=\"AVL树\"><a href=\"#AVL树\" class=\"headerlink\" title=\"AVL树\"></a>AVL树</h4><h4 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h4><h3 id=\"数据结构与算法—完全二叉树\"><a href=\"#数据结构与算法—完全二叉树\" class=\"headerlink\" title=\"数据结构与算法—完全二叉树\"></a>数据结构与算法—完全二叉树</h3><h3 id=\"数据结构与算法—满二叉树\"><a href=\"#数据结构与算法—满二叉树\" class=\"headerlink\" title=\"数据结构与算法—满二叉树\"></a>数据结构与算法—满二叉树</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"数据结构与算法—平衡二叉树\"><a href=\"#数据结构与算法—平衡二叉树\" class=\"headerlink\" title=\"数据结构与算法—平衡二叉树\"></a>数据结构与算法—平衡二叉树</h3><h3 id=\"数据结构与算法—二叉查找树\"><a href=\"#数据结构与算法—二叉查找树\" class=\"headerlink\" title=\"数据结构与算法—二叉查找树\"></a>数据结构与算法—二叉查找树</h3><h3 id=\"数据结构与算法—平衡二叉查找树\"><a href=\"#数据结构与算法—平衡二叉查找树\" class=\"headerlink\" title=\"数据结构与算法—平衡二叉查找树\"></a>数据结构与算法—平衡二叉查找树</h3><h4 id=\"AVL树\"><a href=\"#AVL树\" class=\"headerlink\" title=\"AVL树\"></a>AVL树</h4><h4 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h4><h3 id=\"数据结构与算法—完全二叉树\"><a href=\"#数据结构与算法—完全二叉树\" class=\"headerlink\" title=\"数据结构与算法—完全二叉树\"></a>数据结构与算法—完全二叉树</h3><h3 id=\"数据结构与算法—满二叉树\"><a href=\"#数据结构与算法—满二叉树\" class=\"headerlink\" title=\"数据结构与算法—满二叉树\"></a>数据结构与算法—满二叉树</h3>"},{"title":"中国地图","header-img":"/img/header_img/post-bg-desk.jpg","catalog":false,"toc_number":false,"top":99,"abbrlink":"86e5","subtitle":null,"_content":"\n<div id=\"chinaMap\" style=\"width: 100%;height:600px;\"></div>\n<script type=\"text/javascript\" src=\"/js/echarts/echarts.min.js\"></script>\n<script type=\"text/javascript\" src=\"/js/echarts/china.js\"></script>\n<script type=\"text/javascript\" src=\"/js/src/chinamap.js\"></script>","source":"_posts/chinamap.md","raw":"---\ntitle: 中国地图\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: false\ntoc_number: false\ntop: 99\ntags:\n  - map\ncategories:\n  - life\nabbrlink: '86e5'\nsubtitle:\n---\n\n<div id=\"chinaMap\" style=\"width: 100%;height:600px;\"></div>\n<script type=\"text/javascript\" src=\"/js/echarts/echarts.min.js\"></script>\n<script type=\"text/javascript\" src=\"/js/echarts/china.js\"></script>\n<script type=\"text/javascript\" src=\"/js/src/chinamap.js\"></script>","slug":"chinamap","published":1,"date":"2021-08-17T09:17:04.769Z","updated":"2021-08-18T11:34:44.648Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshhgzjb000hiobfauto8dfk","content":"<div id=\"chinaMap\" style=\"width: 100%;height:600px;\"></div>\n<script type=\"text/javascript\" src=\"/js/echarts/echarts.min.js\"></script>\n<script type=\"text/javascript\" src=\"/js/echarts/china.js\"></script>\n<script type=\"text/javascript\" src=\"/js/src/chinamap.js\"></script>","site":{"data":{}},"excerpt":"","more":"<div id=\"chinaMap\" style=\"width: 100%;height:600px;\"></div>\n<script type=\"text/javascript\" src=\"/js/echarts/echarts.min.js\"></script>\n<script type=\"text/javascript\" src=\"/js/echarts/china.js\"></script>\n<script type=\"text/javascript\" src=\"/js/src/chinamap.js\"></script>"},{"title":"Git同时push到Github和Gitee","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":null,"abbrlink":"1af5","date":"2020-12-17T16:00:00.000Z","subtitle":null,"_content":"\n### 目的\n\nGithub有时访问会很慢，想用Gitee做个备份，如何将已有的Github项目同步到Gitee，并将修改同时push到自己的Github和Gitee上呢？\n\n### 1. 在Gitee上新建仓库，并关联Github仓库\n\n新建gitee仓库\n![create_gitee_repo](/img/1-work/tools/create_gitee_repo.png)\n\n复制github仓库的https地址并粘贴\n![import-github-repo](/img/1-work/tools/import-github-repo.png)\n\n创建，等待同步。\n\n### 2. 拉取Gitee项目，修改.git配置文件\n\n克隆创建好的Gitee项目：\n`git clone $项目地址`\n\ngit默认远程仓库为origin，可用git remote查看。\n添加gitee地址到origin：\n`git remote set-url --add origin $项目gitee地址`\n\n添加github地址到origin：\n`git remote set-url --add origin $项目github地址`\n\n也可直接打开配置文件修改，文件位于.git/config\n```\n[remote \"origin\"]\n \turl = https://gitee.com/$项目gitee地址\n \tfetch = +refs/heads/*:refs/remotes/origin/*\n \turl = https://github.com/$项目github地址\n```\n\n### 3. 修改完成，push一下看看吧\n\n若push不成功，可以检查一下自己是否有仓库权限，配置地址是否正确\n\n#### push时记住用户名密码的方法\n\n配置文件中使能保存密码功能：\n`git config credential.helper store`\n\n提交时输入用户名密码，再次提交就记住啦。","source":"_posts/git-push-two-repo.md","raw":"---\ntitle: Git同时push到Github和Gitee\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop:\ntags:\n  - git\ncategories:\n  - work\nabbrlink: 1af5\ndate: 2020-12-18 00:00:00\nsubtitle:\n---\n\n### 目的\n\nGithub有时访问会很慢，想用Gitee做个备份，如何将已有的Github项目同步到Gitee，并将修改同时push到自己的Github和Gitee上呢？\n\n### 1. 在Gitee上新建仓库，并关联Github仓库\n\n新建gitee仓库\n![create_gitee_repo](/img/1-work/tools/create_gitee_repo.png)\n\n复制github仓库的https地址并粘贴\n![import-github-repo](/img/1-work/tools/import-github-repo.png)\n\n创建，等待同步。\n\n### 2. 拉取Gitee项目，修改.git配置文件\n\n克隆创建好的Gitee项目：\n`git clone $项目地址`\n\ngit默认远程仓库为origin，可用git remote查看。\n添加gitee地址到origin：\n`git remote set-url --add origin $项目gitee地址`\n\n添加github地址到origin：\n`git remote set-url --add origin $项目github地址`\n\n也可直接打开配置文件修改，文件位于.git/config\n```\n[remote \"origin\"]\n \turl = https://gitee.com/$项目gitee地址\n \tfetch = +refs/heads/*:refs/remotes/origin/*\n \turl = https://github.com/$项目github地址\n```\n\n### 3. 修改完成，push一下看看吧\n\n若push不成功，可以检查一下自己是否有仓库权限，配置地址是否正确\n\n#### push时记住用户名密码的方法\n\n配置文件中使能保存密码功能：\n`git config credential.helper store`\n\n提交时输入用户名密码，再次提交就记住啦。","slug":"git-push-two-repo","published":1,"updated":"2021-08-18T12:40:25.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshhgzje000miobf5gx84cdk","content":"<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>Github有时访问会很慢，想用Gitee做个备份，如何将已有的Github项目同步到Gitee，并将修改同时push到自己的Github和Gitee上呢？</p>\n<h3 id=\"1-在Gitee上新建仓库，并关联Github仓库\"><a href=\"#1-在Gitee上新建仓库，并关联Github仓库\" class=\"headerlink\" title=\"1. 在Gitee上新建仓库，并关联Github仓库\"></a>1. 在Gitee上新建仓库，并关联Github仓库</h3><p>新建gitee仓库<br><img src=\"/img/1-work/tools/create_gitee_repo.png\" alt=\"create_gitee_repo\"></p>\n<p>复制github仓库的https地址并粘贴<br><img src=\"/img/1-work/tools/import-github-repo.png\" alt=\"import-github-repo\"></p>\n<p>创建，等待同步。</p>\n<h3 id=\"2-拉取Gitee项目，修改-git配置文件\"><a href=\"#2-拉取Gitee项目，修改-git配置文件\" class=\"headerlink\" title=\"2. 拉取Gitee项目，修改.git配置文件\"></a>2. 拉取Gitee项目，修改.git配置文件</h3><p>克隆创建好的Gitee项目：<br><code>git clone $项目地址</code></p>\n<p>git默认远程仓库为origin，可用git remote查看。<br>添加gitee地址到origin：<br><code>git remote set-url --add origin $项目gitee地址</code></p>\n<p>添加github地址到origin：<br><code>git remote set-url --add origin $项目github地址</code></p>\n<p>也可直接打开配置文件修改，文件位于.git/config</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[remote <span class=\"string\">\"origin\"</span>]</span><br><span class=\"line\"> \turl = <span class=\"symbol\">https:</span>/<span class=\"regexp\">/gitee.com/</span><span class=\"variable\">$项</span>目gitee地址</span><br><span class=\"line\"> \tfetch = +refs/heads/*<span class=\"symbol\">:refs/remotes/origin/*</span></span><br><span class=\"line\"> \turl = <span class=\"symbol\">https:</span>/<span class=\"regexp\">/github.com/</span><span class=\"variable\">$项</span>目github地址</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-修改完成，push一下看看吧\"><a href=\"#3-修改完成，push一下看看吧\" class=\"headerlink\" title=\"3. 修改完成，push一下看看吧\"></a>3. 修改完成，push一下看看吧</h3><p>若push不成功，可以检查一下自己是否有仓库权限，配置地址是否正确</p>\n<h4 id=\"push时记住用户名密码的方法\"><a href=\"#push时记住用户名密码的方法\" class=\"headerlink\" title=\"push时记住用户名密码的方法\"></a>push时记住用户名密码的方法</h4><p>配置文件中使能保存密码功能：<br><code>git config credential.helper store</code></p>\n<p>提交时输入用户名密码，再次提交就记住啦。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>Github有时访问会很慢，想用Gitee做个备份，如何将已有的Github项目同步到Gitee，并将修改同时push到自己的Github和Gitee上呢？</p>\n<h3 id=\"1-在Gitee上新建仓库，并关联Github仓库\"><a href=\"#1-在Gitee上新建仓库，并关联Github仓库\" class=\"headerlink\" title=\"1. 在Gitee上新建仓库，并关联Github仓库\"></a>1. 在Gitee上新建仓库，并关联Github仓库</h3><p>新建gitee仓库<br><img src=\"/img/1-work/tools/create_gitee_repo.png\" alt=\"create_gitee_repo\"></p>\n<p>复制github仓库的https地址并粘贴<br><img src=\"/img/1-work/tools/import-github-repo.png\" alt=\"import-github-repo\"></p>\n<p>创建，等待同步。</p>\n<h3 id=\"2-拉取Gitee项目，修改-git配置文件\"><a href=\"#2-拉取Gitee项目，修改-git配置文件\" class=\"headerlink\" title=\"2. 拉取Gitee项目，修改.git配置文件\"></a>2. 拉取Gitee项目，修改.git配置文件</h3><p>克隆创建好的Gitee项目：<br><code>git clone $项目地址</code></p>\n<p>git默认远程仓库为origin，可用git remote查看。<br>添加gitee地址到origin：<br><code>git remote set-url --add origin $项目gitee地址</code></p>\n<p>添加github地址到origin：<br><code>git remote set-url --add origin $项目github地址</code></p>\n<p>也可直接打开配置文件修改，文件位于.git/config</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[remote <span class=\"string\">\"origin\"</span>]</span><br><span class=\"line\"> \turl = <span class=\"symbol\">https:</span>/<span class=\"regexp\">/gitee.com/</span><span class=\"variable\">$项</span>目gitee地址</span><br><span class=\"line\"> \tfetch = +refs/heads/*<span class=\"symbol\">:refs/remotes/origin/*</span></span><br><span class=\"line\"> \turl = <span class=\"symbol\">https:</span>/<span class=\"regexp\">/github.com/</span><span class=\"variable\">$项</span>目github地址</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-修改完成，push一下看看吧\"><a href=\"#3-修改完成，push一下看看吧\" class=\"headerlink\" title=\"3. 修改完成，push一下看看吧\"></a>3. 修改完成，push一下看看吧</h3><p>若push不成功，可以检查一下自己是否有仓库权限，配置地址是否正确</p>\n<h4 id=\"push时记住用户名密码的方法\"><a href=\"#push时记住用户名密码的方法\" class=\"headerlink\" title=\"push时记住用户名密码的方法\"></a>push时记住用户名密码的方法</h4><p>配置文件中使能保存密码功能：<br><code>git config credential.helper store</code></p>\n<p>提交时输入用户名密码，再次提交就记住啦。</p>\n"},{"title":"不做第二个蛋壳","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":null,"abbrlink":"7b21","date":"2020-12-18T16:00:00.000Z","subtitle":null,"_content":"\n### 不做第二个蛋壳","source":"_posts/read-test.md","raw":"---\ntitle: 不做第二个蛋壳\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop:\ntags:\n  - finance\ncategories:\n  - life\nabbrlink: 7b21\ndate: 2020-12-19 00:00:00\nsubtitle:\n---\n\n### 不做第二个蛋壳","slug":"read-test","published":1,"updated":"2021-08-18T12:40:42.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshhgzjg000piobfb9dq1i4q","content":"<h3 id=\"不做第二个蛋壳\"><a href=\"#不做第二个蛋壳\" class=\"headerlink\" title=\"不做第二个蛋壳\"></a>不做第二个蛋壳</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"不做第二个蛋壳\"><a href=\"#不做第二个蛋壳\" class=\"headerlink\" title=\"不做第二个蛋壳\"></a>不做第二个蛋壳</h3>"},{"title":"git 回滚指定版本并推送到远程分支","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":null,"abbrlink":"6186","_content":"\n1. ###### 回退\n\n    ```\n    git log //查看提交的历史\n    git reset --hard $要回退的commit号\n    ```\n\n2. ###### 切换到临时分支推送并删除原分支\n\n    ```\n    git checkout -b temp            // 新建临时分支并切换\n    git push origin temp:temp       // 将代码push到temp分支\n    git push origin --delete main   // 删除远端分支main，此处注意如果要删除的远端分支为默认分支则不可删除，需将默认分支切换到其他分支\n    git branch -d main              // 删除本地分支main\n    ```\n\n3. ###### 新建并切换回原分支并删除临时分支\n\n    ```\n    git checkout -b main            // 新建本地分支main并切换\n    git push origin main            // 提交分支main到远端\n    git branch -d temp\t\t\t\t// 删除本地临时分支\n    git push origin --delete temp\t// 删除远端临时分支，此处注意如果要删除的远端分支为默认分支则不可删除，需将默认分支切换到其他分支\n    ```\n\n    > ###### github切换默认分支：\n    >\n    > \t进入对应repo → Settings → Branches → Switch to another branch","source":"_posts/git-reset.md","raw":"---\ntitle: git 回滚指定版本并推送到远程分支\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop:\ntags:\n  - git\ncategories:\n  - work\nabbrlink: '6186'\n---\n\n1. ###### 回退\n\n    ```\n    git log //查看提交的历史\n    git reset --hard $要回退的commit号\n    ```\n\n2. ###### 切换到临时分支推送并删除原分支\n\n    ```\n    git checkout -b temp            // 新建临时分支并切换\n    git push origin temp:temp       // 将代码push到temp分支\n    git push origin --delete main   // 删除远端分支main，此处注意如果要删除的远端分支为默认分支则不可删除，需将默认分支切换到其他分支\n    git branch -d main              // 删除本地分支main\n    ```\n\n3. ###### 新建并切换回原分支并删除临时分支\n\n    ```\n    git checkout -b main            // 新建本地分支main并切换\n    git push origin main            // 提交分支main到远端\n    git branch -d temp\t\t\t\t// 删除本地临时分支\n    git push origin --delete temp\t// 删除远端临时分支，此处注意如果要删除的远端分支为默认分支则不可删除，需将默认分支切换到其他分支\n    ```\n\n    > ###### github切换默认分支：\n    >\n    > \t进入对应repo → Settings → Branches → Switch to another branch","slug":"git-reset","published":1,"date":"2021-08-18T12:12:11.051Z","updated":"2021-08-18T12:32:47.092Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshhgzjj000tiobf1dfo3bmj","content":"<ol>\n<li><h6 id=\"回退\"><a href=\"#回退\" class=\"headerlink\" title=\"回退\"></a>回退</h6> <figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built-in\">log</span> <span class=\"comment\">//查看提交的历史</span></span><br><span class=\"line\">git reset --hard <span class=\"symbol\">$</span>要回退的commit号</span><br></pre></td></tr></table></figure>\n</li>\n<li><h6 id=\"切换到临时分支推送并删除原分支\"><a href=\"#切换到临时分支推送并删除原分支\" class=\"headerlink\" title=\"切换到临时分支推送并删除原分支\"></a>切换到临时分支推送并删除原分支</h6> <figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b temp            <span class=\"comment\">// 新建临时分支并切换</span></span><br><span class=\"line\">git <span class=\"keyword\">push</span> origin temp:temp       <span class=\"comment\">// 将代码push到temp分支</span></span><br><span class=\"line\">git <span class=\"keyword\">push</span> origin --<span class=\"keyword\">delete</span> main   <span class=\"comment\">// 删除远端分支main，此处注意如果要删除的远端分支为默认分支则不可删除，需将默认分支切换到其他分支</span></span><br><span class=\"line\">git branch -d main              <span class=\"comment\">// 删除本地分支main</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><h6 id=\"新建并切换回原分支并删除临时分支\"><a href=\"#新建并切换回原分支并删除临时分支\" class=\"headerlink\" title=\"新建并切换回原分支并删除临时分支\"></a>新建并切换回原分支并删除临时分支</h6> <figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b main            <span class=\"comment\">// 新建本地分支main并切换</span></span><br><span class=\"line\">git <span class=\"keyword\">push</span> origin main            <span class=\"comment\">// 提交分支main到远端</span></span><br><span class=\"line\">git branch -d temp\t\t\t\t<span class=\"comment\">// 删除本地临时分支</span></span><br><span class=\"line\">git <span class=\"keyword\">push</span> origin --<span class=\"keyword\">delete</span> temp\t<span class=\"comment\">// 删除远端临时分支，此处注意如果要删除的远端分支为默认分支则不可删除，需将默认分支切换到其他分支</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<h6 id=\"github切换默认分支：\"><a href=\"#github切换默认分支：\" class=\"headerlink\" title=\"github切换默认分支：\"></a>github切换默认分支：</h6><pre><code>进入对应repo → Settings → Branches → Switch to another branch</code></pre></blockquote>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><h6 id=\"回退\"><a href=\"#回退\" class=\"headerlink\" title=\"回退\"></a>回退</h6> <figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built-in\">log</span> <span class=\"comment\">//查看提交的历史</span></span><br><span class=\"line\">git reset --hard <span class=\"symbol\">$</span>要回退的commit号</span><br></pre></td></tr></table></figure>\n</li>\n<li><h6 id=\"切换到临时分支推送并删除原分支\"><a href=\"#切换到临时分支推送并删除原分支\" class=\"headerlink\" title=\"切换到临时分支推送并删除原分支\"></a>切换到临时分支推送并删除原分支</h6> <figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b temp            <span class=\"comment\">// 新建临时分支并切换</span></span><br><span class=\"line\">git <span class=\"keyword\">push</span> origin temp:temp       <span class=\"comment\">// 将代码push到temp分支</span></span><br><span class=\"line\">git <span class=\"keyword\">push</span> origin --<span class=\"keyword\">delete</span> main   <span class=\"comment\">// 删除远端分支main，此处注意如果要删除的远端分支为默认分支则不可删除，需将默认分支切换到其他分支</span></span><br><span class=\"line\">git branch -d main              <span class=\"comment\">// 删除本地分支main</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><h6 id=\"新建并切换回原分支并删除临时分支\"><a href=\"#新建并切换回原分支并删除临时分支\" class=\"headerlink\" title=\"新建并切换回原分支并删除临时分支\"></a>新建并切换回原分支并删除临时分支</h6> <figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b main            <span class=\"comment\">// 新建本地分支main并切换</span></span><br><span class=\"line\">git <span class=\"keyword\">push</span> origin main            <span class=\"comment\">// 提交分支main到远端</span></span><br><span class=\"line\">git branch -d temp\t\t\t\t<span class=\"comment\">// 删除本地临时分支</span></span><br><span class=\"line\">git <span class=\"keyword\">push</span> origin --<span class=\"keyword\">delete</span> temp\t<span class=\"comment\">// 删除远端临时分支，此处注意如果要删除的远端分支为默认分支则不可删除，需将默认分支切换到其他分支</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<h6 id=\"github切换默认分支：\"><a href=\"#github切换默认分支：\" class=\"headerlink\" title=\"github切换默认分支：\"></a>github切换默认分支：</h6><pre><code>进入对应repo → Settings → Branches → Switch to another branch</code></pre></blockquote>\n</li>\n</ol>\n"},{"title":"高并发IO的底层原理","header-img":"/img/header_img/dawn.jpg","catalog":true,"top":null,"abbrlink":"1af5","date":"2021-03-24T07:42:45.000Z","subtitle":null,"_content":"\n## 高并发IO的底层原理\n\n### 一、IO读写基础原理\n\n> ​\t\t用户程序进行IO的读写，会用到底层的read&write两大系统调用。无论是调用操作系统的read，还是write，都会涉及缓冲区。调用read，是把数据从内核缓冲区复制到进程缓冲区；而write，是把数据从进程缓冲区复制到内核缓冲区。也就是说，上层程序的IO操作，实际上不是物理设备级别的读写，而是缓存的复制。数据在内核缓冲区和物理设备（如磁盘）之间的交换，是由操作系统内核（Kernel）来完成的。\n\n#### 内核缓冲区与进程缓冲区\n\n​\t\t外部设备的直接读写，涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，而结束中断之后，还需要恢复之前的进程数据和状态等信息。为了减少这种底层系统的时间损耗、性能损耗，于是出现了内存缓冲区。每个用户程序（进程），有自己独立的缓冲区，叫作进程缓冲区。\n\n**典型的网络IO系统调用流程**，如图：\n\n![image](https://tvax1.sinaimg.cn/large/006YzKDNly1gous8df2kgj30h0096mxz.jpg)\n\n如果是在Java服务器端，完成一次socket请求和响应，完整的流程如下：\n\n- 客户端请求：Linux通过网卡读取客户端的请求数据，将数据读取到内核缓冲区。\n- 获取请求数据：Java服务器通过read系统调用，从Linux内核缓冲区读取数据，再送入Java进程缓冲区。\n- 服务器端业务处理：Java服务器在自己的用户空间中处理客户端的请求。\n- 服务器端返回数据：Java服务器完成处理后，构建好的响应数据，将这些数据从用户缓冲区写入内核缓冲区。这里用到的是write系统调用。\n- 发送给客户端：Linux内核通过网络IO，将内核缓冲区中的数据写入网卡，网卡通过底层的通信协议，会将数据发送给目标客户端。\n\n### 二、四种主要的IO模型\n\n> **阻塞与非阻塞**：阻塞IO，指的是需要内核IO操作彻底完成后，才返回到用户空间执行用户的操作。阻塞指的是用户空间程序的执行状态。\n>\n> **同步与异步**：同步IO是指用户空间的线程是主动发起IO请求的一方，内核空间是被动接受方。异步IO则反过来，是指系统内核是主动发起IO请求的一方（通知或回调），用户空间的线程是被动接受方。\n\n#### 1. 同步阻塞IO（Blocking IO）\n\n​\t\t在Java中，默认创建的socket都是同步阻塞的。在阻塞式IO模型中，Java应用程序**从IO系统调用开始，直到系统调用返回**，在这段时间内，Java进程是**阻塞**的。返回成功后，应用进程开始处理用户空间的缓存区数据。\n\n**同步阻塞IO流程**，如图：\n\n![image](https://tvax1.sinaimg.cn/large/006YzKDNly1gov1uvelijj30i30bbgph.jpg)\n\n- 阻塞IO特点：在内核进行IO执行的两个阶段（等待数据和复制数据），用户线程都被阻塞了。\n\n- 阻塞IO优点：应用的程序开发非常简单；在阻塞等待数据期间，用户线程挂起，基本不会占用CPU资源。\n\n- 阻塞IO缺点：一般情况下，会为每个连接配备一个独立的线程；反过来说，就是一个线程维护一个连接的IO操作。在并发量小的情况下，这样做没有什么问题。但是，当在高并发的应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。因此，基本上阻塞IO模型在高并发应用场景下是不可用的。\n\n#### 2. 同步非阻塞IO（Non-blocking IO）\n\n> 这里的NIO并非Java的NIO（New IO），Java的NIO，对应的不是四种基础IO模型中的NIO（None Blocking IO）模型，而是另外的一种模型，叫作IO多路复用模型（IO Multiplexing）。\n\n​\t\t在NIO模型中，应用程序一旦开始IO系统调用，会出现以下两种情况：\n\n​\t\t1. 在内核缓冲区中**没有数据**的情况下，系统调用会立即返回，返回一个调用失败的信息。\n\n​\t\t2. 在内核缓冲区中**有数据**的情况下，是**阻塞**的，直到数据从内核缓冲复制到用户进程缓冲。复制完成后，系统调用返回成功，应用进程开始处理用户空间的缓存数据。\n\n**同步非阻塞IO流程**，如图*(图源公众号“码农翻身”，侵删)*：\n\n![image](https://tva4.sinaimg.cn/large/006YzKDNgy1goxfc4wvqoj30ll0fmgmt.jpg)\n\n- 同步非阻塞IO**特点**：应用程序的线程需要不断地进行IO系统调用，轮询数据是否已经准备好，如果没有准备好，就继续**轮询**，直到完成IO系统调用为止。一般不单独使用，在其他模型中应用。\n\n- 同步非阻塞IO**优点**：每次发起的IO系统调用，在内核等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。\n\n- 同步非阻塞IO**缺点**：不断地轮询内核，这将占用大量的CPU时间，效率低下。\n\n#### 3. IO多路复用（IO Multiplexing）\n\n> 解决同步非阻塞IO模型中轮询等待的问题\n\n​\t\t在IO多路复用模型中，引入了一种新的系统调用，查询IO的就绪状态。在Linux系统中，对应的系统调用为select/epoll系统调用。通过该系统调用，单个应用程序的线程，可以不断地轮询成百上千的socket连接，一旦某个socket就绪（一般是内核缓冲区可读/可写），内核能够将就绪的状态返回给应用程序。随后，应用程序根据就绪的状态，进行相应的IO系统调用。\n\n**IO多路复用模型流程**，如图：\n\n![image](https://tvax3.sinaimg.cn/large/006YzKDNly1gov3zz1xp6j30h80bhdkc.jpg)\n\n- IO多路复用模型**特点**：涉及两种系统调用（SystemCall），一种是select/epoll（就绪查询），一种是IO操作。要使用IO多路复用模型，操作系统必须支持提供多路分离的系统调用select/epoll。负责select/epoll状态查询调用的线程，需要不断地进行select/epoll轮询，查找出达到IO操作就绪的socket连接。对于注册在选择器（Java中对应的选择器类是Selector类）上的**每一个可以查询的socket连接**，一般都设置成为**同步非阻塞模型**。\n- IO多路复用模型**优点**：一个选择器查询线程可以同时处理成千上万个连接（Connection）。系统不必创建和维护大量线程，减小系统开销。*Java的NIO（New IO）技术和Netty框架，使用的就是IO多路复用模型。在Linux系统上，使用的是epoll系统调用。*\n- IO多路复用模型**缺点**：本质上，select/epoll系统调用是阻塞式的，属于同步IO。都需要在读写事件就绪后，由系统调用本身负责进行读写，也就是说这个读写过程是阻塞的。\n\n##### select: \n\n​\t\tselect可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理*(图源公众号“码农翻身”，侵删)*：\n\n![20210326180007](https://tva2.sinaimg.cn/large/006YzKDNgy1goxgnhkba8g30fa0b4x6p.gif)\n\n1. 首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。\n2. 然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。\n3. 不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。\n\n可以看出几个问题：\n\n​\t1. select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）\n\n​\t2. select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）\n\n​\t3. select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）\n\n##### epoll:\n\n​\t\t解决了 select 的上述问题:\n\n  1. 内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。\n\n  2. 内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。\n\n  3. 内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。\n\n     原理如图*(图源公众号“码农翻身”，侵删)*：\n\n     ![20210326181258](https://tvax2.sinaimg.cn/large/006YzKDNgy1goxh0qffnzg30fa0b4e81.gif)\n\n     **多路复用快的原因**：操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。\n\n#### 4. 异步IO（Asynchronous IO）\n\n> 彻底解除线程的阻塞\n\n​\t\t对于异步IO，当用户线程发起read系统调用后，立刻就可以做其他的事，不阻塞。内核开始准备数据，并复制数据到用户缓冲区。复制完成后，内核会给用户线程发送一个信号（Signal），或者回调用户线程注册的回调接口，告诉用户线程read操作完成了。\n\n**异步IO模型流程**，如图：\n\n![image](https://tvax3.sinaimg.cn/large/006YzKDNly1gov4h3y1m6j30go0c2q7m.jpg)\n\n- 异步IO模型**特点**：在内核等待数据和复制数据的**两个阶段，用户线程都不阻塞**。用户线程需要接收内核的IO操作完成的事件，或者用户线程需要注册一个IO操作完成的回调函数。正因为如此，异步IO有的时候也被称为信号驱动IO。\n- 异步IO模型缺点：应用程序仅需要进行事件的注册与接收，其余的工作都留给了操作系统，也就是说，需要底层内核提供支持。\n\n> ​        就目前而言，Windows系统下通过IOCP实现了真正的异步IO。而在Linux系统下，异步IO模型在2.6版本才引入，目前并不完善，其底层实现仍使用epoll，与IO多路复用相同，因此在性能上没有明显的优势。大多数高并发服务器端程序，都是基于Linux系统的。因而，**目前这类高并发网络应用程序的开发，大多采用IO多路复用模型。**\n\n### 三、系统配置最大句柄\n\n> 在生产环境Linux系统中，基本上都需要解除文件句柄数的限制。因为Linux的系统默认值为1024，也就是说，一个进程最多可以接受1024个socket连接。\n\n#### 文件句柄\n\n​\t\t也叫文件描述符，在Linux系统中，文件可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（File Descriptor）是内核为了高效管理已被打开的文件所创建的索引，它是一个非负整数（通常是小整数），用于指代被打开的文件。所有的IO系统调用，包括socket的读写调用，都是通过文件描述符完成的。在Linux下，可以通过`ulimit -n`看到单个进程能够打开的最大文件句柄数量。Linux的系统默认值为1024。\n\n​\t\t对于高并发的应用，面临的并发连接数往往是十万级、百万级、千万级、甚至像腾讯QQ一样的上亿级。当单个进程打开的文件句柄数量，超过了系统配置上限值时，会发出“Socket/File:Can't open so many files”的错误提示。\n\n#### 配置\n\n​\t\t可以通过`ulimit -n 1000000`修改句柄数（最大值是1048576 ），但是ulimit命令仅对当前用户有效，如果想永久保存配置，可以编辑/etc/rc.local开机启动文件，添加如下内容：\n\n```\nulimit -SHn 1000000\n```\n\n​\t\t增加-S和-H两个命令选项。选项-S表示软性极限值，-H表示硬性极限值。硬性极限（需要root权限）是实际的限制，就是最大可以是100万，不能再多了。软性极限是系统警告（Warning）的极限值，超过这个极限值，内核会发出警告。\n\n​\t\t终极解除Linux系统的最大文件打开数量的限制，可以编辑/etc/security/limits.conf，添加如下内容：\n\n```\nsoft nofile 1000000\nhard nofile 1000000\n```\n\nsoft nofile表示软性极限，hard nofile表示硬性极限。不可以设置unlimited。\n\n","source":"_posts/io.md","raw":"---\ntitle: 高并发IO的底层原理\nheader-img: /img/header_img/dawn.jpg\ncatalog: true\ntop:\ntags:\n  - IO\ncategories:\n  - work\nabbrlink: 1af5\ndate: 2021-3-24 15:42:45\nsubtitle:\n---\n\n## 高并发IO的底层原理\n\n### 一、IO读写基础原理\n\n> ​\t\t用户程序进行IO的读写，会用到底层的read&write两大系统调用。无论是调用操作系统的read，还是write，都会涉及缓冲区。调用read，是把数据从内核缓冲区复制到进程缓冲区；而write，是把数据从进程缓冲区复制到内核缓冲区。也就是说，上层程序的IO操作，实际上不是物理设备级别的读写，而是缓存的复制。数据在内核缓冲区和物理设备（如磁盘）之间的交换，是由操作系统内核（Kernel）来完成的。\n\n#### 内核缓冲区与进程缓冲区\n\n​\t\t外部设备的直接读写，涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，而结束中断之后，还需要恢复之前的进程数据和状态等信息。为了减少这种底层系统的时间损耗、性能损耗，于是出现了内存缓冲区。每个用户程序（进程），有自己独立的缓冲区，叫作进程缓冲区。\n\n**典型的网络IO系统调用流程**，如图：\n\n![image](https://tvax1.sinaimg.cn/large/006YzKDNly1gous8df2kgj30h0096mxz.jpg)\n\n如果是在Java服务器端，完成一次socket请求和响应，完整的流程如下：\n\n- 客户端请求：Linux通过网卡读取客户端的请求数据，将数据读取到内核缓冲区。\n- 获取请求数据：Java服务器通过read系统调用，从Linux内核缓冲区读取数据，再送入Java进程缓冲区。\n- 服务器端业务处理：Java服务器在自己的用户空间中处理客户端的请求。\n- 服务器端返回数据：Java服务器完成处理后，构建好的响应数据，将这些数据从用户缓冲区写入内核缓冲区。这里用到的是write系统调用。\n- 发送给客户端：Linux内核通过网络IO，将内核缓冲区中的数据写入网卡，网卡通过底层的通信协议，会将数据发送给目标客户端。\n\n### 二、四种主要的IO模型\n\n> **阻塞与非阻塞**：阻塞IO，指的是需要内核IO操作彻底完成后，才返回到用户空间执行用户的操作。阻塞指的是用户空间程序的执行状态。\n>\n> **同步与异步**：同步IO是指用户空间的线程是主动发起IO请求的一方，内核空间是被动接受方。异步IO则反过来，是指系统内核是主动发起IO请求的一方（通知或回调），用户空间的线程是被动接受方。\n\n#### 1. 同步阻塞IO（Blocking IO）\n\n​\t\t在Java中，默认创建的socket都是同步阻塞的。在阻塞式IO模型中，Java应用程序**从IO系统调用开始，直到系统调用返回**，在这段时间内，Java进程是**阻塞**的。返回成功后，应用进程开始处理用户空间的缓存区数据。\n\n**同步阻塞IO流程**，如图：\n\n![image](https://tvax1.sinaimg.cn/large/006YzKDNly1gov1uvelijj30i30bbgph.jpg)\n\n- 阻塞IO特点：在内核进行IO执行的两个阶段（等待数据和复制数据），用户线程都被阻塞了。\n\n- 阻塞IO优点：应用的程序开发非常简单；在阻塞等待数据期间，用户线程挂起，基本不会占用CPU资源。\n\n- 阻塞IO缺点：一般情况下，会为每个连接配备一个独立的线程；反过来说，就是一个线程维护一个连接的IO操作。在并发量小的情况下，这样做没有什么问题。但是，当在高并发的应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。因此，基本上阻塞IO模型在高并发应用场景下是不可用的。\n\n#### 2. 同步非阻塞IO（Non-blocking IO）\n\n> 这里的NIO并非Java的NIO（New IO），Java的NIO，对应的不是四种基础IO模型中的NIO（None Blocking IO）模型，而是另外的一种模型，叫作IO多路复用模型（IO Multiplexing）。\n\n​\t\t在NIO模型中，应用程序一旦开始IO系统调用，会出现以下两种情况：\n\n​\t\t1. 在内核缓冲区中**没有数据**的情况下，系统调用会立即返回，返回一个调用失败的信息。\n\n​\t\t2. 在内核缓冲区中**有数据**的情况下，是**阻塞**的，直到数据从内核缓冲复制到用户进程缓冲。复制完成后，系统调用返回成功，应用进程开始处理用户空间的缓存数据。\n\n**同步非阻塞IO流程**，如图*(图源公众号“码农翻身”，侵删)*：\n\n![image](https://tva4.sinaimg.cn/large/006YzKDNgy1goxfc4wvqoj30ll0fmgmt.jpg)\n\n- 同步非阻塞IO**特点**：应用程序的线程需要不断地进行IO系统调用，轮询数据是否已经准备好，如果没有准备好，就继续**轮询**，直到完成IO系统调用为止。一般不单独使用，在其他模型中应用。\n\n- 同步非阻塞IO**优点**：每次发起的IO系统调用，在内核等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。\n\n- 同步非阻塞IO**缺点**：不断地轮询内核，这将占用大量的CPU时间，效率低下。\n\n#### 3. IO多路复用（IO Multiplexing）\n\n> 解决同步非阻塞IO模型中轮询等待的问题\n\n​\t\t在IO多路复用模型中，引入了一种新的系统调用，查询IO的就绪状态。在Linux系统中，对应的系统调用为select/epoll系统调用。通过该系统调用，单个应用程序的线程，可以不断地轮询成百上千的socket连接，一旦某个socket就绪（一般是内核缓冲区可读/可写），内核能够将就绪的状态返回给应用程序。随后，应用程序根据就绪的状态，进行相应的IO系统调用。\n\n**IO多路复用模型流程**，如图：\n\n![image](https://tvax3.sinaimg.cn/large/006YzKDNly1gov3zz1xp6j30h80bhdkc.jpg)\n\n- IO多路复用模型**特点**：涉及两种系统调用（SystemCall），一种是select/epoll（就绪查询），一种是IO操作。要使用IO多路复用模型，操作系统必须支持提供多路分离的系统调用select/epoll。负责select/epoll状态查询调用的线程，需要不断地进行select/epoll轮询，查找出达到IO操作就绪的socket连接。对于注册在选择器（Java中对应的选择器类是Selector类）上的**每一个可以查询的socket连接**，一般都设置成为**同步非阻塞模型**。\n- IO多路复用模型**优点**：一个选择器查询线程可以同时处理成千上万个连接（Connection）。系统不必创建和维护大量线程，减小系统开销。*Java的NIO（New IO）技术和Netty框架，使用的就是IO多路复用模型。在Linux系统上，使用的是epoll系统调用。*\n- IO多路复用模型**缺点**：本质上，select/epoll系统调用是阻塞式的，属于同步IO。都需要在读写事件就绪后，由系统调用本身负责进行读写，也就是说这个读写过程是阻塞的。\n\n##### select: \n\n​\t\tselect可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理*(图源公众号“码农翻身”，侵删)*：\n\n![20210326180007](https://tva2.sinaimg.cn/large/006YzKDNgy1goxgnhkba8g30fa0b4x6p.gif)\n\n1. 首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。\n2. 然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。\n3. 不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。\n\n可以看出几个问题：\n\n​\t1. select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）\n\n​\t2. select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）\n\n​\t3. select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）\n\n##### epoll:\n\n​\t\t解决了 select 的上述问题:\n\n  1. 内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。\n\n  2. 内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。\n\n  3. 内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。\n\n     原理如图*(图源公众号“码农翻身”，侵删)*：\n\n     ![20210326181258](https://tvax2.sinaimg.cn/large/006YzKDNgy1goxh0qffnzg30fa0b4e81.gif)\n\n     **多路复用快的原因**：操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。\n\n#### 4. 异步IO（Asynchronous IO）\n\n> 彻底解除线程的阻塞\n\n​\t\t对于异步IO，当用户线程发起read系统调用后，立刻就可以做其他的事，不阻塞。内核开始准备数据，并复制数据到用户缓冲区。复制完成后，内核会给用户线程发送一个信号（Signal），或者回调用户线程注册的回调接口，告诉用户线程read操作完成了。\n\n**异步IO模型流程**，如图：\n\n![image](https://tvax3.sinaimg.cn/large/006YzKDNly1gov4h3y1m6j30go0c2q7m.jpg)\n\n- 异步IO模型**特点**：在内核等待数据和复制数据的**两个阶段，用户线程都不阻塞**。用户线程需要接收内核的IO操作完成的事件，或者用户线程需要注册一个IO操作完成的回调函数。正因为如此，异步IO有的时候也被称为信号驱动IO。\n- 异步IO模型缺点：应用程序仅需要进行事件的注册与接收，其余的工作都留给了操作系统，也就是说，需要底层内核提供支持。\n\n> ​        就目前而言，Windows系统下通过IOCP实现了真正的异步IO。而在Linux系统下，异步IO模型在2.6版本才引入，目前并不完善，其底层实现仍使用epoll，与IO多路复用相同，因此在性能上没有明显的优势。大多数高并发服务器端程序，都是基于Linux系统的。因而，**目前这类高并发网络应用程序的开发，大多采用IO多路复用模型。**\n\n### 三、系统配置最大句柄\n\n> 在生产环境Linux系统中，基本上都需要解除文件句柄数的限制。因为Linux的系统默认值为1024，也就是说，一个进程最多可以接受1024个socket连接。\n\n#### 文件句柄\n\n​\t\t也叫文件描述符，在Linux系统中，文件可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（File Descriptor）是内核为了高效管理已被打开的文件所创建的索引，它是一个非负整数（通常是小整数），用于指代被打开的文件。所有的IO系统调用，包括socket的读写调用，都是通过文件描述符完成的。在Linux下，可以通过`ulimit -n`看到单个进程能够打开的最大文件句柄数量。Linux的系统默认值为1024。\n\n​\t\t对于高并发的应用，面临的并发连接数往往是十万级、百万级、千万级、甚至像腾讯QQ一样的上亿级。当单个进程打开的文件句柄数量，超过了系统配置上限值时，会发出“Socket/File:Can't open so many files”的错误提示。\n\n#### 配置\n\n​\t\t可以通过`ulimit -n 1000000`修改句柄数（最大值是1048576 ），但是ulimit命令仅对当前用户有效，如果想永久保存配置，可以编辑/etc/rc.local开机启动文件，添加如下内容：\n\n```\nulimit -SHn 1000000\n```\n\n​\t\t增加-S和-H两个命令选项。选项-S表示软性极限值，-H表示硬性极限值。硬性极限（需要root权限）是实际的限制，就是最大可以是100万，不能再多了。软性极限是系统警告（Warning）的极限值，超过这个极限值，内核会发出警告。\n\n​\t\t终极解除Linux系统的最大文件打开数量的限制，可以编辑/etc/security/limits.conf，添加如下内容：\n\n```\nsoft nofile 1000000\nhard nofile 1000000\n```\n\nsoft nofile表示软性极限，hard nofile表示硬性极限。不可以设置unlimited。\n\n","slug":"io","published":1,"updated":"2021-08-18T12:40:25.515Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshhgzjl000wiobf9gs10iae","content":"<h2 id=\"高并发IO的底层原理\"><a href=\"#高并发IO的底层原理\" class=\"headerlink\" title=\"高并发IO的底层原理\"></a>高并发IO的底层原理</h2><h3 id=\"一、IO读写基础原理\"><a href=\"#一、IO读写基础原理\" class=\"headerlink\" title=\"一、IO读写基础原理\"></a>一、IO读写基础原理</h3><blockquote>\n<p>​        用户程序进行IO的读写，会用到底层的read&amp;write两大系统调用。无论是调用操作系统的read，还是write，都会涉及缓冲区。调用read，是把数据从内核缓冲区复制到进程缓冲区；而write，是把数据从进程缓冲区复制到内核缓冲区。也就是说，上层程序的IO操作，实际上不是物理设备级别的读写，而是缓存的复制。数据在内核缓冲区和物理设备（如磁盘）之间的交换，是由操作系统内核（Kernel）来完成的。</p>\n</blockquote>\n<h4 id=\"内核缓冲区与进程缓冲区\"><a href=\"#内核缓冲区与进程缓冲区\" class=\"headerlink\" title=\"内核缓冲区与进程缓冲区\"></a>内核缓冲区与进程缓冲区</h4><p>​        外部设备的直接读写，涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，而结束中断之后，还需要恢复之前的进程数据和状态等信息。为了减少这种底层系统的时间损耗、性能损耗，于是出现了内存缓冲区。每个用户程序（进程），有自己独立的缓冲区，叫作进程缓冲区。</p>\n<p><strong>典型的网络IO系统调用流程</strong>，如图：</p>\n<p><img src=\"https://tvax1.sinaimg.cn/large/006YzKDNly1gous8df2kgj30h0096mxz.jpg\" alt=\"image\"></p>\n<p>如果是在Java服务器端，完成一次socket请求和响应，完整的流程如下：</p>\n<ul>\n<li>客户端请求：Linux通过网卡读取客户端的请求数据，将数据读取到内核缓冲区。</li>\n<li>获取请求数据：Java服务器通过read系统调用，从Linux内核缓冲区读取数据，再送入Java进程缓冲区。</li>\n<li>服务器端业务处理：Java服务器在自己的用户空间中处理客户端的请求。</li>\n<li>服务器端返回数据：Java服务器完成处理后，构建好的响应数据，将这些数据从用户缓冲区写入内核缓冲区。这里用到的是write系统调用。</li>\n<li>发送给客户端：Linux内核通过网络IO，将内核缓冲区中的数据写入网卡，网卡通过底层的通信协议，会将数据发送给目标客户端。</li>\n</ul>\n<h3 id=\"二、四种主要的IO模型\"><a href=\"#二、四种主要的IO模型\" class=\"headerlink\" title=\"二、四种主要的IO模型\"></a>二、四种主要的IO模型</h3><blockquote>\n<p><strong>阻塞与非阻塞</strong>：阻塞IO，指的是需要内核IO操作彻底完成后，才返回到用户空间执行用户的操作。阻塞指的是用户空间程序的执行状态。</p>\n<p><strong>同步与异步</strong>：同步IO是指用户空间的线程是主动发起IO请求的一方，内核空间是被动接受方。异步IO则反过来，是指系统内核是主动发起IO请求的一方（通知或回调），用户空间的线程是被动接受方。</p>\n</blockquote>\n<h4 id=\"1-同步阻塞IO（Blocking-IO）\"><a href=\"#1-同步阻塞IO（Blocking-IO）\" class=\"headerlink\" title=\"1. 同步阻塞IO（Blocking IO）\"></a>1. 同步阻塞IO（Blocking IO）</h4><p>​        在Java中，默认创建的socket都是同步阻塞的。在阻塞式IO模型中，Java应用程序<strong>从IO系统调用开始，直到系统调用返回</strong>，在这段时间内，Java进程是<strong>阻塞</strong>的。返回成功后，应用进程开始处理用户空间的缓存区数据。</p>\n<p><strong>同步阻塞IO流程</strong>，如图：</p>\n<p><img src=\"https://tvax1.sinaimg.cn/large/006YzKDNly1gov1uvelijj30i30bbgph.jpg\" alt=\"image\"></p>\n<ul>\n<li><p>阻塞IO特点：在内核进行IO执行的两个阶段（等待数据和复制数据），用户线程都被阻塞了。</p>\n</li>\n<li><p>阻塞IO优点：应用的程序开发非常简单；在阻塞等待数据期间，用户线程挂起，基本不会占用CPU资源。</p>\n</li>\n<li><p>阻塞IO缺点：一般情况下，会为每个连接配备一个独立的线程；反过来说，就是一个线程维护一个连接的IO操作。在并发量小的情况下，这样做没有什么问题。但是，当在高并发的应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。因此，基本上阻塞IO模型在高并发应用场景下是不可用的。</p>\n</li>\n</ul>\n<h4 id=\"2-同步非阻塞IO（Non-blocking-IO）\"><a href=\"#2-同步非阻塞IO（Non-blocking-IO）\" class=\"headerlink\" title=\"2. 同步非阻塞IO（Non-blocking IO）\"></a>2. 同步非阻塞IO（Non-blocking IO）</h4><blockquote>\n<p>这里的NIO并非Java的NIO（New IO），Java的NIO，对应的不是四种基础IO模型中的NIO（None Blocking IO）模型，而是另外的一种模型，叫作IO多路复用模型（IO Multiplexing）。</p>\n</blockquote>\n<p>​        在NIO模型中，应用程序一旦开始IO系统调用，会出现以下两种情况：</p>\n<p>​        1. 在内核缓冲区中<strong>没有数据</strong>的情况下，系统调用会立即返回，返回一个调用失败的信息。</p>\n<p>​        2. 在内核缓冲区中<strong>有数据</strong>的情况下，是<strong>阻塞</strong>的，直到数据从内核缓冲复制到用户进程缓冲。复制完成后，系统调用返回成功，应用进程开始处理用户空间的缓存数据。</p>\n<p><strong>同步非阻塞IO流程</strong>，如图<em>(图源公众号“码农翻身”，侵删)</em>：</p>\n<p><img src=\"https://tva4.sinaimg.cn/large/006YzKDNgy1goxfc4wvqoj30ll0fmgmt.jpg\" alt=\"image\"></p>\n<ul>\n<li><p>同步非阻塞IO<strong>特点</strong>：应用程序的线程需要不断地进行IO系统调用，轮询数据是否已经准备好，如果没有准备好，就继续<strong>轮询</strong>，直到完成IO系统调用为止。一般不单独使用，在其他模型中应用。</p>\n</li>\n<li><p>同步非阻塞IO<strong>优点</strong>：每次发起的IO系统调用，在内核等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。</p>\n</li>\n<li><p>同步非阻塞IO<strong>缺点</strong>：不断地轮询内核，这将占用大量的CPU时间，效率低下。</p>\n</li>\n</ul>\n<h4 id=\"3-IO多路复用（IO-Multiplexing）\"><a href=\"#3-IO多路复用（IO-Multiplexing）\" class=\"headerlink\" title=\"3. IO多路复用（IO Multiplexing）\"></a>3. IO多路复用（IO Multiplexing）</h4><blockquote>\n<p>解决同步非阻塞IO模型中轮询等待的问题</p>\n</blockquote>\n<p>​        在IO多路复用模型中，引入了一种新的系统调用，查询IO的就绪状态。在Linux系统中，对应的系统调用为select/epoll系统调用。通过该系统调用，单个应用程序的线程，可以不断地轮询成百上千的socket连接，一旦某个socket就绪（一般是内核缓冲区可读/可写），内核能够将就绪的状态返回给应用程序。随后，应用程序根据就绪的状态，进行相应的IO系统调用。</p>\n<p><strong>IO多路复用模型流程</strong>，如图：</p>\n<p><img src=\"https://tvax3.sinaimg.cn/large/006YzKDNly1gov3zz1xp6j30h80bhdkc.jpg\" alt=\"image\"></p>\n<ul>\n<li>IO多路复用模型<strong>特点</strong>：涉及两种系统调用（SystemCall），一种是select/epoll（就绪查询），一种是IO操作。要使用IO多路复用模型，操作系统必须支持提供多路分离的系统调用select/epoll。负责select/epoll状态查询调用的线程，需要不断地进行select/epoll轮询，查找出达到IO操作就绪的socket连接。对于注册在选择器（Java中对应的选择器类是Selector类）上的<strong>每一个可以查询的socket连接</strong>，一般都设置成为<strong>同步非阻塞模型</strong>。</li>\n<li>IO多路复用模型<strong>优点</strong>：一个选择器查询线程可以同时处理成千上万个连接（Connection）。系统不必创建和维护大量线程，减小系统开销。<em>Java的NIO（New IO）技术和Netty框架，使用的就是IO多路复用模型。在Linux系统上，使用的是epoll系统调用。</em></li>\n<li>IO多路复用模型<strong>缺点</strong>：本质上，select/epoll系统调用是阻塞式的，属于同步IO。都需要在读写事件就绪后，由系统调用本身负责进行读写，也就是说这个读写过程是阻塞的。</li>\n</ul>\n<h5 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select:\"></a>select:</h5><p>​        select可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理<em>(图源公众号“码农翻身”，侵删)</em>：</p>\n<p><img src=\"https://tva2.sinaimg.cn/large/006YzKDNgy1goxgnhkba8g30fa0b4x6p.gif\" alt=\"20210326180007\"></p>\n<ol>\n<li>首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。</li>\n<li>然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。</li>\n<li>不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。</li>\n</ol>\n<p>可以看出几个问题：</p>\n<p>​    1. select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>\n<p>​    2. select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>\n<p>​    3. select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>\n<h5 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll:\"></a>epoll:</h5><p>​        解决了 select 的上述问题:</p>\n<ol>\n<li><p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</p>\n</li>\n<li><p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p>\n</li>\n<li><p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p>\n<p>原理如图<em>(图源公众号“码农翻身”，侵删)</em>：</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNgy1goxh0qffnzg30fa0b4e81.gif\" alt=\"20210326181258\"></p>\n<p><strong>多路复用快的原因</strong>：操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。</p>\n</li>\n</ol>\n<h4 id=\"4-异步IO（Asynchronous-IO）\"><a href=\"#4-异步IO（Asynchronous-IO）\" class=\"headerlink\" title=\"4. 异步IO（Asynchronous IO）\"></a>4. 异步IO（Asynchronous IO）</h4><blockquote>\n<p>彻底解除线程的阻塞</p>\n</blockquote>\n<p>​        对于异步IO，当用户线程发起read系统调用后，立刻就可以做其他的事，不阻塞。内核开始准备数据，并复制数据到用户缓冲区。复制完成后，内核会给用户线程发送一个信号（Signal），或者回调用户线程注册的回调接口，告诉用户线程read操作完成了。</p>\n<p><strong>异步IO模型流程</strong>，如图：</p>\n<p><img src=\"https://tvax3.sinaimg.cn/large/006YzKDNly1gov4h3y1m6j30go0c2q7m.jpg\" alt=\"image\"></p>\n<ul>\n<li>异步IO模型<strong>特点</strong>：在内核等待数据和复制数据的<strong>两个阶段，用户线程都不阻塞</strong>。用户线程需要接收内核的IO操作完成的事件，或者用户线程需要注册一个IO操作完成的回调函数。正因为如此，异步IO有的时候也被称为信号驱动IO。</li>\n<li>异步IO模型缺点：应用程序仅需要进行事件的注册与接收，其余的工作都留给了操作系统，也就是说，需要底层内核提供支持。</li>\n</ul>\n<blockquote>\n<p>​        就目前而言，Windows系统下通过IOCP实现了真正的异步IO。而在Linux系统下，异步IO模型在2.6版本才引入，目前并不完善，其底层实现仍使用epoll，与IO多路复用相同，因此在性能上没有明显的优势。大多数高并发服务器端程序，都是基于Linux系统的。因而，<strong>目前这类高并发网络应用程序的开发，大多采用IO多路复用模型。</strong></p>\n</blockquote>\n<h3 id=\"三、系统配置最大句柄\"><a href=\"#三、系统配置最大句柄\" class=\"headerlink\" title=\"三、系统配置最大句柄\"></a>三、系统配置最大句柄</h3><blockquote>\n<p>在生产环境Linux系统中，基本上都需要解除文件句柄数的限制。因为Linux的系统默认值为1024，也就是说，一个进程最多可以接受1024个socket连接。</p>\n</blockquote>\n<h4 id=\"文件句柄\"><a href=\"#文件句柄\" class=\"headerlink\" title=\"文件句柄\"></a>文件句柄</h4><p>​        也叫文件描述符，在Linux系统中，文件可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（File Descriptor）是内核为了高效管理已被打开的文件所创建的索引，它是一个非负整数（通常是小整数），用于指代被打开的文件。所有的IO系统调用，包括socket的读写调用，都是通过文件描述符完成的。在Linux下，可以通过<code>ulimit -n</code>看到单个进程能够打开的最大文件句柄数量。Linux的系统默认值为1024。</p>\n<p>​        对于高并发的应用，面临的并发连接数往往是十万级、百万级、千万级、甚至像腾讯QQ一样的上亿级。当单个进程打开的文件句柄数量，超过了系统配置上限值时，会发出“Socket/File:Can’t open so many files”的错误提示。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>​        可以通过<code>ulimit -n 1000000</code>修改句柄数（最大值是1048576 ），但是ulimit命令仅对当前用户有效，如果想永久保存配置，可以编辑/etc/rc.local开机启动文件，添加如下内容：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ulimit -SHn <span class=\"number\">1000000</span></span><br></pre></td></tr></table></figure>\n\n<p>​        增加-S和-H两个命令选项。选项-S表示软性极限值，-H表示硬性极限值。硬性极限（需要root权限）是实际的限制，就是最大可以是100万，不能再多了。软性极限是系统警告（Warning）的极限值，超过这个极限值，内核会发出警告。</p>\n<p>​        终极解除Linux系统的最大文件打开数量的限制，可以编辑/etc/security/limits.conf，添加如下内容：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">soft nofile <span class=\"number\">1000000</span></span><br><span class=\"line\">hard nofile <span class=\"number\">1000000</span></span><br></pre></td></tr></table></figure>\n\n<p>soft nofile表示软性极限，hard nofile表示硬性极限。不可以设置unlimited。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"高并发IO的底层原理\"><a href=\"#高并发IO的底层原理\" class=\"headerlink\" title=\"高并发IO的底层原理\"></a>高并发IO的底层原理</h2><h3 id=\"一、IO读写基础原理\"><a href=\"#一、IO读写基础原理\" class=\"headerlink\" title=\"一、IO读写基础原理\"></a>一、IO读写基础原理</h3><blockquote>\n<p>​        用户程序进行IO的读写，会用到底层的read&amp;write两大系统调用。无论是调用操作系统的read，还是write，都会涉及缓冲区。调用read，是把数据从内核缓冲区复制到进程缓冲区；而write，是把数据从进程缓冲区复制到内核缓冲区。也就是说，上层程序的IO操作，实际上不是物理设备级别的读写，而是缓存的复制。数据在内核缓冲区和物理设备（如磁盘）之间的交换，是由操作系统内核（Kernel）来完成的。</p>\n</blockquote>\n<h4 id=\"内核缓冲区与进程缓冲区\"><a href=\"#内核缓冲区与进程缓冲区\" class=\"headerlink\" title=\"内核缓冲区与进程缓冲区\"></a>内核缓冲区与进程缓冲区</h4><p>​        外部设备的直接读写，涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，而结束中断之后，还需要恢复之前的进程数据和状态等信息。为了减少这种底层系统的时间损耗、性能损耗，于是出现了内存缓冲区。每个用户程序（进程），有自己独立的缓冲区，叫作进程缓冲区。</p>\n<p><strong>典型的网络IO系统调用流程</strong>，如图：</p>\n<p><img src=\"https://tvax1.sinaimg.cn/large/006YzKDNly1gous8df2kgj30h0096mxz.jpg\" alt=\"image\"></p>\n<p>如果是在Java服务器端，完成一次socket请求和响应，完整的流程如下：</p>\n<ul>\n<li>客户端请求：Linux通过网卡读取客户端的请求数据，将数据读取到内核缓冲区。</li>\n<li>获取请求数据：Java服务器通过read系统调用，从Linux内核缓冲区读取数据，再送入Java进程缓冲区。</li>\n<li>服务器端业务处理：Java服务器在自己的用户空间中处理客户端的请求。</li>\n<li>服务器端返回数据：Java服务器完成处理后，构建好的响应数据，将这些数据从用户缓冲区写入内核缓冲区。这里用到的是write系统调用。</li>\n<li>发送给客户端：Linux内核通过网络IO，将内核缓冲区中的数据写入网卡，网卡通过底层的通信协议，会将数据发送给目标客户端。</li>\n</ul>\n<h3 id=\"二、四种主要的IO模型\"><a href=\"#二、四种主要的IO模型\" class=\"headerlink\" title=\"二、四种主要的IO模型\"></a>二、四种主要的IO模型</h3><blockquote>\n<p><strong>阻塞与非阻塞</strong>：阻塞IO，指的是需要内核IO操作彻底完成后，才返回到用户空间执行用户的操作。阻塞指的是用户空间程序的执行状态。</p>\n<p><strong>同步与异步</strong>：同步IO是指用户空间的线程是主动发起IO请求的一方，内核空间是被动接受方。异步IO则反过来，是指系统内核是主动发起IO请求的一方（通知或回调），用户空间的线程是被动接受方。</p>\n</blockquote>\n<h4 id=\"1-同步阻塞IO（Blocking-IO）\"><a href=\"#1-同步阻塞IO（Blocking-IO）\" class=\"headerlink\" title=\"1. 同步阻塞IO（Blocking IO）\"></a>1. 同步阻塞IO（Blocking IO）</h4><p>​        在Java中，默认创建的socket都是同步阻塞的。在阻塞式IO模型中，Java应用程序<strong>从IO系统调用开始，直到系统调用返回</strong>，在这段时间内，Java进程是<strong>阻塞</strong>的。返回成功后，应用进程开始处理用户空间的缓存区数据。</p>\n<p><strong>同步阻塞IO流程</strong>，如图：</p>\n<p><img src=\"https://tvax1.sinaimg.cn/large/006YzKDNly1gov1uvelijj30i30bbgph.jpg\" alt=\"image\"></p>\n<ul>\n<li><p>阻塞IO特点：在内核进行IO执行的两个阶段（等待数据和复制数据），用户线程都被阻塞了。</p>\n</li>\n<li><p>阻塞IO优点：应用的程序开发非常简单；在阻塞等待数据期间，用户线程挂起，基本不会占用CPU资源。</p>\n</li>\n<li><p>阻塞IO缺点：一般情况下，会为每个连接配备一个独立的线程；反过来说，就是一个线程维护一个连接的IO操作。在并发量小的情况下，这样做没有什么问题。但是，当在高并发的应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。因此，基本上阻塞IO模型在高并发应用场景下是不可用的。</p>\n</li>\n</ul>\n<h4 id=\"2-同步非阻塞IO（Non-blocking-IO）\"><a href=\"#2-同步非阻塞IO（Non-blocking-IO）\" class=\"headerlink\" title=\"2. 同步非阻塞IO（Non-blocking IO）\"></a>2. 同步非阻塞IO（Non-blocking IO）</h4><blockquote>\n<p>这里的NIO并非Java的NIO（New IO），Java的NIO，对应的不是四种基础IO模型中的NIO（None Blocking IO）模型，而是另外的一种模型，叫作IO多路复用模型（IO Multiplexing）。</p>\n</blockquote>\n<p>​        在NIO模型中，应用程序一旦开始IO系统调用，会出现以下两种情况：</p>\n<p>​        1. 在内核缓冲区中<strong>没有数据</strong>的情况下，系统调用会立即返回，返回一个调用失败的信息。</p>\n<p>​        2. 在内核缓冲区中<strong>有数据</strong>的情况下，是<strong>阻塞</strong>的，直到数据从内核缓冲复制到用户进程缓冲。复制完成后，系统调用返回成功，应用进程开始处理用户空间的缓存数据。</p>\n<p><strong>同步非阻塞IO流程</strong>，如图<em>(图源公众号“码农翻身”，侵删)</em>：</p>\n<p><img src=\"https://tva4.sinaimg.cn/large/006YzKDNgy1goxfc4wvqoj30ll0fmgmt.jpg\" alt=\"image\"></p>\n<ul>\n<li><p>同步非阻塞IO<strong>特点</strong>：应用程序的线程需要不断地进行IO系统调用，轮询数据是否已经准备好，如果没有准备好，就继续<strong>轮询</strong>，直到完成IO系统调用为止。一般不单独使用，在其他模型中应用。</p>\n</li>\n<li><p>同步非阻塞IO<strong>优点</strong>：每次发起的IO系统调用，在内核等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。</p>\n</li>\n<li><p>同步非阻塞IO<strong>缺点</strong>：不断地轮询内核，这将占用大量的CPU时间，效率低下。</p>\n</li>\n</ul>\n<h4 id=\"3-IO多路复用（IO-Multiplexing）\"><a href=\"#3-IO多路复用（IO-Multiplexing）\" class=\"headerlink\" title=\"3. IO多路复用（IO Multiplexing）\"></a>3. IO多路复用（IO Multiplexing）</h4><blockquote>\n<p>解决同步非阻塞IO模型中轮询等待的问题</p>\n</blockquote>\n<p>​        在IO多路复用模型中，引入了一种新的系统调用，查询IO的就绪状态。在Linux系统中，对应的系统调用为select/epoll系统调用。通过该系统调用，单个应用程序的线程，可以不断地轮询成百上千的socket连接，一旦某个socket就绪（一般是内核缓冲区可读/可写），内核能够将就绪的状态返回给应用程序。随后，应用程序根据就绪的状态，进行相应的IO系统调用。</p>\n<p><strong>IO多路复用模型流程</strong>，如图：</p>\n<p><img src=\"https://tvax3.sinaimg.cn/large/006YzKDNly1gov3zz1xp6j30h80bhdkc.jpg\" alt=\"image\"></p>\n<ul>\n<li>IO多路复用模型<strong>特点</strong>：涉及两种系统调用（SystemCall），一种是select/epoll（就绪查询），一种是IO操作。要使用IO多路复用模型，操作系统必须支持提供多路分离的系统调用select/epoll。负责select/epoll状态查询调用的线程，需要不断地进行select/epoll轮询，查找出达到IO操作就绪的socket连接。对于注册在选择器（Java中对应的选择器类是Selector类）上的<strong>每一个可以查询的socket连接</strong>，一般都设置成为<strong>同步非阻塞模型</strong>。</li>\n<li>IO多路复用模型<strong>优点</strong>：一个选择器查询线程可以同时处理成千上万个连接（Connection）。系统不必创建和维护大量线程，减小系统开销。<em>Java的NIO（New IO）技术和Netty框架，使用的就是IO多路复用模型。在Linux系统上，使用的是epoll系统调用。</em></li>\n<li>IO多路复用模型<strong>缺点</strong>：本质上，select/epoll系统调用是阻塞式的，属于同步IO。都需要在读写事件就绪后，由系统调用本身负责进行读写，也就是说这个读写过程是阻塞的。</li>\n</ul>\n<h5 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select:\"></a>select:</h5><p>​        select可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理<em>(图源公众号“码农翻身”，侵删)</em>：</p>\n<p><img src=\"https://tva2.sinaimg.cn/large/006YzKDNgy1goxgnhkba8g30fa0b4x6p.gif\" alt=\"20210326180007\"></p>\n<ol>\n<li>首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。</li>\n<li>然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。</li>\n<li>不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。</li>\n</ol>\n<p>可以看出几个问题：</p>\n<p>​    1. select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>\n<p>​    2. select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>\n<p>​    3. select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>\n<h5 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll:\"></a>epoll:</h5><p>​        解决了 select 的上述问题:</p>\n<ol>\n<li><p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</p>\n</li>\n<li><p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p>\n</li>\n<li><p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p>\n<p>原理如图<em>(图源公众号“码农翻身”，侵删)</em>：</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNgy1goxh0qffnzg30fa0b4e81.gif\" alt=\"20210326181258\"></p>\n<p><strong>多路复用快的原因</strong>：操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。</p>\n</li>\n</ol>\n<h4 id=\"4-异步IO（Asynchronous-IO）\"><a href=\"#4-异步IO（Asynchronous-IO）\" class=\"headerlink\" title=\"4. 异步IO（Asynchronous IO）\"></a>4. 异步IO（Asynchronous IO）</h4><blockquote>\n<p>彻底解除线程的阻塞</p>\n</blockquote>\n<p>​        对于异步IO，当用户线程发起read系统调用后，立刻就可以做其他的事，不阻塞。内核开始准备数据，并复制数据到用户缓冲区。复制完成后，内核会给用户线程发送一个信号（Signal），或者回调用户线程注册的回调接口，告诉用户线程read操作完成了。</p>\n<p><strong>异步IO模型流程</strong>，如图：</p>\n<p><img src=\"https://tvax3.sinaimg.cn/large/006YzKDNly1gov4h3y1m6j30go0c2q7m.jpg\" alt=\"image\"></p>\n<ul>\n<li>异步IO模型<strong>特点</strong>：在内核等待数据和复制数据的<strong>两个阶段，用户线程都不阻塞</strong>。用户线程需要接收内核的IO操作完成的事件，或者用户线程需要注册一个IO操作完成的回调函数。正因为如此，异步IO有的时候也被称为信号驱动IO。</li>\n<li>异步IO模型缺点：应用程序仅需要进行事件的注册与接收，其余的工作都留给了操作系统，也就是说，需要底层内核提供支持。</li>\n</ul>\n<blockquote>\n<p>​        就目前而言，Windows系统下通过IOCP实现了真正的异步IO。而在Linux系统下，异步IO模型在2.6版本才引入，目前并不完善，其底层实现仍使用epoll，与IO多路复用相同，因此在性能上没有明显的优势。大多数高并发服务器端程序，都是基于Linux系统的。因而，<strong>目前这类高并发网络应用程序的开发，大多采用IO多路复用模型。</strong></p>\n</blockquote>\n<h3 id=\"三、系统配置最大句柄\"><a href=\"#三、系统配置最大句柄\" class=\"headerlink\" title=\"三、系统配置最大句柄\"></a>三、系统配置最大句柄</h3><blockquote>\n<p>在生产环境Linux系统中，基本上都需要解除文件句柄数的限制。因为Linux的系统默认值为1024，也就是说，一个进程最多可以接受1024个socket连接。</p>\n</blockquote>\n<h4 id=\"文件句柄\"><a href=\"#文件句柄\" class=\"headerlink\" title=\"文件句柄\"></a>文件句柄</h4><p>​        也叫文件描述符，在Linux系统中，文件可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（File Descriptor）是内核为了高效管理已被打开的文件所创建的索引，它是一个非负整数（通常是小整数），用于指代被打开的文件。所有的IO系统调用，包括socket的读写调用，都是通过文件描述符完成的。在Linux下，可以通过<code>ulimit -n</code>看到单个进程能够打开的最大文件句柄数量。Linux的系统默认值为1024。</p>\n<p>​        对于高并发的应用，面临的并发连接数往往是十万级、百万级、千万级、甚至像腾讯QQ一样的上亿级。当单个进程打开的文件句柄数量，超过了系统配置上限值时，会发出“Socket/File:Can’t open so many files”的错误提示。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>​        可以通过<code>ulimit -n 1000000</code>修改句柄数（最大值是1048576 ），但是ulimit命令仅对当前用户有效，如果想永久保存配置，可以编辑/etc/rc.local开机启动文件，添加如下内容：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ulimit -SHn <span class=\"number\">1000000</span></span><br></pre></td></tr></table></figure>\n\n<p>​        增加-S和-H两个命令选项。选项-S表示软性极限值，-H表示硬性极限值。硬性极限（需要root权限）是实际的限制，就是最大可以是100万，不能再多了。软性极限是系统警告（Warning）的极限值，超过这个极限值，内核会发出警告。</p>\n<p>​        终极解除Linux系统的最大文件打开数量的限制，可以编辑/etc/security/limits.conf，添加如下内容：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">soft nofile <span class=\"number\">1000000</span></span><br><span class=\"line\">hard nofile <span class=\"number\">1000000</span></span><br></pre></td></tr></table></figure>\n\n<p>soft nofile表示软性极限，hard nofile表示硬性极限。不可以设置unlimited。</p>\n"},{"title":"Java NIO通信基础","header-img":"/img/header_img/squirrel.jpg","catalog":true,"top":null,"abbrlink":"57bd","date":"2021-03-31T10:45:33.000Z","subtitle":null,"_content":"\n## Java NIO通信基础\n\n### 一、NIO简介\n\n> 在1.4版本之前，Java IO类库是阻塞IO；从1.4版本开始，为了支持非阻塞IO，引进了新的异步IO库，被称为Java New IO类库，简称为JAVA NIO。Java NIO属于 IO多路复用模型。\n\n**NIO和OIO（old IO）的区别：**\n\n- OIO面向流（Stream Oriented），NIO面向缓冲区（BufferOriented）\n- OIO的操作是阻塞的，NIO是非阻塞的。\n- OIO没有选择器（Selector）概念，NIO的选择器，需要底层操作系统提供支持。\n\nJava NIO由以下三个核心组件组成：· Channel（通道）· Buffer（缓冲区）· Selector（选择器）\n\n#### 1. 通道（Channel）\n\n​\t\t在OIO中，同一个网络连接会通过输入流（Input Stream）和输出流（Output Stream）不断地进行输入和输出的操作。在NIO中，同一个网络连接使用一个通道表示，所有的NIO的IO操作都是从通道开始的。一个通道类似于OIO中的两个流的结合体，既可以从通道读取，也可以向通道写入。\n\n#### 2. 选择器（Selector）\n\n> IO多路复用指的是一个进程/线程可以同时监视多个文件描述符（一个网络连接，操作系统底层使用一个文件描述符来表示），一旦其中的一个或者多个文件描述符可读或者可写，系统内核就通知该进程/线程。\n\n​\t\t通过选择器，一个线程可以查询多个通道的IO事件的就绪状态，即监视多个文件描述符。具体的开发层面来说，首先把通道注册到选择器中，然后通过选择器内部的机制，可以查询（select）这些注册的通道是否有已经就绪的IO事件（例如可读、可写、网络连接完成等）。一个选择器只需要一个线程进行监控，系统不必为每一个网络连接（文件描述符）创建进程/线程，从而大大减小了系统的开销。\n\n#### 3. 缓冲区（Buffer）\n\n​\t\t应用程序与通道（Channel）主要的交互操作，就是进行数据的read读取和write写入。通道的读取，就是将数据从通道读取到缓冲区中；通道的写入，就是将数据从缓冲区中写入到通道中。\n\n### 二、Buffer类及其属性\n\n> Buffer（缓冲区）本质上是一个内存块（数组），既可以写入数据，也可以从中读取数据。\n\n#### Buffer类\n\n​\t\tBuffer类是一个抽象类，位于java.nio包中，线程不安全。在NIO中有8种缓冲区类：ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer、MappedByteBuffer，其中MappedByteBuffer是专门用于内存映射的一种ByteBuffer类型。使用最多的是ByteBuffer。\n\n#### Buffer类的重要属性\n\n​\t\t为了记录读写的状态和位置，Buffer类提供了一些重要的属性：capacity（容量）、position（读写位置）、limit（读写的限制）、mark（标记）。\n\n![image](https://tvax2.sinaimg.cn/large/006YzKDNly1gp33iz38e4j30kk05pt9v.jpg)\n\n#### Buffer类的重要方法\n\n1. **allocate()创建缓冲区**\n\n    ​\t\t为了获取一个Buffer实例对象，并不是使用子类的构造器new来创建一个实例对象，而是调用子类的allocate()方法，并分配内存空间（capacity）。\n\n    ```java\n    IntBuffer intBuffer = intBuffer.allocate(10);\n    ```\n\n2. **put()写入到缓冲区**\n\n    ```java\n    intBuffer.put(1);\n    ```\n\n3. **flip()翻转**\n\n    ​\t\t向缓冲区写入数据之后，不能直接从缓冲区中读取数据，需要使用flip()将写入模式翻转成读取模式。flip()方法源码如下：\n\n    ```java\n     public final Buffer flip() {\n         limit = position;\n         position = 0;\n         mark = -1;\n         return this;\n     }\n    ```\n\n    容量为10的intBuffer，在写入1个数据时，position=1，limit=10，capacity=10；在写完翻转后，position=0，limit=1，capacity=10；\n\n    > 读取完成后，如何再一次将缓冲区切换成写入模式呢？可以调用Buffer.clear()清空或者Buffer.compact()压缩方法，它们可以将缓冲区转换为写模式。\n\n    缓冲区读写模式的转换如图：\n\n    ![image](https://tvax1.sinaimg.cn/large/006YzKDNly1gp34tey3npj30g1071aay.jpg)\n\n4. **clear()清空**\n\n    ​\t\t清空缓冲区但不清除数据，数据将“被遗忘”，缓冲区切换为写入模式。源码如下：\n\n    ```java\n    public final Buffer clear() {\n        position = 0;\n        limit = capacity;\n        mark = -1;\n    \treturn this;\n    }\n    ```\n\n5. **compact()压缩**\n\n    ​\t\t不覆盖未读的数据，将所有未读的数据拷贝到Buffer起始处，然后将position设到最后一个未读元素后面，limit设置为capacity，缓冲区切换为写入模式。源码如下：\n\n    ```java\n    public ByteBuffer compact() {\n        System.arraycopy(hb, ix(position()), hb, ix(0), remaining()); // 拷贝未读数据\n        position(remaining()); // remaining()返回limit - position\n        limit(capacity()); // limit设置为capacity\n        discardMark(); // mark = -1\n        return this;\n    }\n    ```\n\n6. **get()从缓冲区读取**\n\n    ​\t\t翻转后可读，读操作会改变可读位置position的值，而limit值不会改变。如果position==limit，表示所有数据读取完成，position指向了一个没有数据的元素位置，此时再读，会抛出BufferUnderflowException异常。\n\n    ```java\n    byteBuffer.get();\n    ```\n\n7. **rewind()倒带**\n\n    ​\t\t已读完的数据，如果需要再读一遍，可以调用rewind()方法。rewind()也叫倒带。源码如下：\n\n    ```java\n    public final Buffer rewind() {\n        position = 0; // 重置\n        mark = -1; // 清理标记\n        return this;\n    }\n    ```\n\n    > rewind()和flip()区别在于：rewind()不会影响limit；而flip()会重设limit属性值。\n\n8.  **mark( )和reset( )**\n\n    ​\t\tBuffer.mark()和Buffer.reset()方法是配套使用的，比如读到第3个元素（i= =2时），调用mark()方法，把当前位置position的值保存到mark属性中，这时mark属性的值为2。接下来，就可以调用reset方法，将mark属性的值恢复到position中。然后可以从位置2（第三个元素）开始读。\n\n**Buffer类的基本使用步骤**：\n\n```java\nIntBuffer intBuffer = intBuffer.allocate(10);\nintBuffer.put(1);\nintBuffer.flip();\nintBuffer.get();\nintBuffer.clear();||intBuffer.compact();\n```\n\n### 二、Channel类及其属性\n\n> NIO中一个连接用一个Channel（通道）来表示，一个通道可以表示一个底层的文件描述符，例如硬件设备、文件、网络连接等。对于不同的网络传输协议类型，在Java中都有不同的NIO Channel（通道）实现。\n\n#### Channel（通道）的主要类型\n\n1. FileChannel文件通道，用于文件的数据读写。\n\n2. SocketChannel套接字通道，用于Socket套接字TCP连接的数据读写。\n\n3. ServerSocketChannel服务器嵌套字通道（或服务器监听通道），允许我们监听TCP连接请求，为每个监听到的请求，创建一个SocketChannel套接字通道。\n\n4. DatagramChannel数据报通道，用于UDP协议的数据读写。\n\n#### FileChannel的使用\n\n> 通过FileChannel，既可以从一个文件中读取数据，也可以将数据写入到文件中。FileChannel为**阻塞模式**，不能设置为非阻塞模式。\n\n1. **获取FileChannel通道**\n\n- 通过文件输入输出流获取：\n\n    ```java\n    // 创建文件输入流\n    FileInputStream fis = new FileInputStream(srcFile);\n    // 获取文件流的通道\n    FileChannel inChannel = fis.getChannel();\n    \n    // 创建文件输出流\n    FileOutputStream fos = new FileOutputStream(destFile);\n    // 获取文件流的通道\n    FileChannel outChannel = fis.getChannel();\n    ```\n\n- 通过RandomAccessFile类获取：\n\n    ```java\n    // 创建RandomAccessFile随机访问对象\n    RandomAccessFile rafile = new RandomAccessFile(srcFile, \"rw\");\n    // 获取文件流的通道\n    FileChannel raFileChannel = rafile.getChannel();\n    ```\n\n2. **读取FileChannel通道**\n\n    ​\t\t调用`public abstract int read(ByteBuffer src) throws IOException`方法读取通道数据，写入ByteBuffer缓冲区，并返回数据。**虽然对于通道来说是读取数据，但是对于ByteBuffer缓冲区来说是写入数据，这时，ByteBuffer缓冲区处于写入模式。**\n\n    ```java\n    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n    int length = -1;\n    while (-1 != (length = raFileChannel.read(byteBuffer))) {\n    // TODO\n    }\n    ```\n\n3. **写入FileChannel通道**\n\n    ​\t\t调用`public abstract int write(ByteBuffer src) throws IOException`方法读取缓冲区数据写入通道，并返回写入的字节数。**对于ByteBuffer缓冲区来说是读入数据，对通道来说是写入。**\n\n    ```java\n    // 刚写完要翻转成读取模式\n    byteBuffer.flip();\n    int outlength = 0;\n    while (0 != (outlength = raFileChannel.write(byteBuffer))) {\n    \tSystem.out.println(\"写入字节数：\" + outlength);\n    }\n    ```\n\n4. **关闭通道**\n\n    ```java\n    inChannel.close();\n    ```\n\n5. **强制刷新到磁盘**\n\n    ​\t\t在将缓冲区写入通道时，出于性能原因，操作系统不可能每次都实时将数据写入磁盘。如果需要保证写入通道的缓冲数据，最终都真正地写入磁盘，可以调用FileChannel的force()方法。\n\n    ```java\n    inChannel.force(true);\n    ```\n\n#### SocketChannel和ServerSocketChannel的使用\n\n> 在NIO中，涉及网络连接的通道有两个，一个是SocketChannel负责连接传输，另一个是ServerSocketChannel负责连接的监听。都**支持阻塞和非阻塞两种模式**。ServerSocketChannel应用于服务器端，而SocketChannel同时处于服务器端和客户端。对于一个连接，两端都有一个负责传输的SocketChannel传输通道。SocketChannel与OIO中的Socket类对应，ServerSocketChannel与OIO中的ServerSocket类对应。\n\n1. **获取SocketChannel传输通道**\n\n    ​\t\t在**客户端**，先通过SocketChannel静态方法open()获得一个套接字传输通道；然后，将socket套接字设置为非阻塞模式；最后，通过connect()实例方法，对服务器的IP和端口发起连接。\n\n    ```java\n    // 获取通道\n    SocketChannel socketChannel = SocketChannel.open();\n    // 设置为非阻塞\n    socketChannel.configureBlocking(false);\n    // 对服务器的IP和端口发起连接\n    socketChannel.connect(new InetSocketAddress(InetAddress.getLocalHost(),5252));\n    ```\n\n    ​\t\t非阻塞情况下，与服务器的连接可能还没有真正建立，socketChannel.connect方法就返回了，因此需要不断地自旋，检查当前是否连接到了主机：\n\n    ```java\n    // 不断自旋，等待连接完成\n    while (!socketChannel.finishConnect()) {\n    }\n    ```\n\n    ​\t\t在**服务器端**，当新连接事件到来时，ServerSocketChannel能成功地查询，通过accept()方法，来获取新连接的套接字通道：\n\n    ```java\n    // 新连接事件到来,通过事件（后面会讲到key）获取服务器监听通道\n    ServerSocketChannel serverSocketChannel = （ServerSocketChannel）key.channel();\n    // 获取新连接的套接字通道\n    SocketChannel socketChannel = serverSocketChannel.accept();\n    // 切换为非阻塞模式\n    socketChannel.configureBlocking(false);\n    ```\n\n2. **读取SocketChannel传输通道**\n\n    ​\t\t与FileChannel一样\n\n3. **写入SocketChannel传输通道**\n\n    ​\t\t与FileChannel一样\n\n4. **关闭SocketChannel传输通道**\n\n    ​\t\t在关闭SocketChannel传输通道前，如果传输通道用来写入数据，则建议调用一次shutdownOutput()终止输出方法，向对方发送一个输出的结束标志（-1）。然后调用socketChannel.close()方法，关闭套接字连接。\n\n    ```\n    // 终止输出方法，向对方发送一个输出的结束标志\n    socketChannel.shutdownOutput();\n    // 关闭套接字连接\n    socketChannel.close();\n    ```\n\n#### DatagramChannel的使用\n\n> DatagramChannel数据报通道用来处理UDP协议的数据传输。和Socket套接字的TCP传输协议不同，UDP协议不是面向连接的协议。使用UDP协议时，只要知道服务器的IP和端口，就可以直接向对方发送数据。\n\n1. **获取DatagramChannel传输通道**\n\n    ​\t\t调用DatagramChannel静态方法open()获得通道，然后设置为非阻塞模式，绑定数据报的监听端口：\n\n    ```java\n    // 获取通道\n    DatagramChannel datagramChannel = DatagramChannel.open();\n    // 设置为非阻塞\n    datagramChannel.configureBlocking(false);\t\t\n    // 绑定监听IP和端口\n    datagramChannel.socket().bind(new InetSocketAddress(InetAddress.getLocalHost(),5252));\n    ```\n\n2. **读取DatagramChannel传输通道**\n\n    ​\t\t不是调用read方法，而是调用receive：\n\n    ```java\n    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n    SocketAddress clientAddr = datagramChannel.receive(byteBuffer);\n    ```\n\n    ​\t\t通道读取receive（ByteBuffer buf）方法的返回值，是SocketAddress类型，表示返回发送端的连接地址（包括IP和端口）。\n\n3. **写入DatagramChannel传输通道**\n\n    ​\t\t不是调用write方法，而是调用send方法，由于UDP是面向非连接的协议，因此，在发送数据的时候，需要指定接收方的地址：\n\n    ```java\n    byteBuffer.flip();\n    datagramChannel.send(byteBuffer, new InetSocketAddress(InetAddress.getLocalHost(),5252));\n    byteBuffer.clear();\n    ```\n\n4. **关闭DatagramChannel传输通道**\n\n    ​\t\t与FileChannel一样，close()即可。\n\n### 三、Select类及其属性\n\n> 非阻塞模式下，如何知道SocketChannel和DatagramChannel通道何时是可读的呢？这时就需要用到NIO的新组件——Selector通道选择器\n>\n> 简单地说：**选择器的使命是完成IO的多路复用**。一个通道代表一条连接，通过选择器可以同时监控多个通道的IO（输入输出）状况。选择器和通道的关系，是监控和被监控的关系。\n\n#### Selector 选择器及注册\n\n​\t\t通道和选择器之间的关系，通过`Channel.register（Selector sel, int ops）`方法完成，需要传入待注册的选择器实例和待监控事件类型。\n\n可供选择器监控的**通道IO事件类型**（就绪状态），包括以下四种：\n\n1. 可读：SelectionKey.OP_READ\n2. 可写：SelectionKey.OP_WRITE\n3. 连接：SelectionKey.OP_CONNECT\n4. 接收：SelectionKey.OP_ACCEPT\n\n事件类型的定义在SelectionKey类中。如果选择器要监控通道的多种事件，可以用“按位或”运算符来实现。例如，同时监控可读和可写IO事件：\n\n```java\nint key = SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n```\n\n#### SelectableChannel(可选择通道)\n\n​\t\t一条通道若能被选择，必须继承SelectableChannel类。所有网络链接Socket套接字通道，都继承了SelectableChannel类，都是可选择的。而FileChannel文件通道，并没有继承SelectableChannel，因此不是可选择通道。\n\n#### SelectionKey(选择键)\n\n​\t\t一旦在通道中发生了某些IO事件（就绪状态达成），并且在选择器中注册过，就会被选择器选中，并放入SelectionKey的集合中。SelectionKey可以获得通道的IO事件类型，比方说SelectionKey.OP_READ，还可以获得发生IO事件所在的通道及选择器实例。\n\n#### 选择器的使用\n\n1. **获取选择器实例**\n\n    ​\t\t通过调用静态工厂方法open()来获取：\n\n    ```java\n    Selector selector = Selector.open();\n    ```\n\n    *open()的内部，是向选择器SPI（SelectorProvider）发出请求，通过默认的SPI对象，获取一个新的选择器实例。SPI全称为（Service Provider Interface，服务提供者接口），是JDK的一种可以扩展的服务提供和发现机制。Java通过SPI的方式，提供选择器的默认实现版本。也就是说，其他的服务提供商可以通过SPI的方式，提供定制化版本的选择器的动态替换或者扩展。*\n\n2. **将通道注册到选择器中**\n\n    ​\t\t需要注意：注册到选择器的通道，必须处于非阻塞模式下，否则将抛出IllegalBlockingModeException异常。并且一个通道，并不一定支持所有的四种IO事件。例如服务器监听通道ServerSocketChannel，仅支持Accept（接收到新连接）IO事件；而SocketChannel传输通道，则不支持Accept（接收到新连接）IO事件。可以在注册之前，通过通道的validOps()方法，来获取该通道所有支持的IO事件集合。\n\n    ```java\n    // 获取通道\n    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n    // 设置为非阻塞\n    serverSocketChannel.configureBlocking(false);\n    // 绑定连接\n    serverSocketChannel.bind(new InetSocketAddress(5252));\n    System.out.println(\"服务器启动成功\");\n    // 将通道注册的“接收新连接”IO事件注册到选择器上\n    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n    ```\n\n3. **选出感兴趣的IO就绪事件（选择键集合）**\n\n    ```java\n    // 轮询感兴趣的IO就绪事件（选择键集合）\n    while (selector.select() > 0) {\n        // 获取选择键集合\n        Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();\n        while (selectedKeys.hasNext()) {\n            // 获取单个的选择键并处理\n            SelectionKey selectedKey = selectedKeys.next();\n            if (selectedKey.isAcceptable()) {\n         \t\t// 通道有新连接\n            } else if (selectedKey.isConnectalbe()) {\n                // 通道连接成功\n            }  else if (selectedKey.isReadalbe()) {\n                // 通道可读\n            }  else if (selectedKey.isWritalbe()) {\n                // 通道可写\n            }\n            // 处理完后移除选择键\n            selectedKeys.remove();\n        }\n    }\n    ```\n\n    SelectionKey集合不能添加元素，如果试图向SelectionKey选择键集合中添加元素，则将抛出java.lang.UnsupportedOperationException异常。\n\n    select()方法有三个重载的实现版本，具体如下：\n\n    1. select()：阻塞调用，一直到至少有一个通道发生了注册的IO事件。\n    2. select(long timeout)：和select()一样，但最长阻塞时间为timeout指定的毫秒数。\n    3. selectNow()：非阻塞，不管有没有IO事件，都会立刻返回。\n\n    select()方法返回的整数值，表示从上一次select到这一次select之间，有多少**通道**发生了注册的IO事件。强调一下，select()方法返回的数量，指的是通道数，而不是IO事件数。\n\n#### 实践案例\n\n使用NIO实现Discard服务器，Discard服务器的功能很简单，读取客户端通道的输入数据，读取完成后直接关闭客户端通道；并且读取到的数据直接抛弃掉。\n\n**服务器端：**\n\n```java\n/**\n * 使用NIO实现Discard服务器端功能：\n *      仅读取客户端通道的输入数据，读取完成后直接关闭客户端通道，并且读取到的数据直接抛弃掉。\n */\npublic class NioDiscardServer {\n    public static void startServer() throws IOException {\n\n        // 获取选择器\n        Selector selector = Selector.open();\n        // 获取通道\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        // 设置为非阻塞\n        serverSocketChannel.configureBlocking(false);\n        // 绑定连接\n        serverSocketChannel.bind(new InetSocketAddress(5252));\n        System.out.println(\"服务器启动成功\");\n        // 将通道注册的“接收新连接”IO事件注册到选择器上\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        // 轮询感兴趣的IO就绪事件（选择键集合）\n        while (selector.select() > 0) {\n            // 获取选择键集合\n            Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();\n            while (selectedKeys.hasNext()) {\n                // 获取单个的选择键并处理\n                SelectionKey selectedKey = selectedKeys.next();\n                if (selectedKey.isAcceptable()) {\n                    // 若选择键的IO事件是“连接就绪”，就获取客户端连接\n                    SocketChannel socketChannel = serverSocketChannel.accept();\n                    // 切换为非阻塞模式\n                    socketChannel.configureBlocking(false);\n                    // 将新连接的通道可读事件注册到选择器上\n                    socketChannel.register(selector, SelectionKey.OP_READ);\n                } else if (selectedKey.isReadable()) {\n                    // 若选择键的IO事件是“可读”，就读取数据\n                    SocketChannel socketChannel = (SocketChannel) selectedKey.channel();\n                    // 读取数据，然后丢弃\n                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                    int length = 0;\n                    // 调用通道的read方法，从通道读取数据写入缓冲区，并返回读取到的数据\n                    while ((length = socketChannel.read(byteBuffer)) > 0) {\n                        byteBuffer.flip();\n                        System.out.println(new String(byteBuffer.array(), 0, length));\n                        byteBuffer.clear();\n                    }\n                    socketChannel.close();\n                }\n                // 移除选择键\n                selectedKeys.remove();\n            }\n        }\n        // 关闭连接\n        serverSocketChannel.close();\n    }\n}\n```\n\n**客户端：**\n\n```java\n/**\n * 使用NIO实现Discard客户端功能：\n *      客户端首先建立到服务器的连接，发送一些简单的数据，然后直接关闭连接。\n */\npublic class NioDiscardClient {\n\n    public static void startClient() throws IOException {\n        InetSocketAddress address = new InetSocketAddress(InetAddress.getLocalHost(),5252);\n        // 获取通道\n        SocketChannel socketChannel = SocketChannel.open(address);\n        // 设置为非阻塞\n        socketChannel.configureBlocking(false);\n        // 不断自旋，等待连接完成\n        while (!socketChannel.finishConnect()) {\n        }\n        System.out.println(\"客户端连接成功\");\n        // 分配指定大小的缓冲区\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        byteBuffer.put(\"hello nio\".getBytes());\n        byteBuffer.flip();\n        // 发送到服务器\n        socketChannel.write(byteBuffer);\n        // 终止输出方法，向对方发送一个输出的结束标志\n        socketChannel.shutdownOutput();\n        // 关闭套接字连接\n        socketChannel.close();\n    }\n}\n```\n\n**测试：**\n\n​\t\t先启动服务器，等到控制台出现“服务器启动成功”，再启动客户端，客户端连接成功后，发现服务器端出现“hello nio”则成功：\n\n服务器端：\n\n```\n服务器启动成功\n```\n\n客户端：\n\n```\n客户端连接成功\n```\n\n服务器端：\n\n```\n服务器启动成功\nhello nio\n```\n\n\n\n","source":"_posts/java-nio.md","raw":"---\ntitle: Java NIO通信基础\nheader-img: /img/header_img/squirrel.jpg\ncatalog: true\ntop:\ntags:\n  - IO\ncategories:\n  - work\nabbrlink: 57bd\ndate: 2021-03-31 18:45:33\nsubtitle:\n---\n\n## Java NIO通信基础\n\n### 一、NIO简介\n\n> 在1.4版本之前，Java IO类库是阻塞IO；从1.4版本开始，为了支持非阻塞IO，引进了新的异步IO库，被称为Java New IO类库，简称为JAVA NIO。Java NIO属于 IO多路复用模型。\n\n**NIO和OIO（old IO）的区别：**\n\n- OIO面向流（Stream Oriented），NIO面向缓冲区（BufferOriented）\n- OIO的操作是阻塞的，NIO是非阻塞的。\n- OIO没有选择器（Selector）概念，NIO的选择器，需要底层操作系统提供支持。\n\nJava NIO由以下三个核心组件组成：· Channel（通道）· Buffer（缓冲区）· Selector（选择器）\n\n#### 1. 通道（Channel）\n\n​\t\t在OIO中，同一个网络连接会通过输入流（Input Stream）和输出流（Output Stream）不断地进行输入和输出的操作。在NIO中，同一个网络连接使用一个通道表示，所有的NIO的IO操作都是从通道开始的。一个通道类似于OIO中的两个流的结合体，既可以从通道读取，也可以向通道写入。\n\n#### 2. 选择器（Selector）\n\n> IO多路复用指的是一个进程/线程可以同时监视多个文件描述符（一个网络连接，操作系统底层使用一个文件描述符来表示），一旦其中的一个或者多个文件描述符可读或者可写，系统内核就通知该进程/线程。\n\n​\t\t通过选择器，一个线程可以查询多个通道的IO事件的就绪状态，即监视多个文件描述符。具体的开发层面来说，首先把通道注册到选择器中，然后通过选择器内部的机制，可以查询（select）这些注册的通道是否有已经就绪的IO事件（例如可读、可写、网络连接完成等）。一个选择器只需要一个线程进行监控，系统不必为每一个网络连接（文件描述符）创建进程/线程，从而大大减小了系统的开销。\n\n#### 3. 缓冲区（Buffer）\n\n​\t\t应用程序与通道（Channel）主要的交互操作，就是进行数据的read读取和write写入。通道的读取，就是将数据从通道读取到缓冲区中；通道的写入，就是将数据从缓冲区中写入到通道中。\n\n### 二、Buffer类及其属性\n\n> Buffer（缓冲区）本质上是一个内存块（数组），既可以写入数据，也可以从中读取数据。\n\n#### Buffer类\n\n​\t\tBuffer类是一个抽象类，位于java.nio包中，线程不安全。在NIO中有8种缓冲区类：ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer、MappedByteBuffer，其中MappedByteBuffer是专门用于内存映射的一种ByteBuffer类型。使用最多的是ByteBuffer。\n\n#### Buffer类的重要属性\n\n​\t\t为了记录读写的状态和位置，Buffer类提供了一些重要的属性：capacity（容量）、position（读写位置）、limit（读写的限制）、mark（标记）。\n\n![image](https://tvax2.sinaimg.cn/large/006YzKDNly1gp33iz38e4j30kk05pt9v.jpg)\n\n#### Buffer类的重要方法\n\n1. **allocate()创建缓冲区**\n\n    ​\t\t为了获取一个Buffer实例对象，并不是使用子类的构造器new来创建一个实例对象，而是调用子类的allocate()方法，并分配内存空间（capacity）。\n\n    ```java\n    IntBuffer intBuffer = intBuffer.allocate(10);\n    ```\n\n2. **put()写入到缓冲区**\n\n    ```java\n    intBuffer.put(1);\n    ```\n\n3. **flip()翻转**\n\n    ​\t\t向缓冲区写入数据之后，不能直接从缓冲区中读取数据，需要使用flip()将写入模式翻转成读取模式。flip()方法源码如下：\n\n    ```java\n     public final Buffer flip() {\n         limit = position;\n         position = 0;\n         mark = -1;\n         return this;\n     }\n    ```\n\n    容量为10的intBuffer，在写入1个数据时，position=1，limit=10，capacity=10；在写完翻转后，position=0，limit=1，capacity=10；\n\n    > 读取完成后，如何再一次将缓冲区切换成写入模式呢？可以调用Buffer.clear()清空或者Buffer.compact()压缩方法，它们可以将缓冲区转换为写模式。\n\n    缓冲区读写模式的转换如图：\n\n    ![image](https://tvax1.sinaimg.cn/large/006YzKDNly1gp34tey3npj30g1071aay.jpg)\n\n4. **clear()清空**\n\n    ​\t\t清空缓冲区但不清除数据，数据将“被遗忘”，缓冲区切换为写入模式。源码如下：\n\n    ```java\n    public final Buffer clear() {\n        position = 0;\n        limit = capacity;\n        mark = -1;\n    \treturn this;\n    }\n    ```\n\n5. **compact()压缩**\n\n    ​\t\t不覆盖未读的数据，将所有未读的数据拷贝到Buffer起始处，然后将position设到最后一个未读元素后面，limit设置为capacity，缓冲区切换为写入模式。源码如下：\n\n    ```java\n    public ByteBuffer compact() {\n        System.arraycopy(hb, ix(position()), hb, ix(0), remaining()); // 拷贝未读数据\n        position(remaining()); // remaining()返回limit - position\n        limit(capacity()); // limit设置为capacity\n        discardMark(); // mark = -1\n        return this;\n    }\n    ```\n\n6. **get()从缓冲区读取**\n\n    ​\t\t翻转后可读，读操作会改变可读位置position的值，而limit值不会改变。如果position==limit，表示所有数据读取完成，position指向了一个没有数据的元素位置，此时再读，会抛出BufferUnderflowException异常。\n\n    ```java\n    byteBuffer.get();\n    ```\n\n7. **rewind()倒带**\n\n    ​\t\t已读完的数据，如果需要再读一遍，可以调用rewind()方法。rewind()也叫倒带。源码如下：\n\n    ```java\n    public final Buffer rewind() {\n        position = 0; // 重置\n        mark = -1; // 清理标记\n        return this;\n    }\n    ```\n\n    > rewind()和flip()区别在于：rewind()不会影响limit；而flip()会重设limit属性值。\n\n8.  **mark( )和reset( )**\n\n    ​\t\tBuffer.mark()和Buffer.reset()方法是配套使用的，比如读到第3个元素（i= =2时），调用mark()方法，把当前位置position的值保存到mark属性中，这时mark属性的值为2。接下来，就可以调用reset方法，将mark属性的值恢复到position中。然后可以从位置2（第三个元素）开始读。\n\n**Buffer类的基本使用步骤**：\n\n```java\nIntBuffer intBuffer = intBuffer.allocate(10);\nintBuffer.put(1);\nintBuffer.flip();\nintBuffer.get();\nintBuffer.clear();||intBuffer.compact();\n```\n\n### 二、Channel类及其属性\n\n> NIO中一个连接用一个Channel（通道）来表示，一个通道可以表示一个底层的文件描述符，例如硬件设备、文件、网络连接等。对于不同的网络传输协议类型，在Java中都有不同的NIO Channel（通道）实现。\n\n#### Channel（通道）的主要类型\n\n1. FileChannel文件通道，用于文件的数据读写。\n\n2. SocketChannel套接字通道，用于Socket套接字TCP连接的数据读写。\n\n3. ServerSocketChannel服务器嵌套字通道（或服务器监听通道），允许我们监听TCP连接请求，为每个监听到的请求，创建一个SocketChannel套接字通道。\n\n4. DatagramChannel数据报通道，用于UDP协议的数据读写。\n\n#### FileChannel的使用\n\n> 通过FileChannel，既可以从一个文件中读取数据，也可以将数据写入到文件中。FileChannel为**阻塞模式**，不能设置为非阻塞模式。\n\n1. **获取FileChannel通道**\n\n- 通过文件输入输出流获取：\n\n    ```java\n    // 创建文件输入流\n    FileInputStream fis = new FileInputStream(srcFile);\n    // 获取文件流的通道\n    FileChannel inChannel = fis.getChannel();\n    \n    // 创建文件输出流\n    FileOutputStream fos = new FileOutputStream(destFile);\n    // 获取文件流的通道\n    FileChannel outChannel = fis.getChannel();\n    ```\n\n- 通过RandomAccessFile类获取：\n\n    ```java\n    // 创建RandomAccessFile随机访问对象\n    RandomAccessFile rafile = new RandomAccessFile(srcFile, \"rw\");\n    // 获取文件流的通道\n    FileChannel raFileChannel = rafile.getChannel();\n    ```\n\n2. **读取FileChannel通道**\n\n    ​\t\t调用`public abstract int read(ByteBuffer src) throws IOException`方法读取通道数据，写入ByteBuffer缓冲区，并返回数据。**虽然对于通道来说是读取数据，但是对于ByteBuffer缓冲区来说是写入数据，这时，ByteBuffer缓冲区处于写入模式。**\n\n    ```java\n    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n    int length = -1;\n    while (-1 != (length = raFileChannel.read(byteBuffer))) {\n    // TODO\n    }\n    ```\n\n3. **写入FileChannel通道**\n\n    ​\t\t调用`public abstract int write(ByteBuffer src) throws IOException`方法读取缓冲区数据写入通道，并返回写入的字节数。**对于ByteBuffer缓冲区来说是读入数据，对通道来说是写入。**\n\n    ```java\n    // 刚写完要翻转成读取模式\n    byteBuffer.flip();\n    int outlength = 0;\n    while (0 != (outlength = raFileChannel.write(byteBuffer))) {\n    \tSystem.out.println(\"写入字节数：\" + outlength);\n    }\n    ```\n\n4. **关闭通道**\n\n    ```java\n    inChannel.close();\n    ```\n\n5. **强制刷新到磁盘**\n\n    ​\t\t在将缓冲区写入通道时，出于性能原因，操作系统不可能每次都实时将数据写入磁盘。如果需要保证写入通道的缓冲数据，最终都真正地写入磁盘，可以调用FileChannel的force()方法。\n\n    ```java\n    inChannel.force(true);\n    ```\n\n#### SocketChannel和ServerSocketChannel的使用\n\n> 在NIO中，涉及网络连接的通道有两个，一个是SocketChannel负责连接传输，另一个是ServerSocketChannel负责连接的监听。都**支持阻塞和非阻塞两种模式**。ServerSocketChannel应用于服务器端，而SocketChannel同时处于服务器端和客户端。对于一个连接，两端都有一个负责传输的SocketChannel传输通道。SocketChannel与OIO中的Socket类对应，ServerSocketChannel与OIO中的ServerSocket类对应。\n\n1. **获取SocketChannel传输通道**\n\n    ​\t\t在**客户端**，先通过SocketChannel静态方法open()获得一个套接字传输通道；然后，将socket套接字设置为非阻塞模式；最后，通过connect()实例方法，对服务器的IP和端口发起连接。\n\n    ```java\n    // 获取通道\n    SocketChannel socketChannel = SocketChannel.open();\n    // 设置为非阻塞\n    socketChannel.configureBlocking(false);\n    // 对服务器的IP和端口发起连接\n    socketChannel.connect(new InetSocketAddress(InetAddress.getLocalHost(),5252));\n    ```\n\n    ​\t\t非阻塞情况下，与服务器的连接可能还没有真正建立，socketChannel.connect方法就返回了，因此需要不断地自旋，检查当前是否连接到了主机：\n\n    ```java\n    // 不断自旋，等待连接完成\n    while (!socketChannel.finishConnect()) {\n    }\n    ```\n\n    ​\t\t在**服务器端**，当新连接事件到来时，ServerSocketChannel能成功地查询，通过accept()方法，来获取新连接的套接字通道：\n\n    ```java\n    // 新连接事件到来,通过事件（后面会讲到key）获取服务器监听通道\n    ServerSocketChannel serverSocketChannel = （ServerSocketChannel）key.channel();\n    // 获取新连接的套接字通道\n    SocketChannel socketChannel = serverSocketChannel.accept();\n    // 切换为非阻塞模式\n    socketChannel.configureBlocking(false);\n    ```\n\n2. **读取SocketChannel传输通道**\n\n    ​\t\t与FileChannel一样\n\n3. **写入SocketChannel传输通道**\n\n    ​\t\t与FileChannel一样\n\n4. **关闭SocketChannel传输通道**\n\n    ​\t\t在关闭SocketChannel传输通道前，如果传输通道用来写入数据，则建议调用一次shutdownOutput()终止输出方法，向对方发送一个输出的结束标志（-1）。然后调用socketChannel.close()方法，关闭套接字连接。\n\n    ```\n    // 终止输出方法，向对方发送一个输出的结束标志\n    socketChannel.shutdownOutput();\n    // 关闭套接字连接\n    socketChannel.close();\n    ```\n\n#### DatagramChannel的使用\n\n> DatagramChannel数据报通道用来处理UDP协议的数据传输。和Socket套接字的TCP传输协议不同，UDP协议不是面向连接的协议。使用UDP协议时，只要知道服务器的IP和端口，就可以直接向对方发送数据。\n\n1. **获取DatagramChannel传输通道**\n\n    ​\t\t调用DatagramChannel静态方法open()获得通道，然后设置为非阻塞模式，绑定数据报的监听端口：\n\n    ```java\n    // 获取通道\n    DatagramChannel datagramChannel = DatagramChannel.open();\n    // 设置为非阻塞\n    datagramChannel.configureBlocking(false);\t\t\n    // 绑定监听IP和端口\n    datagramChannel.socket().bind(new InetSocketAddress(InetAddress.getLocalHost(),5252));\n    ```\n\n2. **读取DatagramChannel传输通道**\n\n    ​\t\t不是调用read方法，而是调用receive：\n\n    ```java\n    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n    SocketAddress clientAddr = datagramChannel.receive(byteBuffer);\n    ```\n\n    ​\t\t通道读取receive（ByteBuffer buf）方法的返回值，是SocketAddress类型，表示返回发送端的连接地址（包括IP和端口）。\n\n3. **写入DatagramChannel传输通道**\n\n    ​\t\t不是调用write方法，而是调用send方法，由于UDP是面向非连接的协议，因此，在发送数据的时候，需要指定接收方的地址：\n\n    ```java\n    byteBuffer.flip();\n    datagramChannel.send(byteBuffer, new InetSocketAddress(InetAddress.getLocalHost(),5252));\n    byteBuffer.clear();\n    ```\n\n4. **关闭DatagramChannel传输通道**\n\n    ​\t\t与FileChannel一样，close()即可。\n\n### 三、Select类及其属性\n\n> 非阻塞模式下，如何知道SocketChannel和DatagramChannel通道何时是可读的呢？这时就需要用到NIO的新组件——Selector通道选择器\n>\n> 简单地说：**选择器的使命是完成IO的多路复用**。一个通道代表一条连接，通过选择器可以同时监控多个通道的IO（输入输出）状况。选择器和通道的关系，是监控和被监控的关系。\n\n#### Selector 选择器及注册\n\n​\t\t通道和选择器之间的关系，通过`Channel.register（Selector sel, int ops）`方法完成，需要传入待注册的选择器实例和待监控事件类型。\n\n可供选择器监控的**通道IO事件类型**（就绪状态），包括以下四种：\n\n1. 可读：SelectionKey.OP_READ\n2. 可写：SelectionKey.OP_WRITE\n3. 连接：SelectionKey.OP_CONNECT\n4. 接收：SelectionKey.OP_ACCEPT\n\n事件类型的定义在SelectionKey类中。如果选择器要监控通道的多种事件，可以用“按位或”运算符来实现。例如，同时监控可读和可写IO事件：\n\n```java\nint key = SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n```\n\n#### SelectableChannel(可选择通道)\n\n​\t\t一条通道若能被选择，必须继承SelectableChannel类。所有网络链接Socket套接字通道，都继承了SelectableChannel类，都是可选择的。而FileChannel文件通道，并没有继承SelectableChannel，因此不是可选择通道。\n\n#### SelectionKey(选择键)\n\n​\t\t一旦在通道中发生了某些IO事件（就绪状态达成），并且在选择器中注册过，就会被选择器选中，并放入SelectionKey的集合中。SelectionKey可以获得通道的IO事件类型，比方说SelectionKey.OP_READ，还可以获得发生IO事件所在的通道及选择器实例。\n\n#### 选择器的使用\n\n1. **获取选择器实例**\n\n    ​\t\t通过调用静态工厂方法open()来获取：\n\n    ```java\n    Selector selector = Selector.open();\n    ```\n\n    *open()的内部，是向选择器SPI（SelectorProvider）发出请求，通过默认的SPI对象，获取一个新的选择器实例。SPI全称为（Service Provider Interface，服务提供者接口），是JDK的一种可以扩展的服务提供和发现机制。Java通过SPI的方式，提供选择器的默认实现版本。也就是说，其他的服务提供商可以通过SPI的方式，提供定制化版本的选择器的动态替换或者扩展。*\n\n2. **将通道注册到选择器中**\n\n    ​\t\t需要注意：注册到选择器的通道，必须处于非阻塞模式下，否则将抛出IllegalBlockingModeException异常。并且一个通道，并不一定支持所有的四种IO事件。例如服务器监听通道ServerSocketChannel，仅支持Accept（接收到新连接）IO事件；而SocketChannel传输通道，则不支持Accept（接收到新连接）IO事件。可以在注册之前，通过通道的validOps()方法，来获取该通道所有支持的IO事件集合。\n\n    ```java\n    // 获取通道\n    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n    // 设置为非阻塞\n    serverSocketChannel.configureBlocking(false);\n    // 绑定连接\n    serverSocketChannel.bind(new InetSocketAddress(5252));\n    System.out.println(\"服务器启动成功\");\n    // 将通道注册的“接收新连接”IO事件注册到选择器上\n    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n    ```\n\n3. **选出感兴趣的IO就绪事件（选择键集合）**\n\n    ```java\n    // 轮询感兴趣的IO就绪事件（选择键集合）\n    while (selector.select() > 0) {\n        // 获取选择键集合\n        Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();\n        while (selectedKeys.hasNext()) {\n            // 获取单个的选择键并处理\n            SelectionKey selectedKey = selectedKeys.next();\n            if (selectedKey.isAcceptable()) {\n         \t\t// 通道有新连接\n            } else if (selectedKey.isConnectalbe()) {\n                // 通道连接成功\n            }  else if (selectedKey.isReadalbe()) {\n                // 通道可读\n            }  else if (selectedKey.isWritalbe()) {\n                // 通道可写\n            }\n            // 处理完后移除选择键\n            selectedKeys.remove();\n        }\n    }\n    ```\n\n    SelectionKey集合不能添加元素，如果试图向SelectionKey选择键集合中添加元素，则将抛出java.lang.UnsupportedOperationException异常。\n\n    select()方法有三个重载的实现版本，具体如下：\n\n    1. select()：阻塞调用，一直到至少有一个通道发生了注册的IO事件。\n    2. select(long timeout)：和select()一样，但最长阻塞时间为timeout指定的毫秒数。\n    3. selectNow()：非阻塞，不管有没有IO事件，都会立刻返回。\n\n    select()方法返回的整数值，表示从上一次select到这一次select之间，有多少**通道**发生了注册的IO事件。强调一下，select()方法返回的数量，指的是通道数，而不是IO事件数。\n\n#### 实践案例\n\n使用NIO实现Discard服务器，Discard服务器的功能很简单，读取客户端通道的输入数据，读取完成后直接关闭客户端通道；并且读取到的数据直接抛弃掉。\n\n**服务器端：**\n\n```java\n/**\n * 使用NIO实现Discard服务器端功能：\n *      仅读取客户端通道的输入数据，读取完成后直接关闭客户端通道，并且读取到的数据直接抛弃掉。\n */\npublic class NioDiscardServer {\n    public static void startServer() throws IOException {\n\n        // 获取选择器\n        Selector selector = Selector.open();\n        // 获取通道\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        // 设置为非阻塞\n        serverSocketChannel.configureBlocking(false);\n        // 绑定连接\n        serverSocketChannel.bind(new InetSocketAddress(5252));\n        System.out.println(\"服务器启动成功\");\n        // 将通道注册的“接收新连接”IO事件注册到选择器上\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        // 轮询感兴趣的IO就绪事件（选择键集合）\n        while (selector.select() > 0) {\n            // 获取选择键集合\n            Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();\n            while (selectedKeys.hasNext()) {\n                // 获取单个的选择键并处理\n                SelectionKey selectedKey = selectedKeys.next();\n                if (selectedKey.isAcceptable()) {\n                    // 若选择键的IO事件是“连接就绪”，就获取客户端连接\n                    SocketChannel socketChannel = serverSocketChannel.accept();\n                    // 切换为非阻塞模式\n                    socketChannel.configureBlocking(false);\n                    // 将新连接的通道可读事件注册到选择器上\n                    socketChannel.register(selector, SelectionKey.OP_READ);\n                } else if (selectedKey.isReadable()) {\n                    // 若选择键的IO事件是“可读”，就读取数据\n                    SocketChannel socketChannel = (SocketChannel) selectedKey.channel();\n                    // 读取数据，然后丢弃\n                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                    int length = 0;\n                    // 调用通道的read方法，从通道读取数据写入缓冲区，并返回读取到的数据\n                    while ((length = socketChannel.read(byteBuffer)) > 0) {\n                        byteBuffer.flip();\n                        System.out.println(new String(byteBuffer.array(), 0, length));\n                        byteBuffer.clear();\n                    }\n                    socketChannel.close();\n                }\n                // 移除选择键\n                selectedKeys.remove();\n            }\n        }\n        // 关闭连接\n        serverSocketChannel.close();\n    }\n}\n```\n\n**客户端：**\n\n```java\n/**\n * 使用NIO实现Discard客户端功能：\n *      客户端首先建立到服务器的连接，发送一些简单的数据，然后直接关闭连接。\n */\npublic class NioDiscardClient {\n\n    public static void startClient() throws IOException {\n        InetSocketAddress address = new InetSocketAddress(InetAddress.getLocalHost(),5252);\n        // 获取通道\n        SocketChannel socketChannel = SocketChannel.open(address);\n        // 设置为非阻塞\n        socketChannel.configureBlocking(false);\n        // 不断自旋，等待连接完成\n        while (!socketChannel.finishConnect()) {\n        }\n        System.out.println(\"客户端连接成功\");\n        // 分配指定大小的缓冲区\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        byteBuffer.put(\"hello nio\".getBytes());\n        byteBuffer.flip();\n        // 发送到服务器\n        socketChannel.write(byteBuffer);\n        // 终止输出方法，向对方发送一个输出的结束标志\n        socketChannel.shutdownOutput();\n        // 关闭套接字连接\n        socketChannel.close();\n    }\n}\n```\n\n**测试：**\n\n​\t\t先启动服务器，等到控制台出现“服务器启动成功”，再启动客户端，客户端连接成功后，发现服务器端出现“hello nio”则成功：\n\n服务器端：\n\n```\n服务器启动成功\n```\n\n客户端：\n\n```\n客户端连接成功\n```\n\n服务器端：\n\n```\n服务器启动成功\nhello nio\n```\n\n\n\n","slug":"java-nio","published":1,"updated":"2021-08-18T12:40:25.526Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshhgzjn0011iobf2wrd6c34","content":"<h2 id=\"Java-NIO通信基础\"><a href=\"#Java-NIO通信基础\" class=\"headerlink\" title=\"Java NIO通信基础\"></a>Java NIO通信基础</h2><h3 id=\"一、NIO简介\"><a href=\"#一、NIO简介\" class=\"headerlink\" title=\"一、NIO简介\"></a>一、NIO简介</h3><blockquote>\n<p>在1.4版本之前，Java IO类库是阻塞IO；从1.4版本开始，为了支持非阻塞IO，引进了新的异步IO库，被称为Java New IO类库，简称为JAVA NIO。Java NIO属于 IO多路复用模型。</p>\n</blockquote>\n<p><strong>NIO和OIO（old IO）的区别：</strong></p>\n<ul>\n<li>OIO面向流（Stream Oriented），NIO面向缓冲区（BufferOriented）</li>\n<li>OIO的操作是阻塞的，NIO是非阻塞的。</li>\n<li>OIO没有选择器（Selector）概念，NIO的选择器，需要底层操作系统提供支持。</li>\n</ul>\n<p>Java NIO由以下三个核心组件组成：· Channel（通道）· Buffer（缓冲区）· Selector（选择器）</p>\n<h4 id=\"1-通道（Channel）\"><a href=\"#1-通道（Channel）\" class=\"headerlink\" title=\"1. 通道（Channel）\"></a>1. 通道（Channel）</h4><p>​        在OIO中，同一个网络连接会通过输入流（Input Stream）和输出流（Output Stream）不断地进行输入和输出的操作。在NIO中，同一个网络连接使用一个通道表示，所有的NIO的IO操作都是从通道开始的。一个通道类似于OIO中的两个流的结合体，既可以从通道读取，也可以向通道写入。</p>\n<h4 id=\"2-选择器（Selector）\"><a href=\"#2-选择器（Selector）\" class=\"headerlink\" title=\"2. 选择器（Selector）\"></a>2. 选择器（Selector）</h4><blockquote>\n<p>IO多路复用指的是一个进程/线程可以同时监视多个文件描述符（一个网络连接，操作系统底层使用一个文件描述符来表示），一旦其中的一个或者多个文件描述符可读或者可写，系统内核就通知该进程/线程。</p>\n</blockquote>\n<p>​        通过选择器，一个线程可以查询多个通道的IO事件的就绪状态，即监视多个文件描述符。具体的开发层面来说，首先把通道注册到选择器中，然后通过选择器内部的机制，可以查询（select）这些注册的通道是否有已经就绪的IO事件（例如可读、可写、网络连接完成等）。一个选择器只需要一个线程进行监控，系统不必为每一个网络连接（文件描述符）创建进程/线程，从而大大减小了系统的开销。</p>\n<h4 id=\"3-缓冲区（Buffer）\"><a href=\"#3-缓冲区（Buffer）\" class=\"headerlink\" title=\"3. 缓冲区（Buffer）\"></a>3. 缓冲区（Buffer）</h4><p>​        应用程序与通道（Channel）主要的交互操作，就是进行数据的read读取和write写入。通道的读取，就是将数据从通道读取到缓冲区中；通道的写入，就是将数据从缓冲区中写入到通道中。</p>\n<h3 id=\"二、Buffer类及其属性\"><a href=\"#二、Buffer类及其属性\" class=\"headerlink\" title=\"二、Buffer类及其属性\"></a>二、Buffer类及其属性</h3><blockquote>\n<p>Buffer（缓冲区）本质上是一个内存块（数组），既可以写入数据，也可以从中读取数据。</p>\n</blockquote>\n<h4 id=\"Buffer类\"><a href=\"#Buffer类\" class=\"headerlink\" title=\"Buffer类\"></a>Buffer类</h4><p>​        Buffer类是一个抽象类，位于java.nio包中，线程不安全。在NIO中有8种缓冲区类：ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer、MappedByteBuffer，其中MappedByteBuffer是专门用于内存映射的一种ByteBuffer类型。使用最多的是ByteBuffer。</p>\n<h4 id=\"Buffer类的重要属性\"><a href=\"#Buffer类的重要属性\" class=\"headerlink\" title=\"Buffer类的重要属性\"></a>Buffer类的重要属性</h4><p>​        为了记录读写的状态和位置，Buffer类提供了一些重要的属性：capacity（容量）、position（读写位置）、limit（读写的限制）、mark（标记）。</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gp33iz38e4j30kk05pt9v.jpg\" alt=\"image\"></p>\n<h4 id=\"Buffer类的重要方法\"><a href=\"#Buffer类的重要方法\" class=\"headerlink\" title=\"Buffer类的重要方法\"></a>Buffer类的重要方法</h4><ol>\n<li><p><strong>allocate()创建缓冲区</strong></p>\n<p> ​        为了获取一个Buffer实例对象，并不是使用子类的构造器new来创建一个实例对象，而是调用子类的allocate()方法，并分配内存空间（capacity）。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntBuffer intBuffer = intBuffer.allocate(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>put()写入到缓冲区</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intBuffer.put(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>flip()翻转</strong></p>\n<p> ​        向缓冲区写入数据之后，不能直接从缓冲区中读取数据，需要使用flip()将写入模式翻转成读取模式。flip()方法源码如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">flip</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    limit = position;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>;</span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 容量为10的intBuffer，在写入1个数据时，position=1，limit=10，capacity=10；在写完翻转后，position=0，limit=1，capacity=10；</p>\n<blockquote>\n<p>读取完成后，如何再一次将缓冲区切换成写入模式呢？可以调用Buffer.clear()清空或者Buffer.compact()压缩方法，它们可以将缓冲区转换为写模式。</p>\n</blockquote>\n<p> 缓冲区读写模式的转换如图：</p>\n<p> <img src=\"https://tvax1.sinaimg.cn/large/006YzKDNly1gp34tey3npj30g1071aay.jpg\" alt=\"image\"></p>\n</li>\n<li><p><strong>clear()清空</strong></p>\n<p> ​        清空缓冲区但不清除数据，数据将“被遗忘”，缓冲区切换为写入模式。源码如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>;</span><br><span class=\"line\">    limit = capacity;</span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>compact()压缩</strong></p>\n<p> ​        不覆盖未读的数据，将所有未读的数据拷贝到Buffer起始处，然后将position设到最后一个未读元素后面，limit设置为capacity，缓冲区切换为写入模式。源码如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ByteBuffer <span class=\"title\">compact</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.arraycopy(hb, ix(position()), hb, ix(<span class=\"number\">0</span>), remaining()); <span class=\"comment\">// 拷贝未读数据</span></span><br><span class=\"line\">    position(remaining()); <span class=\"comment\">// remaining()返回limit - position</span></span><br><span class=\"line\">    limit(capacity()); <span class=\"comment\">// limit设置为capacity</span></span><br><span class=\"line\">    discardMark(); <span class=\"comment\">// mark = -1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>get()从缓冲区读取</strong></p>\n<p> ​        翻转后可读，读操作会改变可读位置position的值，而limit值不会改变。如果position==limit，表示所有数据读取完成，position指向了一个没有数据的元素位置，此时再读，会抛出BufferUnderflowException异常。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byteBuffer.get();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>rewind()倒带</strong></p>\n<p> ​        已读完的数据，如果需要再读一遍，可以调用rewind()方法。rewind()也叫倒带。源码如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">rewind</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>; <span class=\"comment\">// 重置</span></span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>; <span class=\"comment\">// 清理标记</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>rewind()和flip()区别在于：rewind()不会影响limit；而flip()会重设limit属性值。</p>\n</blockquote>\n</li>\n<li><p><strong>mark( )和reset( )</strong></p>\n<p>​        Buffer.mark()和Buffer.reset()方法是配套使用的，比如读到第3个元素（i= =2时），调用mark()方法，把当前位置position的值保存到mark属性中，这时mark属性的值为2。接下来，就可以调用reset方法，将mark属性的值恢复到position中。然后可以从位置2（第三个元素）开始读。</p>\n</li>\n</ol>\n<p><strong>Buffer类的基本使用步骤</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntBuffer intBuffer = intBuffer.allocate(<span class=\"number\">10</span>);</span><br><span class=\"line\">intBuffer.put(<span class=\"number\">1</span>);</span><br><span class=\"line\">intBuffer.flip();</span><br><span class=\"line\">intBuffer.get();</span><br><span class=\"line\">intBuffer.clear();||intBuffer.compact();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、Channel类及其属性\"><a href=\"#二、Channel类及其属性\" class=\"headerlink\" title=\"二、Channel类及其属性\"></a>二、Channel类及其属性</h3><blockquote>\n<p>NIO中一个连接用一个Channel（通道）来表示，一个通道可以表示一个底层的文件描述符，例如硬件设备、文件、网络连接等。对于不同的网络传输协议类型，在Java中都有不同的NIO Channel（通道）实现。</p>\n</blockquote>\n<h4 id=\"Channel（通道）的主要类型\"><a href=\"#Channel（通道）的主要类型\" class=\"headerlink\" title=\"Channel（通道）的主要类型\"></a>Channel（通道）的主要类型</h4><ol>\n<li><p>FileChannel文件通道，用于文件的数据读写。</p>\n</li>\n<li><p>SocketChannel套接字通道，用于Socket套接字TCP连接的数据读写。</p>\n</li>\n<li><p>ServerSocketChannel服务器嵌套字通道（或服务器监听通道），允许我们监听TCP连接请求，为每个监听到的请求，创建一个SocketChannel套接字通道。</p>\n</li>\n<li><p>DatagramChannel数据报通道，用于UDP协议的数据读写。</p>\n</li>\n</ol>\n<h4 id=\"FileChannel的使用\"><a href=\"#FileChannel的使用\" class=\"headerlink\" title=\"FileChannel的使用\"></a>FileChannel的使用</h4><blockquote>\n<p>通过FileChannel，既可以从一个文件中读取数据，也可以将数据写入到文件中。FileChannel为<strong>阻塞模式</strong>，不能设置为非阻塞模式。</p>\n</blockquote>\n<ol>\n<li><strong>获取FileChannel通道</strong></li>\n</ol>\n<ul>\n<li><p>通过文件输入输出流获取：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建文件输入流</span></span><br><span class=\"line\">FileInputStream fis = <span class=\"keyword\">new</span> FileInputStream(srcFile);</span><br><span class=\"line\"><span class=\"comment\">// 获取文件流的通道</span></span><br><span class=\"line\">FileChannel inChannel = fis.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建文件输出流</span></span><br><span class=\"line\">FileOutputStream fos = <span class=\"keyword\">new</span> FileOutputStream(destFile);</span><br><span class=\"line\"><span class=\"comment\">// 获取文件流的通道</span></span><br><span class=\"line\">FileChannel outChannel = fis.getChannel();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过RandomAccessFile类获取：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建RandomAccessFile随机访问对象</span></span><br><span class=\"line\">RandomAccessFile rafile = <span class=\"keyword\">new</span> RandomAccessFile(srcFile, <span class=\"string\">\"rw\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 获取文件流的通道</span></span><br><span class=\"line\">FileChannel raFileChannel = rafile.getChannel();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p><strong>读取FileChannel通道</strong></p>\n<p> ​        调用<code>public abstract int read(ByteBuffer src) throws IOException</code>方法读取通道数据，写入ByteBuffer缓冲区，并返回数据。<strong>虽然对于通道来说是读取数据，但是对于ByteBuffer缓冲区来说是写入数据，这时，ByteBuffer缓冲区处于写入模式。</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> length = -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (-<span class=\"number\">1</span> != (length = raFileChannel.read(byteBuffer))) &#123;</span><br><span class=\"line\"><span class=\"comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>写入FileChannel通道</strong></p>\n<p> ​        调用<code>public abstract int write(ByteBuffer src) throws IOException</code>方法读取缓冲区数据写入通道，并返回写入的字节数。<strong>对于ByteBuffer缓冲区来说是读入数据，对通道来说是写入。</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 刚写完要翻转成读取模式</span></span><br><span class=\"line\">byteBuffer.flip();</span><br><span class=\"line\"><span class=\"keyword\">int</span> outlength = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"number\">0</span> != (outlength = raFileChannel.write(byteBuffer))) &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"写入字节数：\"</span> + outlength);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>关闭通道</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inChannel.close();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>强制刷新到磁盘</strong></p>\n<p> ​        在将缓冲区写入通道时，出于性能原因，操作系统不可能每次都实时将数据写入磁盘。如果需要保证写入通道的缓冲数据，最终都真正地写入磁盘，可以调用FileChannel的force()方法。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inChannel.force(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"SocketChannel和ServerSocketChannel的使用\"><a href=\"#SocketChannel和ServerSocketChannel的使用\" class=\"headerlink\" title=\"SocketChannel和ServerSocketChannel的使用\"></a>SocketChannel和ServerSocketChannel的使用</h4><blockquote>\n<p>在NIO中，涉及网络连接的通道有两个，一个是SocketChannel负责连接传输，另一个是ServerSocketChannel负责连接的监听。都<strong>支持阻塞和非阻塞两种模式</strong>。ServerSocketChannel应用于服务器端，而SocketChannel同时处于服务器端和客户端。对于一个连接，两端都有一个负责传输的SocketChannel传输通道。SocketChannel与OIO中的Socket类对应，ServerSocketChannel与OIO中的ServerSocket类对应。</p>\n</blockquote>\n<ol>\n<li><p><strong>获取SocketChannel传输通道</strong></p>\n<p> ​        在<strong>客户端</strong>，先通过SocketChannel静态方法open()获得一个套接字传输通道；然后，将socket套接字设置为非阻塞模式；最后，通过connect()实例方法，对服务器的IP和端口发起连接。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">SocketChannel socketChannel = SocketChannel.open();</span><br><span class=\"line\"><span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 对服务器的IP和端口发起连接</span></span><br><span class=\"line\">socketChannel.connect(<span class=\"keyword\">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class=\"number\">5252</span>));</span><br></pre></td></tr></table></figure>\n\n<p> ​        非阻塞情况下，与服务器的连接可能还没有真正建立，socketChannel.connect方法就返回了，因此需要不断地自旋，检查当前是否连接到了主机：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不断自旋，等待连接完成</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (!socketChannel.finishConnect()) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> ​        在<strong>服务器端</strong>，当新连接事件到来时，ServerSocketChannel能成功地查询，通过accept()方法，来获取新连接的套接字通道：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新连接事件到来,通过事件（后面会讲到key）获取服务器监听通道</span></span><br><span class=\"line\">ServerSocketChannel serverSocketChannel = （ServerSocketChannel）key.channel();</span><br><span class=\"line\"><span class=\"comment\">// 获取新连接的套接字通道</span></span><br><span class=\"line\">SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class=\"line\"><span class=\"comment\">// 切换为非阻塞模式</span></span><br><span class=\"line\">socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>读取SocketChannel传输通道</strong></p>\n<p> ​        与FileChannel一样</p>\n</li>\n<li><p><strong>写入SocketChannel传输通道</strong></p>\n<p> ​        与FileChannel一样</p>\n</li>\n<li><p><strong>关闭SocketChannel传输通道</strong></p>\n<p> ​        在关闭SocketChannel传输通道前，如果传输通道用来写入数据，则建议调用一次shutdownOutput()终止输出方法，向对方发送一个输出的结束标志（-1）。然后调用socketChannel.close()方法，关闭套接字连接。</p>\n <figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 终止输出方法，向对方发送一个输出的结束标志</span></span><br><span class=\"line\"><span class=\"selector-tag\">socketChannel</span><span class=\"selector-class\">.shutdownOutput</span>();</span><br><span class=\"line\"><span class=\"comment\">// 关闭套接字连接</span></span><br><span class=\"line\"><span class=\"selector-tag\">socketChannel</span><span class=\"selector-class\">.close</span>();</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"DatagramChannel的使用\"><a href=\"#DatagramChannel的使用\" class=\"headerlink\" title=\"DatagramChannel的使用\"></a>DatagramChannel的使用</h4><blockquote>\n<p>DatagramChannel数据报通道用来处理UDP协议的数据传输。和Socket套接字的TCP传输协议不同，UDP协议不是面向连接的协议。使用UDP协议时，只要知道服务器的IP和端口，就可以直接向对方发送数据。</p>\n</blockquote>\n<ol>\n<li><p><strong>获取DatagramChannel传输通道</strong></p>\n<p> ​        调用DatagramChannel静态方法open()获得通道，然后设置为非阻塞模式，绑定数据报的监听端口：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class=\"line\"><span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">datagramChannel.configureBlocking(<span class=\"keyword\">false</span>);\t\t</span><br><span class=\"line\"><span class=\"comment\">// 绑定监听IP和端口</span></span><br><span class=\"line\">datagramChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class=\"number\">5252</span>));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>读取DatagramChannel传输通道</strong></p>\n<p> ​        不是调用read方法，而是调用receive：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">SocketAddress clientAddr = datagramChannel.receive(byteBuffer);</span><br></pre></td></tr></table></figure>\n\n<p> ​        通道读取receive（ByteBuffer buf）方法的返回值，是SocketAddress类型，表示返回发送端的连接地址（包括IP和端口）。</p>\n</li>\n<li><p><strong>写入DatagramChannel传输通道</strong></p>\n<p> ​        不是调用write方法，而是调用send方法，由于UDP是面向非连接的协议，因此，在发送数据的时候，需要指定接收方的地址：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byteBuffer.flip();</span><br><span class=\"line\">datagramChannel.send(byteBuffer, <span class=\"keyword\">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class=\"number\">5252</span>));</span><br><span class=\"line\">byteBuffer.clear();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>关闭DatagramChannel传输通道</strong></p>\n<p> ​        与FileChannel一样，close()即可。</p>\n</li>\n</ol>\n<h3 id=\"三、Select类及其属性\"><a href=\"#三、Select类及其属性\" class=\"headerlink\" title=\"三、Select类及其属性\"></a>三、Select类及其属性</h3><blockquote>\n<p>非阻塞模式下，如何知道SocketChannel和DatagramChannel通道何时是可读的呢？这时就需要用到NIO的新组件——Selector通道选择器</p>\n<p>简单地说：<strong>选择器的使命是完成IO的多路复用</strong>。一个通道代表一条连接，通过选择器可以同时监控多个通道的IO（输入输出）状况。选择器和通道的关系，是监控和被监控的关系。</p>\n</blockquote>\n<h4 id=\"Selector-选择器及注册\"><a href=\"#Selector-选择器及注册\" class=\"headerlink\" title=\"Selector 选择器及注册\"></a>Selector 选择器及注册</h4><p>​        通道和选择器之间的关系，通过<code>Channel.register（Selector sel, int ops）</code>方法完成，需要传入待注册的选择器实例和待监控事件类型。</p>\n<p>可供选择器监控的<strong>通道IO事件类型</strong>（就绪状态），包括以下四种：</p>\n<ol>\n<li>可读：SelectionKey.OP_READ</li>\n<li>可写：SelectionKey.OP_WRITE</li>\n<li>连接：SelectionKey.OP_CONNECT</li>\n<li>接收：SelectionKey.OP_ACCEPT</li>\n</ol>\n<p>事件类型的定义在SelectionKey类中。如果选择器要监控通道的多种事件，可以用“按位或”运算符来实现。例如，同时监控可读和可写IO事件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> key = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SelectableChannel-可选择通道\"><a href=\"#SelectableChannel-可选择通道\" class=\"headerlink\" title=\"SelectableChannel(可选择通道)\"></a>SelectableChannel(可选择通道)</h4><p>​        一条通道若能被选择，必须继承SelectableChannel类。所有网络链接Socket套接字通道，都继承了SelectableChannel类，都是可选择的。而FileChannel文件通道，并没有继承SelectableChannel，因此不是可选择通道。</p>\n<h4 id=\"SelectionKey-选择键\"><a href=\"#SelectionKey-选择键\" class=\"headerlink\" title=\"SelectionKey(选择键)\"></a>SelectionKey(选择键)</h4><p>​        一旦在通道中发生了某些IO事件（就绪状态达成），并且在选择器中注册过，就会被选择器选中，并放入SelectionKey的集合中。SelectionKey可以获得通道的IO事件类型，比方说SelectionKey.OP_READ，还可以获得发生IO事件所在的通道及选择器实例。</p>\n<h4 id=\"选择器的使用\"><a href=\"#选择器的使用\" class=\"headerlink\" title=\"选择器的使用\"></a>选择器的使用</h4><ol>\n<li><p><strong>获取选择器实例</strong></p>\n<p> ​        通过调用静态工厂方法open()来获取：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>\n\n<p> <em>open()的内部，是向选择器SPI（SelectorProvider）发出请求，通过默认的SPI对象，获取一个新的选择器实例。SPI全称为（Service Provider Interface，服务提供者接口），是JDK的一种可以扩展的服务提供和发现机制。Java通过SPI的方式，提供选择器的默认实现版本。也就是说，其他的服务提供商可以通过SPI的方式，提供定制化版本的选择器的动态替换或者扩展。</em></p>\n</li>\n<li><p><strong>将通道注册到选择器中</strong></p>\n<p> ​        需要注意：注册到选择器的通道，必须处于非阻塞模式下，否则将抛出IllegalBlockingModeException异常。并且一个通道，并不一定支持所有的四种IO事件。例如服务器监听通道ServerSocketChannel，仅支持Accept（接收到新连接）IO事件；而SocketChannel传输通道，则不支持Accept（接收到新连接）IO事件。可以在注册之前，通过通道的validOps()方法，来获取该通道所有支持的IO事件集合。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\"><span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 绑定连接</span></span><br><span class=\"line\">serverSocketChannel.bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">5252</span>));</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"服务器启动成功\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 将通道注册的“接收新连接”IO事件注册到选择器上</span></span><br><span class=\"line\">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>选出感兴趣的IO就绪事件（选择键集合）</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 轮询感兴趣的IO就绪事件（选择键集合）</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (selector.select() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取选择键集合</span></span><br><span class=\"line\">    Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (selectedKeys.hasNext()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取单个的选择键并处理</span></span><br><span class=\"line\">        SelectionKey selectedKey = selectedKeys.next();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedKey.isAcceptable()) &#123;</span><br><span class=\"line\">     \t\t<span class=\"comment\">// 通道有新连接</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isConnectalbe()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通道连接成功</span></span><br><span class=\"line\">        &#125;  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isReadalbe()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通道可读</span></span><br><span class=\"line\">        &#125;  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isWritalbe()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通道可写</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 处理完后移除选择键</span></span><br><span class=\"line\">        selectedKeys.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> SelectionKey集合不能添加元素，如果试图向SelectionKey选择键集合中添加元素，则将抛出java.lang.UnsupportedOperationException异常。</p>\n<p> select()方法有三个重载的实现版本，具体如下：</p>\n<ol>\n<li><p>select()：阻塞调用，一直到至少有一个通道发生了注册的IO事件。</p>\n</li>\n<li><p>select(long timeout)：和select()一样，但最长阻塞时间为timeout指定的毫秒数。</p>\n</li>\n<li><p>selectNow()：非阻塞，不管有没有IO事件，都会立刻返回。</p>\n<p>select()方法返回的整数值，表示从上一次select到这一次select之间，有多少<strong>通道</strong>发生了注册的IO事件。强调一下，select()方法返回的数量，指的是通道数，而不是IO事件数。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"实践案例\"><a href=\"#实践案例\" class=\"headerlink\" title=\"实践案例\"></a>实践案例</h4><p>使用NIO实现Discard服务器，Discard服务器的功能很简单，读取客户端通道的输入数据，读取完成后直接关闭客户端通道；并且读取到的数据直接抛弃掉。</p>\n<p><strong>服务器端：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用NIO实现Discard服务器端功能：</span></span><br><span class=\"line\"><span class=\"comment\"> *      仅读取客户端通道的输入数据，读取完成后直接关闭客户端通道，并且读取到的数据直接抛弃掉。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioDiscardServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startServer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取选择器</span></span><br><span class=\"line\">        Selector selector = Selector.open();</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\">        <span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">        serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 绑定连接</span></span><br><span class=\"line\">        serverSocketChannel.bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">5252</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"服务器启动成功\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 将通道注册的“接收新连接”IO事件注册到选择器上</span></span><br><span class=\"line\">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 轮询感兴趣的IO就绪事件（选择键集合）</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (selector.select() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取选择键集合</span></span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (selectedKeys.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取单个的选择键并处理</span></span><br><span class=\"line\">                SelectionKey selectedKey = selectedKeys.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (selectedKey.isAcceptable()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 若选择键的IO事件是“连接就绪”，就获取客户端连接</span></span><br><span class=\"line\">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class=\"line\">                    <span class=\"comment\">// 切换为非阻塞模式</span></span><br><span class=\"line\">                    socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 将新连接的通道可读事件注册到选择器上</span></span><br><span class=\"line\">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isReadable()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 若选择键的IO事件是“可读”，就读取数据</span></span><br><span class=\"line\">                    SocketChannel socketChannel = (SocketChannel) selectedKey.channel();</span><br><span class=\"line\">                    <span class=\"comment\">// 读取数据，然后丢弃</span></span><br><span class=\"line\">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 调用通道的read方法，从通道读取数据写入缓冲区，并返回读取到的数据</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> ((length = socketChannel.read(byteBuffer)) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        byteBuffer.flip();</span><br><span class=\"line\">                        System.out.println(<span class=\"keyword\">new</span> String(byteBuffer.array(), <span class=\"number\">0</span>, length));</span><br><span class=\"line\">                        byteBuffer.clear();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    socketChannel.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 移除选择键</span></span><br><span class=\"line\">                selectedKeys.remove();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\">        serverSocketChannel.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>客户端：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用NIO实现Discard客户端功能：</span></span><br><span class=\"line\"><span class=\"comment\"> *      客户端首先建立到服务器的连接，发送一些简单的数据，然后直接关闭连接。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioDiscardClient</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startClient</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        InetSocketAddress address = <span class=\"keyword\">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class=\"number\">5252</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        SocketChannel socketChannel = SocketChannel.open(address);</span><br><span class=\"line\">        <span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">        socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 不断自旋，等待连接完成</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!socketChannel.finishConnect()) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端连接成功\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 分配指定大小的缓冲区</span></span><br><span class=\"line\">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">        byteBuffer.put(<span class=\"string\">\"hello nio\"</span>.getBytes());</span><br><span class=\"line\">        byteBuffer.flip();</span><br><span class=\"line\">        <span class=\"comment\">// 发送到服务器</span></span><br><span class=\"line\">        socketChannel.write(byteBuffer);</span><br><span class=\"line\">        <span class=\"comment\">// 终止输出方法，向对方发送一个输出的结束标志</span></span><br><span class=\"line\">        socketChannel.shutdownOutput();</span><br><span class=\"line\">        <span class=\"comment\">// 关闭套接字连接</span></span><br><span class=\"line\">        socketChannel.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试：</strong></p>\n<p>​        先启动服务器，等到控制台出现“服务器启动成功”，再启动客户端，客户端连接成功后，发现服务器端出现“hello nio”则成功：</p>\n<p>服务器端：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">服务器启动成功</span><br></pre></td></tr></table></figure>\n\n<p>客户端：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端连接成功</span><br></pre></td></tr></table></figure>\n\n<p>服务器端：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">服务器启动成功</span></span><br><span class=\"line\"><span class=\"attr\">hello</span> <span class=\"string\">nio</span></span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java-NIO通信基础\"><a href=\"#Java-NIO通信基础\" class=\"headerlink\" title=\"Java NIO通信基础\"></a>Java NIO通信基础</h2><h3 id=\"一、NIO简介\"><a href=\"#一、NIO简介\" class=\"headerlink\" title=\"一、NIO简介\"></a>一、NIO简介</h3><blockquote>\n<p>在1.4版本之前，Java IO类库是阻塞IO；从1.4版本开始，为了支持非阻塞IO，引进了新的异步IO库，被称为Java New IO类库，简称为JAVA NIO。Java NIO属于 IO多路复用模型。</p>\n</blockquote>\n<p><strong>NIO和OIO（old IO）的区别：</strong></p>\n<ul>\n<li>OIO面向流（Stream Oriented），NIO面向缓冲区（BufferOriented）</li>\n<li>OIO的操作是阻塞的，NIO是非阻塞的。</li>\n<li>OIO没有选择器（Selector）概念，NIO的选择器，需要底层操作系统提供支持。</li>\n</ul>\n<p>Java NIO由以下三个核心组件组成：· Channel（通道）· Buffer（缓冲区）· Selector（选择器）</p>\n<h4 id=\"1-通道（Channel）\"><a href=\"#1-通道（Channel）\" class=\"headerlink\" title=\"1. 通道（Channel）\"></a>1. 通道（Channel）</h4><p>​        在OIO中，同一个网络连接会通过输入流（Input Stream）和输出流（Output Stream）不断地进行输入和输出的操作。在NIO中，同一个网络连接使用一个通道表示，所有的NIO的IO操作都是从通道开始的。一个通道类似于OIO中的两个流的结合体，既可以从通道读取，也可以向通道写入。</p>\n<h4 id=\"2-选择器（Selector）\"><a href=\"#2-选择器（Selector）\" class=\"headerlink\" title=\"2. 选择器（Selector）\"></a>2. 选择器（Selector）</h4><blockquote>\n<p>IO多路复用指的是一个进程/线程可以同时监视多个文件描述符（一个网络连接，操作系统底层使用一个文件描述符来表示），一旦其中的一个或者多个文件描述符可读或者可写，系统内核就通知该进程/线程。</p>\n</blockquote>\n<p>​        通过选择器，一个线程可以查询多个通道的IO事件的就绪状态，即监视多个文件描述符。具体的开发层面来说，首先把通道注册到选择器中，然后通过选择器内部的机制，可以查询（select）这些注册的通道是否有已经就绪的IO事件（例如可读、可写、网络连接完成等）。一个选择器只需要一个线程进行监控，系统不必为每一个网络连接（文件描述符）创建进程/线程，从而大大减小了系统的开销。</p>\n<h4 id=\"3-缓冲区（Buffer）\"><a href=\"#3-缓冲区（Buffer）\" class=\"headerlink\" title=\"3. 缓冲区（Buffer）\"></a>3. 缓冲区（Buffer）</h4><p>​        应用程序与通道（Channel）主要的交互操作，就是进行数据的read读取和write写入。通道的读取，就是将数据从通道读取到缓冲区中；通道的写入，就是将数据从缓冲区中写入到通道中。</p>\n<h3 id=\"二、Buffer类及其属性\"><a href=\"#二、Buffer类及其属性\" class=\"headerlink\" title=\"二、Buffer类及其属性\"></a>二、Buffer类及其属性</h3><blockquote>\n<p>Buffer（缓冲区）本质上是一个内存块（数组），既可以写入数据，也可以从中读取数据。</p>\n</blockquote>\n<h4 id=\"Buffer类\"><a href=\"#Buffer类\" class=\"headerlink\" title=\"Buffer类\"></a>Buffer类</h4><p>​        Buffer类是一个抽象类，位于java.nio包中，线程不安全。在NIO中有8种缓冲区类：ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer、MappedByteBuffer，其中MappedByteBuffer是专门用于内存映射的一种ByteBuffer类型。使用最多的是ByteBuffer。</p>\n<h4 id=\"Buffer类的重要属性\"><a href=\"#Buffer类的重要属性\" class=\"headerlink\" title=\"Buffer类的重要属性\"></a>Buffer类的重要属性</h4><p>​        为了记录读写的状态和位置，Buffer类提供了一些重要的属性：capacity（容量）、position（读写位置）、limit（读写的限制）、mark（标记）。</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gp33iz38e4j30kk05pt9v.jpg\" alt=\"image\"></p>\n<h4 id=\"Buffer类的重要方法\"><a href=\"#Buffer类的重要方法\" class=\"headerlink\" title=\"Buffer类的重要方法\"></a>Buffer类的重要方法</h4><ol>\n<li><p><strong>allocate()创建缓冲区</strong></p>\n<p> ​        为了获取一个Buffer实例对象，并不是使用子类的构造器new来创建一个实例对象，而是调用子类的allocate()方法，并分配内存空间（capacity）。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntBuffer intBuffer = intBuffer.allocate(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>put()写入到缓冲区</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intBuffer.put(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>flip()翻转</strong></p>\n<p> ​        向缓冲区写入数据之后，不能直接从缓冲区中读取数据，需要使用flip()将写入模式翻转成读取模式。flip()方法源码如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">flip</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    limit = position;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>;</span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 容量为10的intBuffer，在写入1个数据时，position=1，limit=10，capacity=10；在写完翻转后，position=0，limit=1，capacity=10；</p>\n<blockquote>\n<p>读取完成后，如何再一次将缓冲区切换成写入模式呢？可以调用Buffer.clear()清空或者Buffer.compact()压缩方法，它们可以将缓冲区转换为写模式。</p>\n</blockquote>\n<p> 缓冲区读写模式的转换如图：</p>\n<p> <img src=\"https://tvax1.sinaimg.cn/large/006YzKDNly1gp34tey3npj30g1071aay.jpg\" alt=\"image\"></p>\n</li>\n<li><p><strong>clear()清空</strong></p>\n<p> ​        清空缓冲区但不清除数据，数据将“被遗忘”，缓冲区切换为写入模式。源码如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>;</span><br><span class=\"line\">    limit = capacity;</span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>compact()压缩</strong></p>\n<p> ​        不覆盖未读的数据，将所有未读的数据拷贝到Buffer起始处，然后将position设到最后一个未读元素后面，limit设置为capacity，缓冲区切换为写入模式。源码如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ByteBuffer <span class=\"title\">compact</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.arraycopy(hb, ix(position()), hb, ix(<span class=\"number\">0</span>), remaining()); <span class=\"comment\">// 拷贝未读数据</span></span><br><span class=\"line\">    position(remaining()); <span class=\"comment\">// remaining()返回limit - position</span></span><br><span class=\"line\">    limit(capacity()); <span class=\"comment\">// limit设置为capacity</span></span><br><span class=\"line\">    discardMark(); <span class=\"comment\">// mark = -1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>get()从缓冲区读取</strong></p>\n<p> ​        翻转后可读，读操作会改变可读位置position的值，而limit值不会改变。如果position==limit，表示所有数据读取完成，position指向了一个没有数据的元素位置，此时再读，会抛出BufferUnderflowException异常。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byteBuffer.get();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>rewind()倒带</strong></p>\n<p> ​        已读完的数据，如果需要再读一遍，可以调用rewind()方法。rewind()也叫倒带。源码如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">rewind</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>; <span class=\"comment\">// 重置</span></span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>; <span class=\"comment\">// 清理标记</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>rewind()和flip()区别在于：rewind()不会影响limit；而flip()会重设limit属性值。</p>\n</blockquote>\n</li>\n<li><p><strong>mark( )和reset( )</strong></p>\n<p>​        Buffer.mark()和Buffer.reset()方法是配套使用的，比如读到第3个元素（i= =2时），调用mark()方法，把当前位置position的值保存到mark属性中，这时mark属性的值为2。接下来，就可以调用reset方法，将mark属性的值恢复到position中。然后可以从位置2（第三个元素）开始读。</p>\n</li>\n</ol>\n<p><strong>Buffer类的基本使用步骤</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntBuffer intBuffer = intBuffer.allocate(<span class=\"number\">10</span>);</span><br><span class=\"line\">intBuffer.put(<span class=\"number\">1</span>);</span><br><span class=\"line\">intBuffer.flip();</span><br><span class=\"line\">intBuffer.get();</span><br><span class=\"line\">intBuffer.clear();||intBuffer.compact();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、Channel类及其属性\"><a href=\"#二、Channel类及其属性\" class=\"headerlink\" title=\"二、Channel类及其属性\"></a>二、Channel类及其属性</h3><blockquote>\n<p>NIO中一个连接用一个Channel（通道）来表示，一个通道可以表示一个底层的文件描述符，例如硬件设备、文件、网络连接等。对于不同的网络传输协议类型，在Java中都有不同的NIO Channel（通道）实现。</p>\n</blockquote>\n<h4 id=\"Channel（通道）的主要类型\"><a href=\"#Channel（通道）的主要类型\" class=\"headerlink\" title=\"Channel（通道）的主要类型\"></a>Channel（通道）的主要类型</h4><ol>\n<li><p>FileChannel文件通道，用于文件的数据读写。</p>\n</li>\n<li><p>SocketChannel套接字通道，用于Socket套接字TCP连接的数据读写。</p>\n</li>\n<li><p>ServerSocketChannel服务器嵌套字通道（或服务器监听通道），允许我们监听TCP连接请求，为每个监听到的请求，创建一个SocketChannel套接字通道。</p>\n</li>\n<li><p>DatagramChannel数据报通道，用于UDP协议的数据读写。</p>\n</li>\n</ol>\n<h4 id=\"FileChannel的使用\"><a href=\"#FileChannel的使用\" class=\"headerlink\" title=\"FileChannel的使用\"></a>FileChannel的使用</h4><blockquote>\n<p>通过FileChannel，既可以从一个文件中读取数据，也可以将数据写入到文件中。FileChannel为<strong>阻塞模式</strong>，不能设置为非阻塞模式。</p>\n</blockquote>\n<ol>\n<li><strong>获取FileChannel通道</strong></li>\n</ol>\n<ul>\n<li><p>通过文件输入输出流获取：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建文件输入流</span></span><br><span class=\"line\">FileInputStream fis = <span class=\"keyword\">new</span> FileInputStream(srcFile);</span><br><span class=\"line\"><span class=\"comment\">// 获取文件流的通道</span></span><br><span class=\"line\">FileChannel inChannel = fis.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建文件输出流</span></span><br><span class=\"line\">FileOutputStream fos = <span class=\"keyword\">new</span> FileOutputStream(destFile);</span><br><span class=\"line\"><span class=\"comment\">// 获取文件流的通道</span></span><br><span class=\"line\">FileChannel outChannel = fis.getChannel();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过RandomAccessFile类获取：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建RandomAccessFile随机访问对象</span></span><br><span class=\"line\">RandomAccessFile rafile = <span class=\"keyword\">new</span> RandomAccessFile(srcFile, <span class=\"string\">\"rw\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 获取文件流的通道</span></span><br><span class=\"line\">FileChannel raFileChannel = rafile.getChannel();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p><strong>读取FileChannel通道</strong></p>\n<p> ​        调用<code>public abstract int read(ByteBuffer src) throws IOException</code>方法读取通道数据，写入ByteBuffer缓冲区，并返回数据。<strong>虽然对于通道来说是读取数据，但是对于ByteBuffer缓冲区来说是写入数据，这时，ByteBuffer缓冲区处于写入模式。</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> length = -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (-<span class=\"number\">1</span> != (length = raFileChannel.read(byteBuffer))) &#123;</span><br><span class=\"line\"><span class=\"comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>写入FileChannel通道</strong></p>\n<p> ​        调用<code>public abstract int write(ByteBuffer src) throws IOException</code>方法读取缓冲区数据写入通道，并返回写入的字节数。<strong>对于ByteBuffer缓冲区来说是读入数据，对通道来说是写入。</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 刚写完要翻转成读取模式</span></span><br><span class=\"line\">byteBuffer.flip();</span><br><span class=\"line\"><span class=\"keyword\">int</span> outlength = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"number\">0</span> != (outlength = raFileChannel.write(byteBuffer))) &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"写入字节数：\"</span> + outlength);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>关闭通道</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inChannel.close();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>强制刷新到磁盘</strong></p>\n<p> ​        在将缓冲区写入通道时，出于性能原因，操作系统不可能每次都实时将数据写入磁盘。如果需要保证写入通道的缓冲数据，最终都真正地写入磁盘，可以调用FileChannel的force()方法。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inChannel.force(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"SocketChannel和ServerSocketChannel的使用\"><a href=\"#SocketChannel和ServerSocketChannel的使用\" class=\"headerlink\" title=\"SocketChannel和ServerSocketChannel的使用\"></a>SocketChannel和ServerSocketChannel的使用</h4><blockquote>\n<p>在NIO中，涉及网络连接的通道有两个，一个是SocketChannel负责连接传输，另一个是ServerSocketChannel负责连接的监听。都<strong>支持阻塞和非阻塞两种模式</strong>。ServerSocketChannel应用于服务器端，而SocketChannel同时处于服务器端和客户端。对于一个连接，两端都有一个负责传输的SocketChannel传输通道。SocketChannel与OIO中的Socket类对应，ServerSocketChannel与OIO中的ServerSocket类对应。</p>\n</blockquote>\n<ol>\n<li><p><strong>获取SocketChannel传输通道</strong></p>\n<p> ​        在<strong>客户端</strong>，先通过SocketChannel静态方法open()获得一个套接字传输通道；然后，将socket套接字设置为非阻塞模式；最后，通过connect()实例方法，对服务器的IP和端口发起连接。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">SocketChannel socketChannel = SocketChannel.open();</span><br><span class=\"line\"><span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 对服务器的IP和端口发起连接</span></span><br><span class=\"line\">socketChannel.connect(<span class=\"keyword\">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class=\"number\">5252</span>));</span><br></pre></td></tr></table></figure>\n\n<p> ​        非阻塞情况下，与服务器的连接可能还没有真正建立，socketChannel.connect方法就返回了，因此需要不断地自旋，检查当前是否连接到了主机：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不断自旋，等待连接完成</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (!socketChannel.finishConnect()) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> ​        在<strong>服务器端</strong>，当新连接事件到来时，ServerSocketChannel能成功地查询，通过accept()方法，来获取新连接的套接字通道：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新连接事件到来,通过事件（后面会讲到key）获取服务器监听通道</span></span><br><span class=\"line\">ServerSocketChannel serverSocketChannel = （ServerSocketChannel）key.channel();</span><br><span class=\"line\"><span class=\"comment\">// 获取新连接的套接字通道</span></span><br><span class=\"line\">SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class=\"line\"><span class=\"comment\">// 切换为非阻塞模式</span></span><br><span class=\"line\">socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>读取SocketChannel传输通道</strong></p>\n<p> ​        与FileChannel一样</p>\n</li>\n<li><p><strong>写入SocketChannel传输通道</strong></p>\n<p> ​        与FileChannel一样</p>\n</li>\n<li><p><strong>关闭SocketChannel传输通道</strong></p>\n<p> ​        在关闭SocketChannel传输通道前，如果传输通道用来写入数据，则建议调用一次shutdownOutput()终止输出方法，向对方发送一个输出的结束标志（-1）。然后调用socketChannel.close()方法，关闭套接字连接。</p>\n <figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 终止输出方法，向对方发送一个输出的结束标志</span></span><br><span class=\"line\"><span class=\"selector-tag\">socketChannel</span><span class=\"selector-class\">.shutdownOutput</span>();</span><br><span class=\"line\"><span class=\"comment\">// 关闭套接字连接</span></span><br><span class=\"line\"><span class=\"selector-tag\">socketChannel</span><span class=\"selector-class\">.close</span>();</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"DatagramChannel的使用\"><a href=\"#DatagramChannel的使用\" class=\"headerlink\" title=\"DatagramChannel的使用\"></a>DatagramChannel的使用</h4><blockquote>\n<p>DatagramChannel数据报通道用来处理UDP协议的数据传输。和Socket套接字的TCP传输协议不同，UDP协议不是面向连接的协议。使用UDP协议时，只要知道服务器的IP和端口，就可以直接向对方发送数据。</p>\n</blockquote>\n<ol>\n<li><p><strong>获取DatagramChannel传输通道</strong></p>\n<p> ​        调用DatagramChannel静态方法open()获得通道，然后设置为非阻塞模式，绑定数据报的监听端口：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class=\"line\"><span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">datagramChannel.configureBlocking(<span class=\"keyword\">false</span>);\t\t</span><br><span class=\"line\"><span class=\"comment\">// 绑定监听IP和端口</span></span><br><span class=\"line\">datagramChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class=\"number\">5252</span>));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>读取DatagramChannel传输通道</strong></p>\n<p> ​        不是调用read方法，而是调用receive：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">SocketAddress clientAddr = datagramChannel.receive(byteBuffer);</span><br></pre></td></tr></table></figure>\n\n<p> ​        通道读取receive（ByteBuffer buf）方法的返回值，是SocketAddress类型，表示返回发送端的连接地址（包括IP和端口）。</p>\n</li>\n<li><p><strong>写入DatagramChannel传输通道</strong></p>\n<p> ​        不是调用write方法，而是调用send方法，由于UDP是面向非连接的协议，因此，在发送数据的时候，需要指定接收方的地址：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byteBuffer.flip();</span><br><span class=\"line\">datagramChannel.send(byteBuffer, <span class=\"keyword\">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class=\"number\">5252</span>));</span><br><span class=\"line\">byteBuffer.clear();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>关闭DatagramChannel传输通道</strong></p>\n<p> ​        与FileChannel一样，close()即可。</p>\n</li>\n</ol>\n<h3 id=\"三、Select类及其属性\"><a href=\"#三、Select类及其属性\" class=\"headerlink\" title=\"三、Select类及其属性\"></a>三、Select类及其属性</h3><blockquote>\n<p>非阻塞模式下，如何知道SocketChannel和DatagramChannel通道何时是可读的呢？这时就需要用到NIO的新组件——Selector通道选择器</p>\n<p>简单地说：<strong>选择器的使命是完成IO的多路复用</strong>。一个通道代表一条连接，通过选择器可以同时监控多个通道的IO（输入输出）状况。选择器和通道的关系，是监控和被监控的关系。</p>\n</blockquote>\n<h4 id=\"Selector-选择器及注册\"><a href=\"#Selector-选择器及注册\" class=\"headerlink\" title=\"Selector 选择器及注册\"></a>Selector 选择器及注册</h4><p>​        通道和选择器之间的关系，通过<code>Channel.register（Selector sel, int ops）</code>方法完成，需要传入待注册的选择器实例和待监控事件类型。</p>\n<p>可供选择器监控的<strong>通道IO事件类型</strong>（就绪状态），包括以下四种：</p>\n<ol>\n<li>可读：SelectionKey.OP_READ</li>\n<li>可写：SelectionKey.OP_WRITE</li>\n<li>连接：SelectionKey.OP_CONNECT</li>\n<li>接收：SelectionKey.OP_ACCEPT</li>\n</ol>\n<p>事件类型的定义在SelectionKey类中。如果选择器要监控通道的多种事件，可以用“按位或”运算符来实现。例如，同时监控可读和可写IO事件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> key = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SelectableChannel-可选择通道\"><a href=\"#SelectableChannel-可选择通道\" class=\"headerlink\" title=\"SelectableChannel(可选择通道)\"></a>SelectableChannel(可选择通道)</h4><p>​        一条通道若能被选择，必须继承SelectableChannel类。所有网络链接Socket套接字通道，都继承了SelectableChannel类，都是可选择的。而FileChannel文件通道，并没有继承SelectableChannel，因此不是可选择通道。</p>\n<h4 id=\"SelectionKey-选择键\"><a href=\"#SelectionKey-选择键\" class=\"headerlink\" title=\"SelectionKey(选择键)\"></a>SelectionKey(选择键)</h4><p>​        一旦在通道中发生了某些IO事件（就绪状态达成），并且在选择器中注册过，就会被选择器选中，并放入SelectionKey的集合中。SelectionKey可以获得通道的IO事件类型，比方说SelectionKey.OP_READ，还可以获得发生IO事件所在的通道及选择器实例。</p>\n<h4 id=\"选择器的使用\"><a href=\"#选择器的使用\" class=\"headerlink\" title=\"选择器的使用\"></a>选择器的使用</h4><ol>\n<li><p><strong>获取选择器实例</strong></p>\n<p> ​        通过调用静态工厂方法open()来获取：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>\n\n<p> <em>open()的内部，是向选择器SPI（SelectorProvider）发出请求，通过默认的SPI对象，获取一个新的选择器实例。SPI全称为（Service Provider Interface，服务提供者接口），是JDK的一种可以扩展的服务提供和发现机制。Java通过SPI的方式，提供选择器的默认实现版本。也就是说，其他的服务提供商可以通过SPI的方式，提供定制化版本的选择器的动态替换或者扩展。</em></p>\n</li>\n<li><p><strong>将通道注册到选择器中</strong></p>\n<p> ​        需要注意：注册到选择器的通道，必须处于非阻塞模式下，否则将抛出IllegalBlockingModeException异常。并且一个通道，并不一定支持所有的四种IO事件。例如服务器监听通道ServerSocketChannel，仅支持Accept（接收到新连接）IO事件；而SocketChannel传输通道，则不支持Accept（接收到新连接）IO事件。可以在注册之前，通过通道的validOps()方法，来获取该通道所有支持的IO事件集合。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\"><span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 绑定连接</span></span><br><span class=\"line\">serverSocketChannel.bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">5252</span>));</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"服务器启动成功\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 将通道注册的“接收新连接”IO事件注册到选择器上</span></span><br><span class=\"line\">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>选出感兴趣的IO就绪事件（选择键集合）</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 轮询感兴趣的IO就绪事件（选择键集合）</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (selector.select() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取选择键集合</span></span><br><span class=\"line\">    Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (selectedKeys.hasNext()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取单个的选择键并处理</span></span><br><span class=\"line\">        SelectionKey selectedKey = selectedKeys.next();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedKey.isAcceptable()) &#123;</span><br><span class=\"line\">     \t\t<span class=\"comment\">// 通道有新连接</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isConnectalbe()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通道连接成功</span></span><br><span class=\"line\">        &#125;  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isReadalbe()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通道可读</span></span><br><span class=\"line\">        &#125;  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isWritalbe()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通道可写</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 处理完后移除选择键</span></span><br><span class=\"line\">        selectedKeys.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> SelectionKey集合不能添加元素，如果试图向SelectionKey选择键集合中添加元素，则将抛出java.lang.UnsupportedOperationException异常。</p>\n<p> select()方法有三个重载的实现版本，具体如下：</p>\n<ol>\n<li><p>select()：阻塞调用，一直到至少有一个通道发生了注册的IO事件。</p>\n</li>\n<li><p>select(long timeout)：和select()一样，但最长阻塞时间为timeout指定的毫秒数。</p>\n</li>\n<li><p>selectNow()：非阻塞，不管有没有IO事件，都会立刻返回。</p>\n<p>select()方法返回的整数值，表示从上一次select到这一次select之间，有多少<strong>通道</strong>发生了注册的IO事件。强调一下，select()方法返回的数量，指的是通道数，而不是IO事件数。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"实践案例\"><a href=\"#实践案例\" class=\"headerlink\" title=\"实践案例\"></a>实践案例</h4><p>使用NIO实现Discard服务器，Discard服务器的功能很简单，读取客户端通道的输入数据，读取完成后直接关闭客户端通道；并且读取到的数据直接抛弃掉。</p>\n<p><strong>服务器端：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用NIO实现Discard服务器端功能：</span></span><br><span class=\"line\"><span class=\"comment\"> *      仅读取客户端通道的输入数据，读取完成后直接关闭客户端通道，并且读取到的数据直接抛弃掉。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioDiscardServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startServer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取选择器</span></span><br><span class=\"line\">        Selector selector = Selector.open();</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\">        <span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">        serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 绑定连接</span></span><br><span class=\"line\">        serverSocketChannel.bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">5252</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"服务器启动成功\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 将通道注册的“接收新连接”IO事件注册到选择器上</span></span><br><span class=\"line\">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 轮询感兴趣的IO就绪事件（选择键集合）</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (selector.select() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取选择键集合</span></span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (selectedKeys.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取单个的选择键并处理</span></span><br><span class=\"line\">                SelectionKey selectedKey = selectedKeys.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (selectedKey.isAcceptable()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 若选择键的IO事件是“连接就绪”，就获取客户端连接</span></span><br><span class=\"line\">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class=\"line\">                    <span class=\"comment\">// 切换为非阻塞模式</span></span><br><span class=\"line\">                    socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 将新连接的通道可读事件注册到选择器上</span></span><br><span class=\"line\">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isReadable()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 若选择键的IO事件是“可读”，就读取数据</span></span><br><span class=\"line\">                    SocketChannel socketChannel = (SocketChannel) selectedKey.channel();</span><br><span class=\"line\">                    <span class=\"comment\">// 读取数据，然后丢弃</span></span><br><span class=\"line\">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 调用通道的read方法，从通道读取数据写入缓冲区，并返回读取到的数据</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> ((length = socketChannel.read(byteBuffer)) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        byteBuffer.flip();</span><br><span class=\"line\">                        System.out.println(<span class=\"keyword\">new</span> String(byteBuffer.array(), <span class=\"number\">0</span>, length));</span><br><span class=\"line\">                        byteBuffer.clear();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    socketChannel.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 移除选择键</span></span><br><span class=\"line\">                selectedKeys.remove();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\">        serverSocketChannel.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>客户端：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用NIO实现Discard客户端功能：</span></span><br><span class=\"line\"><span class=\"comment\"> *      客户端首先建立到服务器的连接，发送一些简单的数据，然后直接关闭连接。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioDiscardClient</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startClient</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        InetSocketAddress address = <span class=\"keyword\">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class=\"number\">5252</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        SocketChannel socketChannel = SocketChannel.open(address);</span><br><span class=\"line\">        <span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">        socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 不断自旋，等待连接完成</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!socketChannel.finishConnect()) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端连接成功\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 分配指定大小的缓冲区</span></span><br><span class=\"line\">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">        byteBuffer.put(<span class=\"string\">\"hello nio\"</span>.getBytes());</span><br><span class=\"line\">        byteBuffer.flip();</span><br><span class=\"line\">        <span class=\"comment\">// 发送到服务器</span></span><br><span class=\"line\">        socketChannel.write(byteBuffer);</span><br><span class=\"line\">        <span class=\"comment\">// 终止输出方法，向对方发送一个输出的结束标志</span></span><br><span class=\"line\">        socketChannel.shutdownOutput();</span><br><span class=\"line\">        <span class=\"comment\">// 关闭套接字连接</span></span><br><span class=\"line\">        socketChannel.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试：</strong></p>\n<p>​        先启动服务器，等到控制台出现“服务器启动成功”，再启动客户端，客户端连接成功后，发现服务器端出现“hello nio”则成功：</p>\n<p>服务器端：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">服务器启动成功</span><br></pre></td></tr></table></figure>\n\n<p>客户端：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端连接成功</span><br></pre></td></tr></table></figure>\n\n<p>服务器端：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">服务器启动成功</span></span><br><span class=\"line\"><span class=\"attr\">hello</span> <span class=\"string\">nio</span></span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"高并发利器Redis","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":null,"abbrlink":"a10a","subtitle":null,"_content":"\n\n\n### 一. 什么是Redis\n\n​\t\t官方简介：Redis是一个基于BSD**开源**的项目，是一个把**结构化**的数据放在**内存**中的一个存储系统，可以把它**作为数据库，缓存和消息中间件**来使用。同时支持**strings，lists，hashes，sets，sorted sets，**bitmaps，hyperloglogs、geospatial indexes和streams等**数据类型**。还内建了**复制、lua脚本、LRU、事务**、不同级别的**持久化**功能，通过redis sentinel实现**高可用**，通过redis cluster实现了**自动分片**，以及**发布/订阅**，**自动故障转移**等等特性。\n\n\n\n### 二. Redis能解决什么问题\n\n> **假如我们有个查询列表的API，用户抱怨说每次请求都要2秒左右才能返回结果，如何改善用户体验呢？**\n\n​\t\t**方案一、基于HTTP缓存**：\n\n​\t\t为API的响应头加上缓存控制 **cache-control**:max-age=600 ，即在浏览器缓存这个响应10分钟，简单粗暴。但是这个方法有两个缺点：第一个是在缓存生效的10分钟内，API消费者可能会得到旧的数据；第二个是如果客户端浏览器不使用缓存，方法直接无效。\n\n​\t\t**方案二、基于本机内存的缓存**\n\n​\t\t该API请求耗时操作主要在于使用SQL查询结果的过程中消耗了将近2秒的时间，于是，我们又想到了一个方案，把SQL查询的结果直接缓存在当前API服务器的内存中，比如使用JDK自带的**HashMap**和ConcurrentHashMap，或者**Guava Cache**、Spring Cache等本地缓存框架，设置缓存有效时间为10分钟，并且在修改和更新操作时同步修改缓存中的数据。这样后续10分钟内的请求直接读缓存，可以做到及时响应，不再花费2秒去执行SQL了。\n\n​\t\t结果其他API的小伙伴发现这是个好办法，于是很快我们就发现API服务器的内存要爆了...而且对于分布式架构，相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的。\n\n​\t\t**方案三、使用Redis做缓存**\n\n​\t\t要解决API服务器内存被缓存塞满及各服务间缓存无法共享的问题，最直接的办法就是把这些缓存部署在一台单独的服务器上，即使同一个相同的服务部署在再多机器上，也是使用的同一份缓存。于是我们需要为分布式缓存引入额外的服务，比如 Redis 或Memcached，而且要保证服务的高可用。\n\n#### Redis主要应用场景\n\n​\t\t缓存（数据查询、短连接、新闻内容、商品内容等）、分布式会话（Session）、任务队列（秒杀、抢购、12306等）、应用排行榜、访问统计、数据过期处理（可以精确到毫秒）。\n\n### 三. Redis 和 Memcached 的区别和共同点\n\n- **共同点** ：\n\n1. 都是基于内存的缓存。\n2. 都有过期策略。\n3. 两者的性能都非常高。\n\n- **区别** ：\n\n1. **Redis 支持更丰富的数据类型（支持更复杂的应用场景）**。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。\n2. **Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存之中。**\n3. **Redis 有灾难恢复机制。** 因为可以把缓存中的数据持久化到磁盘上。\n4. **Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。**\n5. **Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。**\n6. **Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。** （Redis 6.0 引入了多线程 IO ）\n7. **Redis 支持发布订阅模型、Lua脚本、事务等功能，而Memcached不支持。并且，Redis支持更多的编程语言。**\n\n\n\n### 四. 安装和配置\n\n#### 1. 安装：略\n\n#### 2. 主要配置：\n\n​\tLinux下配置文件为redis.conf，Windows下配置文件为redis.windows.conf\n\n- 开启持久化，配置文件装中添加如下内容：\n\n    ```\n    appendonly yes\n    ```\n\n- port：端口配置项，查看和设置Redis监听端口，默认端口为6379。\n- bind：主机地址配置项，查看和绑定的主机地址，默认地址的值为127.0.0.1。这个选项，在单网卡的机器上，一般不需要修改。\n\n- timeout：连接空闲多长要关闭连接，表示客户端闲置一段时间后，要关闭连接。如果指定为0，表示时长不限制。这个选项的默认值为0，表示默认不限制连接的空闲时长\n\n- dbfilename：指定保存缓存数据库的本地文件名，默认值为dump.rdb。\n\n- dir：指定保存缓存数据的本地文件所存放的目录，默认值为安装目录。\n\n- rdbcompression：指定存储至本地数据库时是否压缩数据，默认为yes,Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变得巨大。\n\n- save：指定在多长时间内，有多少次Key-Value更新操作，就将数据同步到本地数据库文件，可以设置多个条件。save配置项的格式为save<seconds><changes>:seconds表示时间段的长度，changes表示变化的次数。如设置为900秒（15分钟）内有1个更改，则同步到文件：\n\n    ```\n    127.0.0.1:6379> config set save \"900 1\"\n    OK\n    127.0.0.1:6379> config get save\n    1) \"save\"\n    2) \"900 1\"\n    ```\n\n- requirepass：设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认这个选项是关闭的。\n\n- slaveof：在主从复制的模式下，设置当前节点为slave（从）节点时，设置master（主）节点的IP地址及端口，在Redis启动时，它会自动从master（主）节点进行数据同步。如果已经是slave（从）服务器，则会丢掉旧数据集，从新的master主服务器同步缓存数据。格式为：\n\n    ```\n    slaveof<masterip><masterport>\n    ```\n\n- masterauth：在主从复制的模式下，当master（主）服务器节点设置了密码保护时，slave（从）服务器连接master（主）服务器的密码。格式为:\n\n    ```\n    masterauth<master-password>\n    ```\n\n- databases：设置缓存数据库的数量，默认数据库数量为16个。这16个数据库的id为0-15，默认使用的数据库是第0个。可以使用SELECT <dbid>命令在连接时通过数据库id来指定要使用的数据库。\n\n#### 3. Redis连接客户端命令：\n\n```\n#redis-cli -h host -p port -a password\n```\n\n本地连接：\n\n```\nroot@0912b31c4171# redis-cli\n```\n\n\n\n### 五. Redis的主要特点\n\n#### 1. 速度异常快 \n\n​\t\t采用多路 IO 复用模型，不需要等待磁盘的IO，在内存之间进行的数据存储和查询，速度非常快。官方数据显示每秒可执行大约 110000 次的设置(SET)操作，每秒大约可执行 81000 次的读取/获取(GET)操作。可以运行命令 `redis-benchmark -n 100000 -q` 来检测本地同时执行 10 万个请求时的性能：\n\n```\nroot@0912b31c4171:/data# redis-benchmark -n 100000 -q\nPING_INLINE: 31172.07 requests per second\nPING_BULK: 31615.55 requests per second\nSET: 30432.14 requests per second\nGET: 31289.11 requests per second\nINCR: 30441.40 requests per second\nLPUSH: 29550.83 requests per second\nRPUSH: 30184.12 requests per second\n```\n\n#### 2. 丰富的数据结构 \n\n​\t\t除了string之外，还有list、hash、set、sortedset、bitmaps、hyperloglogs、geospatial indexes和stream。其中**string(字符串)**、**list(列表)**、**hash(字典)**、**set(集合)** 和 **zset(有序集合)**这 5 种是 Redis 最基础、最重要的部分。\n\n#### 3. 单线程\n\n​\t\t避免了频繁的上下文切换。Redis 内部使用文件事件处理器 `file event handler`，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。\n\n文件事件处理器的结构包含 4 个部分：\n\n- 多个 socket\n\n- IO 多路复用程序\n\n- 文件事件分派器\n\n- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）\n\n    ​\t\t多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。\n\n    ***传统的并发模型，每个 I/O 流都有一个新的线程管理***\n\n     ***I/O 多路复用，只有单个线程，通过跟踪每个 I/O 流的状态，来管理多个 I/O 流。***\n\n#### 4. 可持久化 \n\n​\t\t支持RDB与AOF两种方式，将内存中的数据写入外部的物理存储设备。\n\n​\t\t**RDB**(Redis DataBase)：是最简单的 Redis 持久性模式。当满足特定条件时，它将生成数据集的时间点**快照**，例如，如果先前的快照是在2分钟前创建的，并且现在已经至少有 *100* 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 `.rdb` 文件生成。\n\n​\t\t**AOF** (Append Only File - 仅追加文件)：它的工作方式非常简单：每次执行 **修改内存** 中数据集的写操作时，都会 **记录** 该操作。假设 AOF 日志记录了自 Redis 实例创建以来 **所有的修改性指令序列**，那么就可以通过对一个空的 Redis 实例 **顺序执行所有的指令**，也就是 **「重放」**，来恢复 Redis 当前实例的内存数据结构的状态。\n\n​\t\t**RDB优势**\n\n- RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。\n\n- 生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。\n\n- RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。\n\n​\t\t**RDB劣势**\n\n- RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。\n\n​\t\t**AOF优势**\n\n- AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。（2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。\n\n- AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。\n\n- AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据\n\n​\t\t**AOF劣势**\n\n- 对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大\n\n- AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的\n\n- 以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。\n\n#### 5. 支持发布、订阅、管道。\n\n​\t\t**发布/ 订阅系统** 是 Web 系统中比较常用的一个功能。简单点说就是 **发布者发布消息，订阅者接受消息**，这有点类似于我们的报纸/ 杂志社之类的。我们可以使用redis的一个 `list` 列表结构结合 `lpush` 和 `rpop` 来实现消息队列的功能，但是似乎很难实现实现 **消息多播** 的功能：\n\n![image](https://tvax2.sinaimg.cn/large/006YzKDNly1gopdit62wmj30yg0ccgmp.jpg)\n\n​\t\t**Redis**为了消除`Publisher` 与 `Consumer` 的强关联，支持消息多播，引入了另一种概念：**频道** *(channel)*：\n\n![image](https://tvax1.sinaimg.cn/large/006YzKDNly1gopdjtvehij30yg0cbmy0.jpg)\n\n当 `Publisher` 往 `channel` 中发布消息时，关注了指定 `channel` 的 `Consumer` 就能够同时受到消息。但这里的 **问题** 是，消费者订阅一个频道是必须 **明确指定频道名称** 的，这意味着，如果我们想要 **订阅多个** 频道，那么就必须 **显式地关注多个** 名称。\n\n为了简化订阅的繁琐操作，**Redis** 提供了 **模式订阅** 的功能 **Pattern Subscribe**，这样就可以 **一次性关注多个频道** 了，即使生产者新增了同模式的频道，消费者也可以立即受到消息：\n\n![image](https://tvax2.sinaimg.cn/large/006YzKDNly1gopdkll7gtj30yg0cb0ul.jpg)\n\n例如上图中，**所有** 位于图片下方的 **`Consumer` 都能够受到消息**。\n\n`Publisher` 往 `wmyskxz.chat` 这个 `channel` 中发送了一条消息，不仅仅关注了这个频道的 `Consumer 1` 和 `Consumer 2` 能够受到消息，图片中的两个 `channel` 都和模式 `wmyskxz.*` 匹配，所以 **Redis** 此时会同样发送消息给订阅了 `wmyskxz.*` 这个模式的 `Consumer 3` 和关注了在这个模式下的另一个频道 `wmyskxz.log` 下的 `Consumer 4` 和 `Consumer 5`。\n\n另一方面，如果接收消息的频道是 `wmyskxz.chat`，那么 `Consumer 3` 也会受到消息。  \n\n##### *快速体验*\n\n在 **Redis** 中，**PubSub** 模块的使用非常简单，常用的命令也就下面这么几条：\n\n```bash\n# 订阅频道：\nSUBSCRIBE channel [channel ....]   # 订阅给定的一个或多个频道的信息\nPSUBSCRIBE pattern [pattern ....]  # 订阅一个或多个符合给定模式的频道\n# 发布频道：\nPUBLISH channel message  # 将消息发送到指定的频道\n# 退订频道：\nUNSUBSCRIBE [channel [channel ....]]   # 退订指定的频道\nPUNSUBSCRIBE [pattern [pattern ....]]  #退订所有给定模式的频道\n```\n\n我们可以在本地快速地来体验一下 **PubSub**：\n\n![](https://tvax2.sinaimg.cn/large/006YzKDNly1gopdlahl8sg30qq0cenpg.gif)\n\n具体步骤如下：\n\n1. 开启本地 Redis 服务，新建两个控制台窗口；\n2. 在其中一个窗口输入 `SUBSCRIBE wmyskxz.chat` 关注 `wmyskxz.chat` 频道，让这个窗口成为 **消费者**。\n3. 在另一个窗口输入 `PUBLISH wmyskxz.chat 'message'` 往这个频道发送消息，这个时候就会看到 **另一个窗口实时地出现** 了发送的测试消息。\n\n#### 6. 支持分布式锁 \n\n​\t\t在分布式系统中，如果不同的节点需要访同到一个资源，往往需要通过互斥机制来防止彼此干扰，并且保证数据的一致性。在这种情况下，需要使用到分布式锁。分布式锁和Java的锁用于实现不同线程之间的同步访问，原理上是类似的。\n\n#### 7.支持原子操作和事务\n\n​\t\tRedis事务是一组命令的集合。一个事务中的命令要么都执行，要么都不执行。如果命令在运行期间出现错误，不会自动回滚。\n\n#### 8.支持主-从（Master-Slave）复制与高可用（Redis Sentinel）集群\n\n​\t\t3.0版本以上功能\n\n\n\n### 六.常见数据结构及使用操作\n\n*一般情况下是这样设计 key 的： `表名:列名:主键名:主键值`*\n\n#### 1. string：\n\n> 值可以是任何种类的字符串（包括二进制数据），例如你可以在一个键下保存一张 `.jpeg` 图片，需要注意不要超过 512 MB 。\n\n- **设置和获取键值对**：\n\n```\n> SET key value\nOK\n> GET key\n\"value\"\n```\n\n当 key 存在时，`SET` 命令会覆盖掉你上一次设置的值：\n\n```\n> SET key newValue\nOK\n> GET key\n\"newValue\"\n```\n\n另外还可以使用 `EXISTS` 和 `DEL` 关键字来查询是否存在和删除键值对：\n\n```\n> EXISTS key\n(integer) 1\n> DEL key\n(integer) 1\n> GET key\n(nil)\n```\n\n- **批量设置键值对**\n\n```\n> SET key1 value1\nOK\n> SET key2 value2\nOK\n> MGET key1 key2 key3    # 返回一个列表\n1) \"value1\"\n2) \"value2\"\n3) (nil)\n> MSET key1 value1 key2 value2\n> MGET key1 key2\n1) \"value1\"\n2) \"value2\"\n```\n\n- **过期和 SET 命令扩展**\n\n可以对 key 设置过期时间，到时间会被自动删除，这个功能常用来控制缓存的失效时间。*(过期可以是任意数据结构)*\n\n```\n> SET key value1\n> GET key\n\"value1\"\n> EXPIRE name 5    # 5s 后过期\n...                # 等待 5s\n> GET key\n(nil)\n```\n\n等价于 `SET` + `EXPIRE` 的 `SETEX` 命令：\n\n```\n> SETEX key 5 value1\n...                # 等待 5s 后获取\n> GET key\n(nil)\n\n> SETNX key value1  # 如果 key 不存在则 SET 成功\n(integer) 1\n> SETNX key value1  # 如果 key 存在则 SET 失败\n(integer) 0\n> GET key\n\"value\"             # 没有改变 \n```\n\n- **计数**\n\n如果 value 是一个整数，还可以对它使用 `INCR` 命令进行 **原子性** 的自增操作，这意味着及时多个客户端对同一个 key 进行操作，也决不会导致竞争的情况：\n\n```\n> SET counter 100\n> INCR counter\n(integer) 101\n> INCRBY counter 50\n(integer) 151\n```\n\n#### 2. list\n\n> Redis 的列表相当于 Java 语言中的 **LinkedList**，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。\n\n**链表的基本操作**\n\n- `LPUSH` 和 `RPUSH` 分别可以向 list 的左边（头部）和右边（尾部）添加一个新元素；\n- `LRANGE` 命令可以从 list 中取出一定范围的元素；\n- `LINDEX` 命令可以从 list 中取出指定下表的元素，相当于 Java 链表操作中的 `get(int index)` 操作；\n\n示范：\n\n```console\n> rpush mylist A\n(integer) 1\n> rpush mylist B\n(integer) 2\n> lpush mylist first\n(integer) 3\n> lrange mylist 0 -1    # -1 表示倒数第一个元素, 这里表示从第一个元素到最后一个元素，即所有\n1) \"first\"\n2) \"A\"\n3) \"B\"\n```\n\n- list 实现队列\n\n队列是先进先出的数据结构，常用于消息排队和异步逻辑处理，它会确保元素的访问顺序：\n\n```console\n> RPUSH books python java golang\n(integer) 3\n> LPOP books\n\"python\"\n> LPOP books\n\"java\"\n> LPOP books\n\"golang\"\n> LPOP books\n(nil)\n```\n\n- list 实现栈\n\n栈是先进后出的数据结构，跟队列正好相反：\n\n```console\n> RPUSH books python java golang\n> RPOP books\n\"golang\"\n> RPOP books\n\"java\"\n> RPOP books\n\"python\"\n> RPOP books\n(nil)\n```\n\n- 使用场景举例：简单的消息队列、分页功能（lrange ）\n\n#### 3. hash\n\n> Redis 中的字典相当于 Java 中的 **HashMap**，内部实现也差不多类似，都是通过 **\"数组 + 链表\"** 的链地址法来解决部分 **哈希冲突**，同时这样的结构也吸收了两种不同数据结构的优点。\n\n- 基本操作：\n\n```\n> HSET books java \"think in java\"    # 命令行的字符串如果包含空格则需要使用引号包裹\n(integer) 1\n> HSET books python \"python cookbook\"\n(integer) 1\n> HGETALL books    # key 和 value 间隔出现\n1) \"java\"\n2) \"think in java\"\n3) \"python\"\n4) \"python cookbook\"\n> HGET books java\n\"think in java\"\n> HSET books java \"head first java\"  \n(integer) 0        # 因为是更新操作，所以返回 0\n> HMSET books java \"effetive  java\" python \"learning python\"    # 批量操作\nOK\n```\n\n- 使用场景举例：单点登录。存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果。\n\n#### 4. set\n\n> Redis 的集合相当于 Java 语言中的 **HashSet**，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。\n\n- 基本操作：\n\n```\n> SADD books java\n(integer) 1\n> SADD books java    # 重复\n(integer) 0\n> SADD books python golang\n(integer) 2\n> SMEMBERS books    # 注意顺序，set 是无序的 \n1) \"java\"\n2) \"python\"\n3) \"golang\"\n> SISMEMBER books java    # 查询某个 value 是否存在，相当于 contains\n(integer) 1\n> SCARD books    # 获取长度\n(integer) 3\n> SPOP books     # 弹出一个\n\"java\"\n```\n\n- 使用场景举例：全局去重、计算共同喜好等\n\n#### 5. zset\n\n> 这可能使 Redis 最具特色的一个数据结构了，它类似于 Java 中 **SortedSet** 和 **HashMap** 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。它的内部实现用的是一种叫做 **「跳跃表」** 的数据结构。\n\n- 基本操作\n\n```\n> ZADD books 9.0 \"think in java\"\n> ZADD books 8.9 \"java concurrency\"\n> ZADD books 8.6 \"java cookbook\"\n\n> ZRANGE books 0 -1     # 按 score 排序列出，参数区间为排名范围\n1) \"java cookbook\"\n2) \"java concurrency\"\n3) \"think in java\"\n\n> ZREVRANGE books 0 -1  # 按 score 逆序列出，参数区间为排名范围\n1) \"think in java\"\n2) \"java concurrency\"\n3) \"java cookbook\"\n\n> ZCARD books           # 相当于 count()\n(integer) 3\n\n> ZSCORE books \"java concurrency\"   # 获取指定 value 的 score\n\"8.9000000000000004\"                # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题\n\n> ZRANK books \"java concurrency\"    # 排名\n(integer) 1\n\n> ZRANGEBYSCORE books 0 8.91        # 根据分值区间遍历 zset\n1) \"java cookbook\"\n2) \"java concurrency\"\n\n> ZRANGEBYSCORE books -inf 8.91 withscores  # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite。\n1) \"java cookbook\"\n2) \"8.5999999999999996\"\n3) \"java concurrency\"\n4) \"8.9000000000000004\"\n\n> ZREM books \"java concurrency\"             # 删除 value\n(integer) 1\n> ZRANGE books 0 -1\n1) \"java cookbook\"\n2) \"think in java\"\n```\n\n- 使用场景举例：排行榜应用取 TOP N 、范围查找\n\n### 七. Redis常见问题及解决方法\n\n#### 1. 缓存与数据库双写不一致\n\n##### 什么是双写不一致？\n\n​\t\t一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是当要执行数据的更新操作的时候，数据库和缓存的数据就会出现不一致的情况。\n\n从理论上说，只要我们设置了**键的过期时间**，就能保证缓存和数据库的数据**最终一致**。\n\n##### 有哪些解决办法？\n\n- 先更新数据库，再删缓存。\n\n    如果在高并发的场景下，出现数据库与缓存数据不一致的**概率特别低**，也不是没有：\n\n    > 1、 缓存刚好失效\n    > 2、线程A查询数据库，得一个旧值\n    > 3、线程B将新值写入数据库\n    > 4、线程B删除缓存\n    > 5、线程A将查到的旧值写入缓存\n\n- 先删除缓存，再更新数据库。\n\n    并发场景下分析一下，还是有问题：\n\n    > 线程A删除了缓存\n    > 线程B查询，发现缓存已不存在\n    > 线程B去数据库查询得到旧值\n    > 线程B将旧值写入缓存\n    > 线程A将新值写入数据库\n\n- 将删除缓存、修改数据库、读取缓存等的操作积压到队列里边，实现串行化。\n\n这些方案从根本上来说，只能降低不一致发生的概率，无法完全避免。因此，**有强一致性要求的数据，不能放缓存。**\n\n#### 2. 缓存穿透\n\n##### 什么是缓存穿透？\n\n​\t\t缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：我们有一张数据库表，ID都是从1开始的，但是可能有黑客想把我们的数据库搞垮，每次请求的ID都是负数，导致缓存失去意义，请求都会去找数据库。\n\n##### 有哪些解决办法？\n\n1. 缓存无效 key\n\n    ​\t\t如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：`SET key value EX 10086`。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。如果用 Java 代码展示的话，差不多是下面这样的：\n\n```java\npublic Object getObjectInclNullById(Integer id) {\n    // 从缓存中获取数据\n    Object cacheValue = cache.get(id);\n    // 缓存为空\n    if (cacheValue == null) {\n        // 从数据库中获取\n        Object storageValue = storage.get(key);\n        // 缓存空对象\n        cache.set(key, storageValue);\n        // 如果存储数据为空，需要设置一个过期时间(300秒)\n        if (storageValue == null) {\n            // 必须设置过期时间，否则有被攻击的风险\n            cache.expire(key, 60 * 5);\n        }\n        return storageValue;\n    }\n    return cacheValue;\n}\n```\n\n2. 布隆过滤器\n\n    ​\t\t布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中，我们需要的就是判断 key 是否合法。\n\n    ​\t\t具体做法：内部维护一系列合法有效的 Key都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。\n\n    ​\t\t但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： **布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**\n\n    ****\n\n    ***布隆过滤器原理*：**  \n\n    **当一个元素加入布隆过滤器中的时候，会进行如下操作：**\n\n    1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。\n\n    2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。\n\n    **当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：**\n\n    1. 对给定元素再次进行相同的哈希计算；\n\n    2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。\n\n    然后，一定会出现这样一种情况：**不同的字符串可能哈希出来的位置相同。** （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）\n\n#### 3. 缓存雪崩\n\n##### 什么是缓存雪崩？\n\n​\t\t缓存雪崩描述的就是这样一个简单的场景：**缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。** 这就好比雪崩一样，数据库的压力可想而知，可能直接就挂了。\n\n​\t\t举个例子：系统的缓存模块出了问题比如宕机导致不可用，造成系统的所有访问，都要走数据库。\n\n​\t\t还有一种缓存雪崩的场景是：**有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。**\n\n​\t\t举个例子 ：秒杀开始12个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是12个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。\n\n##### 有哪些解决办法？\n\nRedis服务不可用：\n\n1. 采用Redis集群，避免单机出现问题整个缓存服务都没办法使用。\n2. 限流，避免同时处理大量的请求。\n\n热点缓存失效：\n\n1. 设置不同的失效时间，比如随机设置缓存的失效时间。\n2. 缓存永不失效。\n\n","source":"_posts/redis.md","raw":"---\ntitle: 高并发利器Redis\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop:\ntags:\n  - tools\ncategories:\n  - work\nabbrlink: a10a\nsubtitle:\n---\n\n\n\n### 一. 什么是Redis\n\n​\t\t官方简介：Redis是一个基于BSD**开源**的项目，是一个把**结构化**的数据放在**内存**中的一个存储系统，可以把它**作为数据库，缓存和消息中间件**来使用。同时支持**strings，lists，hashes，sets，sorted sets，**bitmaps，hyperloglogs、geospatial indexes和streams等**数据类型**。还内建了**复制、lua脚本、LRU、事务**、不同级别的**持久化**功能，通过redis sentinel实现**高可用**，通过redis cluster实现了**自动分片**，以及**发布/订阅**，**自动故障转移**等等特性。\n\n\n\n### 二. Redis能解决什么问题\n\n> **假如我们有个查询列表的API，用户抱怨说每次请求都要2秒左右才能返回结果，如何改善用户体验呢？**\n\n​\t\t**方案一、基于HTTP缓存**：\n\n​\t\t为API的响应头加上缓存控制 **cache-control**:max-age=600 ，即在浏览器缓存这个响应10分钟，简单粗暴。但是这个方法有两个缺点：第一个是在缓存生效的10分钟内，API消费者可能会得到旧的数据；第二个是如果客户端浏览器不使用缓存，方法直接无效。\n\n​\t\t**方案二、基于本机内存的缓存**\n\n​\t\t该API请求耗时操作主要在于使用SQL查询结果的过程中消耗了将近2秒的时间，于是，我们又想到了一个方案，把SQL查询的结果直接缓存在当前API服务器的内存中，比如使用JDK自带的**HashMap**和ConcurrentHashMap，或者**Guava Cache**、Spring Cache等本地缓存框架，设置缓存有效时间为10分钟，并且在修改和更新操作时同步修改缓存中的数据。这样后续10分钟内的请求直接读缓存，可以做到及时响应，不再花费2秒去执行SQL了。\n\n​\t\t结果其他API的小伙伴发现这是个好办法，于是很快我们就发现API服务器的内存要爆了...而且对于分布式架构，相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的。\n\n​\t\t**方案三、使用Redis做缓存**\n\n​\t\t要解决API服务器内存被缓存塞满及各服务间缓存无法共享的问题，最直接的办法就是把这些缓存部署在一台单独的服务器上，即使同一个相同的服务部署在再多机器上，也是使用的同一份缓存。于是我们需要为分布式缓存引入额外的服务，比如 Redis 或Memcached，而且要保证服务的高可用。\n\n#### Redis主要应用场景\n\n​\t\t缓存（数据查询、短连接、新闻内容、商品内容等）、分布式会话（Session）、任务队列（秒杀、抢购、12306等）、应用排行榜、访问统计、数据过期处理（可以精确到毫秒）。\n\n### 三. Redis 和 Memcached 的区别和共同点\n\n- **共同点** ：\n\n1. 都是基于内存的缓存。\n2. 都有过期策略。\n3. 两者的性能都非常高。\n\n- **区别** ：\n\n1. **Redis 支持更丰富的数据类型（支持更复杂的应用场景）**。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。\n2. **Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存之中。**\n3. **Redis 有灾难恢复机制。** 因为可以把缓存中的数据持久化到磁盘上。\n4. **Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。**\n5. **Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。**\n6. **Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。** （Redis 6.0 引入了多线程 IO ）\n7. **Redis 支持发布订阅模型、Lua脚本、事务等功能，而Memcached不支持。并且，Redis支持更多的编程语言。**\n\n\n\n### 四. 安装和配置\n\n#### 1. 安装：略\n\n#### 2. 主要配置：\n\n​\tLinux下配置文件为redis.conf，Windows下配置文件为redis.windows.conf\n\n- 开启持久化，配置文件装中添加如下内容：\n\n    ```\n    appendonly yes\n    ```\n\n- port：端口配置项，查看和设置Redis监听端口，默认端口为6379。\n- bind：主机地址配置项，查看和绑定的主机地址，默认地址的值为127.0.0.1。这个选项，在单网卡的机器上，一般不需要修改。\n\n- timeout：连接空闲多长要关闭连接，表示客户端闲置一段时间后，要关闭连接。如果指定为0，表示时长不限制。这个选项的默认值为0，表示默认不限制连接的空闲时长\n\n- dbfilename：指定保存缓存数据库的本地文件名，默认值为dump.rdb。\n\n- dir：指定保存缓存数据的本地文件所存放的目录，默认值为安装目录。\n\n- rdbcompression：指定存储至本地数据库时是否压缩数据，默认为yes,Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变得巨大。\n\n- save：指定在多长时间内，有多少次Key-Value更新操作，就将数据同步到本地数据库文件，可以设置多个条件。save配置项的格式为save<seconds><changes>:seconds表示时间段的长度，changes表示变化的次数。如设置为900秒（15分钟）内有1个更改，则同步到文件：\n\n    ```\n    127.0.0.1:6379> config set save \"900 1\"\n    OK\n    127.0.0.1:6379> config get save\n    1) \"save\"\n    2) \"900 1\"\n    ```\n\n- requirepass：设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认这个选项是关闭的。\n\n- slaveof：在主从复制的模式下，设置当前节点为slave（从）节点时，设置master（主）节点的IP地址及端口，在Redis启动时，它会自动从master（主）节点进行数据同步。如果已经是slave（从）服务器，则会丢掉旧数据集，从新的master主服务器同步缓存数据。格式为：\n\n    ```\n    slaveof<masterip><masterport>\n    ```\n\n- masterauth：在主从复制的模式下，当master（主）服务器节点设置了密码保护时，slave（从）服务器连接master（主）服务器的密码。格式为:\n\n    ```\n    masterauth<master-password>\n    ```\n\n- databases：设置缓存数据库的数量，默认数据库数量为16个。这16个数据库的id为0-15，默认使用的数据库是第0个。可以使用SELECT <dbid>命令在连接时通过数据库id来指定要使用的数据库。\n\n#### 3. Redis连接客户端命令：\n\n```\n#redis-cli -h host -p port -a password\n```\n\n本地连接：\n\n```\nroot@0912b31c4171# redis-cli\n```\n\n\n\n### 五. Redis的主要特点\n\n#### 1. 速度异常快 \n\n​\t\t采用多路 IO 复用模型，不需要等待磁盘的IO，在内存之间进行的数据存储和查询，速度非常快。官方数据显示每秒可执行大约 110000 次的设置(SET)操作，每秒大约可执行 81000 次的读取/获取(GET)操作。可以运行命令 `redis-benchmark -n 100000 -q` 来检测本地同时执行 10 万个请求时的性能：\n\n```\nroot@0912b31c4171:/data# redis-benchmark -n 100000 -q\nPING_INLINE: 31172.07 requests per second\nPING_BULK: 31615.55 requests per second\nSET: 30432.14 requests per second\nGET: 31289.11 requests per second\nINCR: 30441.40 requests per second\nLPUSH: 29550.83 requests per second\nRPUSH: 30184.12 requests per second\n```\n\n#### 2. 丰富的数据结构 \n\n​\t\t除了string之外，还有list、hash、set、sortedset、bitmaps、hyperloglogs、geospatial indexes和stream。其中**string(字符串)**、**list(列表)**、**hash(字典)**、**set(集合)** 和 **zset(有序集合)**这 5 种是 Redis 最基础、最重要的部分。\n\n#### 3. 单线程\n\n​\t\t避免了频繁的上下文切换。Redis 内部使用文件事件处理器 `file event handler`，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。\n\n文件事件处理器的结构包含 4 个部分：\n\n- 多个 socket\n\n- IO 多路复用程序\n\n- 文件事件分派器\n\n- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）\n\n    ​\t\t多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。\n\n    ***传统的并发模型，每个 I/O 流都有一个新的线程管理***\n\n     ***I/O 多路复用，只有单个线程，通过跟踪每个 I/O 流的状态，来管理多个 I/O 流。***\n\n#### 4. 可持久化 \n\n​\t\t支持RDB与AOF两种方式，将内存中的数据写入外部的物理存储设备。\n\n​\t\t**RDB**(Redis DataBase)：是最简单的 Redis 持久性模式。当满足特定条件时，它将生成数据集的时间点**快照**，例如，如果先前的快照是在2分钟前创建的，并且现在已经至少有 *100* 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 `.rdb` 文件生成。\n\n​\t\t**AOF** (Append Only File - 仅追加文件)：它的工作方式非常简单：每次执行 **修改内存** 中数据集的写操作时，都会 **记录** 该操作。假设 AOF 日志记录了自 Redis 实例创建以来 **所有的修改性指令序列**，那么就可以通过对一个空的 Redis 实例 **顺序执行所有的指令**，也就是 **「重放」**，来恢复 Redis 当前实例的内存数据结构的状态。\n\n​\t\t**RDB优势**\n\n- RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。\n\n- 生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。\n\n- RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。\n\n​\t\t**RDB劣势**\n\n- RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。\n\n​\t\t**AOF优势**\n\n- AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。（2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。\n\n- AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。\n\n- AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据\n\n​\t\t**AOF劣势**\n\n- 对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大\n\n- AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的\n\n- 以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。\n\n#### 5. 支持发布、订阅、管道。\n\n​\t\t**发布/ 订阅系统** 是 Web 系统中比较常用的一个功能。简单点说就是 **发布者发布消息，订阅者接受消息**，这有点类似于我们的报纸/ 杂志社之类的。我们可以使用redis的一个 `list` 列表结构结合 `lpush` 和 `rpop` 来实现消息队列的功能，但是似乎很难实现实现 **消息多播** 的功能：\n\n![image](https://tvax2.sinaimg.cn/large/006YzKDNly1gopdit62wmj30yg0ccgmp.jpg)\n\n​\t\t**Redis**为了消除`Publisher` 与 `Consumer` 的强关联，支持消息多播，引入了另一种概念：**频道** *(channel)*：\n\n![image](https://tvax1.sinaimg.cn/large/006YzKDNly1gopdjtvehij30yg0cbmy0.jpg)\n\n当 `Publisher` 往 `channel` 中发布消息时，关注了指定 `channel` 的 `Consumer` 就能够同时受到消息。但这里的 **问题** 是，消费者订阅一个频道是必须 **明确指定频道名称** 的，这意味着，如果我们想要 **订阅多个** 频道，那么就必须 **显式地关注多个** 名称。\n\n为了简化订阅的繁琐操作，**Redis** 提供了 **模式订阅** 的功能 **Pattern Subscribe**，这样就可以 **一次性关注多个频道** 了，即使生产者新增了同模式的频道，消费者也可以立即受到消息：\n\n![image](https://tvax2.sinaimg.cn/large/006YzKDNly1gopdkll7gtj30yg0cb0ul.jpg)\n\n例如上图中，**所有** 位于图片下方的 **`Consumer` 都能够受到消息**。\n\n`Publisher` 往 `wmyskxz.chat` 这个 `channel` 中发送了一条消息，不仅仅关注了这个频道的 `Consumer 1` 和 `Consumer 2` 能够受到消息，图片中的两个 `channel` 都和模式 `wmyskxz.*` 匹配，所以 **Redis** 此时会同样发送消息给订阅了 `wmyskxz.*` 这个模式的 `Consumer 3` 和关注了在这个模式下的另一个频道 `wmyskxz.log` 下的 `Consumer 4` 和 `Consumer 5`。\n\n另一方面，如果接收消息的频道是 `wmyskxz.chat`，那么 `Consumer 3` 也会受到消息。  \n\n##### *快速体验*\n\n在 **Redis** 中，**PubSub** 模块的使用非常简单，常用的命令也就下面这么几条：\n\n```bash\n# 订阅频道：\nSUBSCRIBE channel [channel ....]   # 订阅给定的一个或多个频道的信息\nPSUBSCRIBE pattern [pattern ....]  # 订阅一个或多个符合给定模式的频道\n# 发布频道：\nPUBLISH channel message  # 将消息发送到指定的频道\n# 退订频道：\nUNSUBSCRIBE [channel [channel ....]]   # 退订指定的频道\nPUNSUBSCRIBE [pattern [pattern ....]]  #退订所有给定模式的频道\n```\n\n我们可以在本地快速地来体验一下 **PubSub**：\n\n![](https://tvax2.sinaimg.cn/large/006YzKDNly1gopdlahl8sg30qq0cenpg.gif)\n\n具体步骤如下：\n\n1. 开启本地 Redis 服务，新建两个控制台窗口；\n2. 在其中一个窗口输入 `SUBSCRIBE wmyskxz.chat` 关注 `wmyskxz.chat` 频道，让这个窗口成为 **消费者**。\n3. 在另一个窗口输入 `PUBLISH wmyskxz.chat 'message'` 往这个频道发送消息，这个时候就会看到 **另一个窗口实时地出现** 了发送的测试消息。\n\n#### 6. 支持分布式锁 \n\n​\t\t在分布式系统中，如果不同的节点需要访同到一个资源，往往需要通过互斥机制来防止彼此干扰，并且保证数据的一致性。在这种情况下，需要使用到分布式锁。分布式锁和Java的锁用于实现不同线程之间的同步访问，原理上是类似的。\n\n#### 7.支持原子操作和事务\n\n​\t\tRedis事务是一组命令的集合。一个事务中的命令要么都执行，要么都不执行。如果命令在运行期间出现错误，不会自动回滚。\n\n#### 8.支持主-从（Master-Slave）复制与高可用（Redis Sentinel）集群\n\n​\t\t3.0版本以上功能\n\n\n\n### 六.常见数据结构及使用操作\n\n*一般情况下是这样设计 key 的： `表名:列名:主键名:主键值`*\n\n#### 1. string：\n\n> 值可以是任何种类的字符串（包括二进制数据），例如你可以在一个键下保存一张 `.jpeg` 图片，需要注意不要超过 512 MB 。\n\n- **设置和获取键值对**：\n\n```\n> SET key value\nOK\n> GET key\n\"value\"\n```\n\n当 key 存在时，`SET` 命令会覆盖掉你上一次设置的值：\n\n```\n> SET key newValue\nOK\n> GET key\n\"newValue\"\n```\n\n另外还可以使用 `EXISTS` 和 `DEL` 关键字来查询是否存在和删除键值对：\n\n```\n> EXISTS key\n(integer) 1\n> DEL key\n(integer) 1\n> GET key\n(nil)\n```\n\n- **批量设置键值对**\n\n```\n> SET key1 value1\nOK\n> SET key2 value2\nOK\n> MGET key1 key2 key3    # 返回一个列表\n1) \"value1\"\n2) \"value2\"\n3) (nil)\n> MSET key1 value1 key2 value2\n> MGET key1 key2\n1) \"value1\"\n2) \"value2\"\n```\n\n- **过期和 SET 命令扩展**\n\n可以对 key 设置过期时间，到时间会被自动删除，这个功能常用来控制缓存的失效时间。*(过期可以是任意数据结构)*\n\n```\n> SET key value1\n> GET key\n\"value1\"\n> EXPIRE name 5    # 5s 后过期\n...                # 等待 5s\n> GET key\n(nil)\n```\n\n等价于 `SET` + `EXPIRE` 的 `SETEX` 命令：\n\n```\n> SETEX key 5 value1\n...                # 等待 5s 后获取\n> GET key\n(nil)\n\n> SETNX key value1  # 如果 key 不存在则 SET 成功\n(integer) 1\n> SETNX key value1  # 如果 key 存在则 SET 失败\n(integer) 0\n> GET key\n\"value\"             # 没有改变 \n```\n\n- **计数**\n\n如果 value 是一个整数，还可以对它使用 `INCR` 命令进行 **原子性** 的自增操作，这意味着及时多个客户端对同一个 key 进行操作，也决不会导致竞争的情况：\n\n```\n> SET counter 100\n> INCR counter\n(integer) 101\n> INCRBY counter 50\n(integer) 151\n```\n\n#### 2. list\n\n> Redis 的列表相当于 Java 语言中的 **LinkedList**，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。\n\n**链表的基本操作**\n\n- `LPUSH` 和 `RPUSH` 分别可以向 list 的左边（头部）和右边（尾部）添加一个新元素；\n- `LRANGE` 命令可以从 list 中取出一定范围的元素；\n- `LINDEX` 命令可以从 list 中取出指定下表的元素，相当于 Java 链表操作中的 `get(int index)` 操作；\n\n示范：\n\n```console\n> rpush mylist A\n(integer) 1\n> rpush mylist B\n(integer) 2\n> lpush mylist first\n(integer) 3\n> lrange mylist 0 -1    # -1 表示倒数第一个元素, 这里表示从第一个元素到最后一个元素，即所有\n1) \"first\"\n2) \"A\"\n3) \"B\"\n```\n\n- list 实现队列\n\n队列是先进先出的数据结构，常用于消息排队和异步逻辑处理，它会确保元素的访问顺序：\n\n```console\n> RPUSH books python java golang\n(integer) 3\n> LPOP books\n\"python\"\n> LPOP books\n\"java\"\n> LPOP books\n\"golang\"\n> LPOP books\n(nil)\n```\n\n- list 实现栈\n\n栈是先进后出的数据结构，跟队列正好相反：\n\n```console\n> RPUSH books python java golang\n> RPOP books\n\"golang\"\n> RPOP books\n\"java\"\n> RPOP books\n\"python\"\n> RPOP books\n(nil)\n```\n\n- 使用场景举例：简单的消息队列、分页功能（lrange ）\n\n#### 3. hash\n\n> Redis 中的字典相当于 Java 中的 **HashMap**，内部实现也差不多类似，都是通过 **\"数组 + 链表\"** 的链地址法来解决部分 **哈希冲突**，同时这样的结构也吸收了两种不同数据结构的优点。\n\n- 基本操作：\n\n```\n> HSET books java \"think in java\"    # 命令行的字符串如果包含空格则需要使用引号包裹\n(integer) 1\n> HSET books python \"python cookbook\"\n(integer) 1\n> HGETALL books    # key 和 value 间隔出现\n1) \"java\"\n2) \"think in java\"\n3) \"python\"\n4) \"python cookbook\"\n> HGET books java\n\"think in java\"\n> HSET books java \"head first java\"  \n(integer) 0        # 因为是更新操作，所以返回 0\n> HMSET books java \"effetive  java\" python \"learning python\"    # 批量操作\nOK\n```\n\n- 使用场景举例：单点登录。存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果。\n\n#### 4. set\n\n> Redis 的集合相当于 Java 语言中的 **HashSet**，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。\n\n- 基本操作：\n\n```\n> SADD books java\n(integer) 1\n> SADD books java    # 重复\n(integer) 0\n> SADD books python golang\n(integer) 2\n> SMEMBERS books    # 注意顺序，set 是无序的 \n1) \"java\"\n2) \"python\"\n3) \"golang\"\n> SISMEMBER books java    # 查询某个 value 是否存在，相当于 contains\n(integer) 1\n> SCARD books    # 获取长度\n(integer) 3\n> SPOP books     # 弹出一个\n\"java\"\n```\n\n- 使用场景举例：全局去重、计算共同喜好等\n\n#### 5. zset\n\n> 这可能使 Redis 最具特色的一个数据结构了，它类似于 Java 中 **SortedSet** 和 **HashMap** 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。它的内部实现用的是一种叫做 **「跳跃表」** 的数据结构。\n\n- 基本操作\n\n```\n> ZADD books 9.0 \"think in java\"\n> ZADD books 8.9 \"java concurrency\"\n> ZADD books 8.6 \"java cookbook\"\n\n> ZRANGE books 0 -1     # 按 score 排序列出，参数区间为排名范围\n1) \"java cookbook\"\n2) \"java concurrency\"\n3) \"think in java\"\n\n> ZREVRANGE books 0 -1  # 按 score 逆序列出，参数区间为排名范围\n1) \"think in java\"\n2) \"java concurrency\"\n3) \"java cookbook\"\n\n> ZCARD books           # 相当于 count()\n(integer) 3\n\n> ZSCORE books \"java concurrency\"   # 获取指定 value 的 score\n\"8.9000000000000004\"                # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题\n\n> ZRANK books \"java concurrency\"    # 排名\n(integer) 1\n\n> ZRANGEBYSCORE books 0 8.91        # 根据分值区间遍历 zset\n1) \"java cookbook\"\n2) \"java concurrency\"\n\n> ZRANGEBYSCORE books -inf 8.91 withscores  # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite。\n1) \"java cookbook\"\n2) \"8.5999999999999996\"\n3) \"java concurrency\"\n4) \"8.9000000000000004\"\n\n> ZREM books \"java concurrency\"             # 删除 value\n(integer) 1\n> ZRANGE books 0 -1\n1) \"java cookbook\"\n2) \"think in java\"\n```\n\n- 使用场景举例：排行榜应用取 TOP N 、范围查找\n\n### 七. Redis常见问题及解决方法\n\n#### 1. 缓存与数据库双写不一致\n\n##### 什么是双写不一致？\n\n​\t\t一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是当要执行数据的更新操作的时候，数据库和缓存的数据就会出现不一致的情况。\n\n从理论上说，只要我们设置了**键的过期时间**，就能保证缓存和数据库的数据**最终一致**。\n\n##### 有哪些解决办法？\n\n- 先更新数据库，再删缓存。\n\n    如果在高并发的场景下，出现数据库与缓存数据不一致的**概率特别低**，也不是没有：\n\n    > 1、 缓存刚好失效\n    > 2、线程A查询数据库，得一个旧值\n    > 3、线程B将新值写入数据库\n    > 4、线程B删除缓存\n    > 5、线程A将查到的旧值写入缓存\n\n- 先删除缓存，再更新数据库。\n\n    并发场景下分析一下，还是有问题：\n\n    > 线程A删除了缓存\n    > 线程B查询，发现缓存已不存在\n    > 线程B去数据库查询得到旧值\n    > 线程B将旧值写入缓存\n    > 线程A将新值写入数据库\n\n- 将删除缓存、修改数据库、读取缓存等的操作积压到队列里边，实现串行化。\n\n这些方案从根本上来说，只能降低不一致发生的概率，无法完全避免。因此，**有强一致性要求的数据，不能放缓存。**\n\n#### 2. 缓存穿透\n\n##### 什么是缓存穿透？\n\n​\t\t缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：我们有一张数据库表，ID都是从1开始的，但是可能有黑客想把我们的数据库搞垮，每次请求的ID都是负数，导致缓存失去意义，请求都会去找数据库。\n\n##### 有哪些解决办法？\n\n1. 缓存无效 key\n\n    ​\t\t如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：`SET key value EX 10086`。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。如果用 Java 代码展示的话，差不多是下面这样的：\n\n```java\npublic Object getObjectInclNullById(Integer id) {\n    // 从缓存中获取数据\n    Object cacheValue = cache.get(id);\n    // 缓存为空\n    if (cacheValue == null) {\n        // 从数据库中获取\n        Object storageValue = storage.get(key);\n        // 缓存空对象\n        cache.set(key, storageValue);\n        // 如果存储数据为空，需要设置一个过期时间(300秒)\n        if (storageValue == null) {\n            // 必须设置过期时间，否则有被攻击的风险\n            cache.expire(key, 60 * 5);\n        }\n        return storageValue;\n    }\n    return cacheValue;\n}\n```\n\n2. 布隆过滤器\n\n    ​\t\t布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中，我们需要的就是判断 key 是否合法。\n\n    ​\t\t具体做法：内部维护一系列合法有效的 Key都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。\n\n    ​\t\t但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： **布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**\n\n    ****\n\n    ***布隆过滤器原理*：**  \n\n    **当一个元素加入布隆过滤器中的时候，会进行如下操作：**\n\n    1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。\n\n    2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。\n\n    **当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：**\n\n    1. 对给定元素再次进行相同的哈希计算；\n\n    2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。\n\n    然后，一定会出现这样一种情况：**不同的字符串可能哈希出来的位置相同。** （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）\n\n#### 3. 缓存雪崩\n\n##### 什么是缓存雪崩？\n\n​\t\t缓存雪崩描述的就是这样一个简单的场景：**缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。** 这就好比雪崩一样，数据库的压力可想而知，可能直接就挂了。\n\n​\t\t举个例子：系统的缓存模块出了问题比如宕机导致不可用，造成系统的所有访问，都要走数据库。\n\n​\t\t还有一种缓存雪崩的场景是：**有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。**\n\n​\t\t举个例子 ：秒杀开始12个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是12个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。\n\n##### 有哪些解决办法？\n\nRedis服务不可用：\n\n1. 采用Redis集群，避免单机出现问题整个缓存服务都没办法使用。\n2. 限流，避免同时处理大量的请求。\n\n热点缓存失效：\n\n1. 设置不同的失效时间，比如随机设置缓存的失效时间。\n2. 缓存永不失效。\n\n","slug":"redis","published":1,"date":"2021-03-18T09:35:34.120Z","updated":"2021-08-18T12:40:42.174Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshhgzjo0014iobf08vo10s6","content":"<h3 id=\"一-什么是Redis\"><a href=\"#一-什么是Redis\" class=\"headerlink\" title=\"一. 什么是Redis\"></a>一. 什么是Redis</h3><p>​        官方简介：Redis是一个基于BSD<strong>开源</strong>的项目，是一个把<strong>结构化</strong>的数据放在<strong>内存</strong>中的一个存储系统，可以把它<strong>作为数据库，缓存和消息中间件</strong>来使用。同时支持<strong>strings，lists，hashes，sets，sorted sets，</strong>bitmaps，hyperloglogs、geospatial indexes和streams等<strong>数据类型</strong>。还内建了<strong>复制、lua脚本、LRU、事务</strong>、不同级别的<strong>持久化</strong>功能，通过redis sentinel实现<strong>高可用</strong>，通过redis cluster实现了<strong>自动分片</strong>，以及<strong>发布/订阅</strong>，<strong>自动故障转移</strong>等等特性。</p>\n<h3 id=\"二-Redis能解决什么问题\"><a href=\"#二-Redis能解决什么问题\" class=\"headerlink\" title=\"二. Redis能解决什么问题\"></a>二. Redis能解决什么问题</h3><blockquote>\n<p><strong>假如我们有个查询列表的API，用户抱怨说每次请求都要2秒左右才能返回结果，如何改善用户体验呢？</strong></p>\n</blockquote>\n<p>​        <strong>方案一、基于HTTP缓存</strong>：</p>\n<p>​        为API的响应头加上缓存控制 <strong>cache-control</strong>:max-age=600 ，即在浏览器缓存这个响应10分钟，简单粗暴。但是这个方法有两个缺点：第一个是在缓存生效的10分钟内，API消费者可能会得到旧的数据；第二个是如果客户端浏览器不使用缓存，方法直接无效。</p>\n<p>​        <strong>方案二、基于本机内存的缓存</strong></p>\n<p>​        该API请求耗时操作主要在于使用SQL查询结果的过程中消耗了将近2秒的时间，于是，我们又想到了一个方案，把SQL查询的结果直接缓存在当前API服务器的内存中，比如使用JDK自带的<strong>HashMap</strong>和ConcurrentHashMap，或者<strong>Guava Cache</strong>、Spring Cache等本地缓存框架，设置缓存有效时间为10分钟，并且在修改和更新操作时同步修改缓存中的数据。这样后续10分钟内的请求直接读缓存，可以做到及时响应，不再花费2秒去执行SQL了。</p>\n<p>​        结果其他API的小伙伴发现这是个好办法，于是很快我们就发现API服务器的内存要爆了…而且对于分布式架构，相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的。</p>\n<p>​        <strong>方案三、使用Redis做缓存</strong></p>\n<p>​        要解决API服务器内存被缓存塞满及各服务间缓存无法共享的问题，最直接的办法就是把这些缓存部署在一台单独的服务器上，即使同一个相同的服务部署在再多机器上，也是使用的同一份缓存。于是我们需要为分布式缓存引入额外的服务，比如 Redis 或Memcached，而且要保证服务的高可用。</p>\n<h4 id=\"Redis主要应用场景\"><a href=\"#Redis主要应用场景\" class=\"headerlink\" title=\"Redis主要应用场景\"></a>Redis主要应用场景</h4><p>​        缓存（数据查询、短连接、新闻内容、商品内容等）、分布式会话（Session）、任务队列（秒杀、抢购、12306等）、应用排行榜、访问统计、数据过期处理（可以精确到毫秒）。</p>\n<h3 id=\"三-Redis-和-Memcached-的区别和共同点\"><a href=\"#三-Redis-和-Memcached-的区别和共同点\" class=\"headerlink\" title=\"三. Redis 和 Memcached 的区别和共同点\"></a>三. Redis 和 Memcached 的区别和共同点</h3><ul>\n<li><strong>共同点</strong> ：</li>\n</ul>\n<ol>\n<li>都是基于内存的缓存。</li>\n<li>都有过期策略。</li>\n<li>两者的性能都非常高。</li>\n</ol>\n<ul>\n<li><strong>区别</strong> ：</li>\n</ul>\n<ol>\n<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li>\n<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存之中。</strong></li>\n<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>\n<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>\n<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li>\n<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li>\n<li><strong>Redis 支持发布订阅模型、Lua脚本、事务等功能，而Memcached不支持。并且，Redis支持更多的编程语言。</strong></li>\n</ol>\n<h3 id=\"四-安装和配置\"><a href=\"#四-安装和配置\" class=\"headerlink\" title=\"四. 安装和配置\"></a>四. 安装和配置</h3><h4 id=\"1-安装：略\"><a href=\"#1-安装：略\" class=\"headerlink\" title=\"1. 安装：略\"></a>1. 安装：略</h4><h4 id=\"2-主要配置：\"><a href=\"#2-主要配置：\" class=\"headerlink\" title=\"2. 主要配置：\"></a>2. 主要配置：</h4><p>​    Linux下配置文件为redis.conf，Windows下配置文件为redis.windows.conf</p>\n<ul>\n<li><p>开启持久化，配置文件装中添加如下内容：</p>\n  <figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">appendonly</span> <span class=\"literal\">yes</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>port：端口配置项，查看和设置Redis监听端口，默认端口为6379。</p>\n</li>\n<li><p>bind：主机地址配置项，查看和绑定的主机地址，默认地址的值为127.0.0.1。这个选项，在单网卡的机器上，一般不需要修改。</p>\n</li>\n<li><p>timeout：连接空闲多长要关闭连接，表示客户端闲置一段时间后，要关闭连接。如果指定为0，表示时长不限制。这个选项的默认值为0，表示默认不限制连接的空闲时长</p>\n</li>\n<li><p>dbfilename：指定保存缓存数据库的本地文件名，默认值为dump.rdb。</p>\n</li>\n<li><p>dir：指定保存缓存数据的本地文件所存放的目录，默认值为安装目录。</p>\n</li>\n<li><p>rdbcompression：指定存储至本地数据库时是否压缩数据，默认为yes,Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变得巨大。</p>\n</li>\n<li><p>save：指定在多长时间内，有多少次Key-Value更新操作，就将数据同步到本地数据库文件，可以设置多个条件。save配置项的格式为save<seconds><changes>:seconds表示时间段的长度，changes表示变化的次数。如设置为900秒（15分钟）内有1个更改，则同步到文件：</p>\n  <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt;<span class=\"built_in\"> config </span><span class=\"builtin-name\">set</span> save <span class=\"string\">\"900 1\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt;<span class=\"built_in\"> config </span><span class=\"builtin-name\">get</span> save</span><br><span class=\"line\">1) <span class=\"string\">\"save\"</span></span><br><span class=\"line\">2) <span class=\"string\">\"900 1\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>requirepass：设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认这个选项是关闭的。</p>\n</li>\n<li><p>slaveof：在主从复制的模式下，设置当前节点为slave（从）节点时，设置master（主）节点的IP地址及端口，在Redis启动时，它会自动从master（主）节点进行数据同步。如果已经是slave（从）服务器，则会丢掉旧数据集，从新的master主服务器同步缓存数据。格式为：</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slaveof<span class=\"tag\">&lt;<span class=\"name\">masterip</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">masterport</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>masterauth：在主从复制的模式下，当master（主）服务器节点设置了密码保护时，slave（从）服务器连接master（主）服务器的密码。格式为:</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">masterauth<span class=\"tag\">&lt;<span class=\"name\">master-password</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>databases：设置缓存数据库的数量，默认数据库数量为16个。这16个数据库的id为0-15，默认使用的数据库是第0个。可以使用SELECT <dbid>命令在连接时通过数据库id来指定要使用的数据库。</p>\n</li>\n</ul>\n<h4 id=\"3-Redis连接客户端命令：\"><a href=\"#3-Redis连接客户端命令：\" class=\"headerlink\" title=\"3. Redis连接客户端命令：\"></a>3. Redis连接客户端命令：</h4><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#redis-cli</span> -h host -<span class=\"selector-tag\">p</span> port -<span class=\"selector-tag\">a</span> password</span><br></pre></td></tr></table></figure>\n\n<p>本地连接：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">root@</span><span class=\"number\">0912</span>b31c4171# redis-cli</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"五-Redis的主要特点\"><a href=\"#五-Redis的主要特点\" class=\"headerlink\" title=\"五. Redis的主要特点\"></a>五. Redis的主要特点</h3><h4 id=\"1-速度异常快\"><a href=\"#1-速度异常快\" class=\"headerlink\" title=\"1. 速度异常快\"></a>1. 速度异常快</h4><p>​        采用多路 IO 复用模型，不需要等待磁盘的IO，在内存之间进行的数据存储和查询，速度非常快。官方数据显示每秒可执行大约 110000 次的设置(SET)操作，每秒大约可执行 81000 次的读取/获取(GET)操作。可以运行命令 <code>redis-benchmark -n 100000 -q</code> 来检测本地同时执行 10 万个请求时的性能：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">root@0912b31c4171:/data#</span> <span class=\"string\">redis-benchmark</span> <span class=\"string\">-n</span> <span class=\"number\">100000</span> <span class=\"string\">-q</span></span><br><span class=\"line\"><span class=\"attr\">PING_INLINE:</span> <span class=\"number\">31172.07</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">PING_BULK:</span> <span class=\"number\">31615.55</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">SET:</span> <span class=\"number\">30432.14</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">GET:</span> <span class=\"number\">31289.11</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">INCR:</span> <span class=\"number\">30441.40</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">LPUSH:</span> <span class=\"number\">29550.83</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">RPUSH:</span> <span class=\"number\">30184.12</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-丰富的数据结构\"><a href=\"#2-丰富的数据结构\" class=\"headerlink\" title=\"2. 丰富的数据结构\"></a>2. 丰富的数据结构</h4><p>​        除了string之外，还有list、hash、set、sortedset、bitmaps、hyperloglogs、geospatial indexes和stream。其中<strong>string(字符串)</strong>、<strong>list(列表)</strong>、<strong>hash(字典)</strong>、<strong>set(集合)</strong> 和 <strong>zset(有序集合)</strong>这 5 种是 Redis 最基础、最重要的部分。</p>\n<h4 id=\"3-单线程\"><a href=\"#3-单线程\" class=\"headerlink\" title=\"3. 单线程\"></a>3. 单线程</h4><p>​        避免了频繁的上下文切换。Redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p>\n<p>文件事件处理器的结构包含 4 个部分：</p>\n<ul>\n<li><p>多个 socket</p>\n</li>\n<li><p>IO 多路复用程序</p>\n</li>\n<li><p>文件事件分派器</p>\n</li>\n<li><p>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</p>\n<p>  ​        多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>\n<p>  <strong><em>传统的并发模型，每个 I/O 流都有一个新的线程管理</em></strong></p>\n<p>   <strong><em>I/O 多路复用，只有单个线程，通过跟踪每个 I/O 流的状态，来管理多个 I/O 流。</em></strong></p>\n</li>\n</ul>\n<h4 id=\"4-可持久化\"><a href=\"#4-可持久化\" class=\"headerlink\" title=\"4. 可持久化\"></a>4. 可持久化</h4><p>​        支持RDB与AOF两种方式，将内存中的数据写入外部的物理存储设备。</p>\n<p>​        <strong>RDB</strong>(Redis DataBase)：是最简单的 Redis 持久性模式。当满足特定条件时，它将生成数据集的时间点<strong>快照</strong>，例如，如果先前的快照是在2分钟前创建的，并且现在已经至少有 <em>100</em> 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 <code>.rdb</code> 文件生成。</p>\n<p>​        <strong>AOF</strong> (Append Only File - 仅追加文件)：它的工作方式非常简单：每次执行 <strong>修改内存</strong> 中数据集的写操作时，都会 <strong>记录</strong> 该操作。假设 AOF 日志记录了自 Redis 实例创建以来 <strong>所有的修改性指令序列</strong>，那么就可以通过对一个空的 Redis 实例 <strong>顺序执行所有的指令</strong>，也就是 <strong>「重放」</strong>，来恢复 Redis 当前实例的内存数据结构的状态。</p>\n<p>​        <strong>RDB优势</strong></p>\n<ul>\n<li><p>RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</p>\n</li>\n<li><p>生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p>\n</li>\n<li><p>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p>\n</li>\n</ul>\n<p>​        <strong>RDB劣势</strong></p>\n<ul>\n<li>RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</li>\n</ul>\n<p>​        <strong>AOF优势</strong></p>\n<ul>\n<li><p>AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。（2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</p>\n</li>\n<li><p>AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</p>\n</li>\n<li><p>AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p>\n</li>\n</ul>\n<p>​        <strong>AOF劣势</strong></p>\n<ul>\n<li><p>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</p>\n</li>\n<li><p>AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</p>\n</li>\n<li><p>以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。</p>\n</li>\n</ul>\n<h4 id=\"5-支持发布、订阅、管道。\"><a href=\"#5-支持发布、订阅、管道。\" class=\"headerlink\" title=\"5. 支持发布、订阅、管道。\"></a>5. 支持发布、订阅、管道。</h4><p>​        <strong>发布/ 订阅系统</strong> 是 Web 系统中比较常用的一个功能。简单点说就是 <strong>发布者发布消息，订阅者接受消息</strong>，这有点类似于我们的报纸/ 杂志社之类的。我们可以使用redis的一个 <code>list</code> 列表结构结合 <code>lpush</code> 和 <code>rpop</code> 来实现消息队列的功能，但是似乎很难实现实现 <strong>消息多播</strong> 的功能：</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gopdit62wmj30yg0ccgmp.jpg\" alt=\"image\"></p>\n<p>​        <strong>Redis</strong>为了消除<code>Publisher</code> 与 <code>Consumer</code> 的强关联，支持消息多播，引入了另一种概念：<strong>频道</strong> <em>(channel)</em>：</p>\n<p><img src=\"https://tvax1.sinaimg.cn/large/006YzKDNly1gopdjtvehij30yg0cbmy0.jpg\" alt=\"image\"></p>\n<p>当 <code>Publisher</code> 往 <code>channel</code> 中发布消息时，关注了指定 <code>channel</code> 的 <code>Consumer</code> 就能够同时受到消息。但这里的 <strong>问题</strong> 是，消费者订阅一个频道是必须 <strong>明确指定频道名称</strong> 的，这意味着，如果我们想要 <strong>订阅多个</strong> 频道，那么就必须 <strong>显式地关注多个</strong> 名称。</p>\n<p>为了简化订阅的繁琐操作，<strong>Redis</strong> 提供了 <strong>模式订阅</strong> 的功能 <strong>Pattern Subscribe</strong>，这样就可以 <strong>一次性关注多个频道</strong> 了，即使生产者新增了同模式的频道，消费者也可以立即受到消息：</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gopdkll7gtj30yg0cb0ul.jpg\" alt=\"image\"></p>\n<p>例如上图中，<strong>所有</strong> 位于图片下方的 <strong><code>Consumer</code> 都能够受到消息</strong>。</p>\n<p><code>Publisher</code> 往 <code>wmyskxz.chat</code> 这个 <code>channel</code> 中发送了一条消息，不仅仅关注了这个频道的 <code>Consumer 1</code> 和 <code>Consumer 2</code> 能够受到消息，图片中的两个 <code>channel</code> 都和模式 <code>wmyskxz.*</code> 匹配，所以 <strong>Redis</strong> 此时会同样发送消息给订阅了 <code>wmyskxz.*</code> 这个模式的 <code>Consumer 3</code> 和关注了在这个模式下的另一个频道 <code>wmyskxz.log</code> 下的 <code>Consumer 4</code> 和 <code>Consumer 5</code>。</p>\n<p>另一方面，如果接收消息的频道是 <code>wmyskxz.chat</code>，那么 <code>Consumer 3</code> 也会受到消息。  </p>\n<h5 id=\"快速体验\"><a href=\"#快速体验\" class=\"headerlink\" title=\"快速体验\"></a><em>快速体验</em></h5><p>在 <strong>Redis</strong> 中，<strong>PubSub</strong> 模块的使用非常简单，常用的命令也就下面这么几条：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 订阅频道：</span></span><br><span class=\"line\">SUBSCRIBE channel [channel ....]   <span class=\"comment\"># 订阅给定的一个或多个频道的信息</span></span><br><span class=\"line\">PSUBSCRIBE pattern [pattern ....]  <span class=\"comment\"># 订阅一个或多个符合给定模式的频道</span></span><br><span class=\"line\"><span class=\"comment\"># 发布频道：</span></span><br><span class=\"line\">PUBLISH channel message  <span class=\"comment\"># 将消息发送到指定的频道</span></span><br><span class=\"line\"><span class=\"comment\"># 退订频道：</span></span><br><span class=\"line\">UNSUBSCRIBE [channel [channel ....]]   <span class=\"comment\"># 退订指定的频道</span></span><br><span class=\"line\">PUNSUBSCRIBE [pattern [pattern ....]]  <span class=\"comment\">#退订所有给定模式的频道</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以在本地快速地来体验一下 <strong>PubSub</strong>：</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gopdlahl8sg30qq0cenpg.gif\" alt=\"\"></p>\n<p>具体步骤如下：</p>\n<ol>\n<li>开启本地 Redis 服务，新建两个控制台窗口；</li>\n<li>在其中一个窗口输入 <code>SUBSCRIBE wmyskxz.chat</code> 关注 <code>wmyskxz.chat</code> 频道，让这个窗口成为 <strong>消费者</strong>。</li>\n<li>在另一个窗口输入 <code>PUBLISH wmyskxz.chat &#39;message&#39;</code> 往这个频道发送消息，这个时候就会看到 <strong>另一个窗口实时地出现</strong> 了发送的测试消息。</li>\n</ol>\n<h4 id=\"6-支持分布式锁\"><a href=\"#6-支持分布式锁\" class=\"headerlink\" title=\"6. 支持分布式锁\"></a>6. 支持分布式锁</h4><p>​        在分布式系统中，如果不同的节点需要访同到一个资源，往往需要通过互斥机制来防止彼此干扰，并且保证数据的一致性。在这种情况下，需要使用到分布式锁。分布式锁和Java的锁用于实现不同线程之间的同步访问，原理上是类似的。</p>\n<h4 id=\"7-支持原子操作和事务\"><a href=\"#7-支持原子操作和事务\" class=\"headerlink\" title=\"7.支持原子操作和事务\"></a>7.支持原子操作和事务</h4><p>​        Redis事务是一组命令的集合。一个事务中的命令要么都执行，要么都不执行。如果命令在运行期间出现错误，不会自动回滚。</p>\n<h4 id=\"8-支持主-从（Master-Slave）复制与高可用（Redis-Sentinel）集群\"><a href=\"#8-支持主-从（Master-Slave）复制与高可用（Redis-Sentinel）集群\" class=\"headerlink\" title=\"8.支持主-从（Master-Slave）复制与高可用（Redis Sentinel）集群\"></a>8.支持主-从（Master-Slave）复制与高可用（Redis Sentinel）集群</h4><p>​        3.0版本以上功能</p>\n<h3 id=\"六-常见数据结构及使用操作\"><a href=\"#六-常见数据结构及使用操作\" class=\"headerlink\" title=\"六.常见数据结构及使用操作\"></a>六.常见数据结构及使用操作</h3><p><em>一般情况下是这样设计 key 的： <code>表名:列名:主键名:主键值</code></em></p>\n<h4 id=\"1-string：\"><a href=\"#1-string：\" class=\"headerlink\" title=\"1. string：\"></a>1. string：</h4><blockquote>\n<p>值可以是任何种类的字符串（包括二进制数据），例如你可以在一个键下保存一张 <code>.jpeg</code> 图片，需要注意不要超过 512 MB 。</p>\n</blockquote>\n<ul>\n<li><strong>设置和获取键值对</strong>：</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"builtin-name\">SET</span> key value</span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; <span class=\"builtin-name\">GET</span> key</span><br><span class=\"line\"><span class=\"string\">\"value\"</span></span><br></pre></td></tr></table></figure>\n\n<p>当 key 存在时，<code>SET</code> 命令会覆盖掉你上一次设置的值：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"builtin-name\">SET</span> key newValue</span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; <span class=\"builtin-name\">GET</span> key</span><br><span class=\"line\"><span class=\"string\">\"newValue\"</span></span><br></pre></td></tr></table></figure>\n\n<p>另外还可以使用 <code>EXISTS</code> 和 <code>DEL</code> 关键字来查询是否存在和删除键值对：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; EXISTS <span class=\"type\">key</span></span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; DEL <span class=\"type\">key</span></span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; GET <span class=\"type\">key</span></span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>批量设置键值对</strong></li>\n</ul>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">SET</span> key1 <span class=\"comment\">value1</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; <span class=\"keyword\">SET</span> <span class=\"comment\">key2 value2</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; MGET <span class=\"comment\">key1 key2 key3    #</span> 返回一个列表</span><br><span class=\"line\">1) <span class=\"string\">\"value1\"</span></span><br><span class=\"line\">2) <span class=\"string\">\"value2\"</span></span><br><span class=\"line\">3) (nil)</span><br><span class=\"line\">&gt; MSET <span class=\"comment\">key1 value1 key2 value2</span></span><br><span class=\"line\">&gt; MGET <span class=\"comment\">key1 key2</span></span><br><span class=\"line\">1) <span class=\"string\">\"value1\"</span></span><br><span class=\"line\">2) <span class=\"string\">\"value2\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>过期和 SET 命令扩展</strong></li>\n</ul>\n<p>可以对 key 设置过期时间，到时间会被自动删除，这个功能常用来控制缓存的失效时间。<em>(过期可以是任意数据结构)</em></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"builtin-name\">SET</span> key value1</span><br><span class=\"line\">&gt; <span class=\"builtin-name\">GET</span> key</span><br><span class=\"line\"><span class=\"string\">\"value1\"</span></span><br><span class=\"line\">&gt; EXPIRE name 5    # 5s 后过期</span><br><span class=\"line\"><span class=\"built_in\">..</span>.                # 等待 5s</span><br><span class=\"line\">&gt; <span class=\"builtin-name\">GET</span> key</span><br><span class=\"line\">(<span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n\n<p>等价于 <code>SET</code> + <code>EXPIRE</code> 的 <code>SETEX</code> 命令：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SETEX <span class=\"type\">key</span> <span class=\"number\">5</span> value1</span><br><span class=\"line\">...                # 等待 <span class=\"number\">5</span>s 后获取</span><br><span class=\"line\">&gt; GET <span class=\"type\">key</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; SETNX <span class=\"type\">key</span> value1  # 如果 <span class=\"type\">key</span> 不存在则 SET 成功</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; SETNX <span class=\"type\">key</span> value1  # 如果 <span class=\"type\">key</span> 存在则 SET 失败</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">0</span></span><br><span class=\"line\">&gt; GET <span class=\"type\">key</span></span><br><span class=\"line\"><span class=\"string\">\"value\"</span>             # 没有改变</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>计数</strong></li>\n</ul>\n<p>如果 value 是一个整数，还可以对它使用 <code>INCR</code> 命令进行 <strong>原子性</strong> 的自增操作，这意味着及时多个客户端对同一个 key 进行操作，也决不会导致竞争的情况：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SET counter <span class=\"number\">100</span></span><br><span class=\"line\">&gt; INCR counter</span><br><span class=\"line\">(<span class=\"built_in\">int</span>eger) <span class=\"number\">101</span></span><br><span class=\"line\">&gt; INCRBY counter <span class=\"number\">50</span></span><br><span class=\"line\">(<span class=\"built_in\">int</span>eger) <span class=\"number\">151</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-list\"><a href=\"#2-list\" class=\"headerlink\" title=\"2. list\"></a>2. list</h4><blockquote>\n<p>Redis 的列表相当于 Java 语言中的 <strong>LinkedList</strong>，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。</p>\n</blockquote>\n<p><strong>链表的基本操作</strong></p>\n<ul>\n<li><code>LPUSH</code> 和 <code>RPUSH</code> 分别可以向 list 的左边（头部）和右边（尾部）添加一个新元素；</li>\n<li><code>LRANGE</code> 命令可以从 list 中取出一定范围的元素；</li>\n<li><code>LINDEX</code> 命令可以从 list 中取出指定下表的元素，相当于 Java 链表操作中的 <code>get(int index)</code> 操作；</li>\n</ul>\n<p>示范：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> rpush mylist A</span></span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> rpush mylist B</span></span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> lpush mylist first</span></span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> lrange mylist 0 -1    <span class=\"comment\"># -1 表示倒数第一个元素, 这里表示从第一个元素到最后一个元素，即所有</span></span></span><br><span class=\"line\">1) \"first\"</span><br><span class=\"line\">2) \"A\"</span><br><span class=\"line\">3) \"B\"</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>list 实现队列</li>\n</ul>\n<p>队列是先进先出的数据结构，常用于消息排队和异步逻辑处理，它会确保元素的访问顺序：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPUSH books python java golang</span></span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> LPOP books</span></span><br><span class=\"line\">\"python\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> LPOP books</span></span><br><span class=\"line\">\"java\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> LPOP books</span></span><br><span class=\"line\">\"golang\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> LPOP books</span></span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>list 实现栈</li>\n</ul>\n<p>栈是先进后出的数据结构，跟队列正好相反：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPUSH books python java golang</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPOP books</span></span><br><span class=\"line\">\"golang\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPOP books</span></span><br><span class=\"line\">\"java\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPOP books</span></span><br><span class=\"line\">\"python\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPOP books</span></span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用场景举例：简单的消息队列、分页功能（lrange ）</li>\n</ul>\n<h4 id=\"3-hash\"><a href=\"#3-hash\" class=\"headerlink\" title=\"3. hash\"></a>3. hash</h4><blockquote>\n<p>Redis 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，都是通过 <strong>“数组 + 链表”</strong> 的链地址法来解决部分 <strong>哈希冲突</strong>，同时这样的结构也吸收了两种不同数据结构的优点。</p>\n</blockquote>\n<ul>\n<li>基本操作：</li>\n</ul>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; HSET <span class=\"keyword\">books </span><span class=\"keyword\">java </span><span class=\"string\">\"think in java\"</span>    <span class=\"comment\"># 命令行的字符串如果包含空格则需要使用引号包裹</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; HSET <span class=\"keyword\">books </span>python <span class=\"string\">\"python cookbook\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; HGETALL <span class=\"keyword\">books </span>   <span class=\"comment\"># key 和 value 间隔出现</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"think in java\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"python\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"python cookbook\"</span></span><br><span class=\"line\">&gt; HGET <span class=\"keyword\">books </span><span class=\"keyword\">java</span></span><br><span class=\"line\"><span class=\"keyword\">\"think </span>in <span class=\"keyword\">java\"</span></span><br><span class=\"line\"><span class=\"keyword\">&gt; </span>HSET <span class=\"keyword\">books </span><span class=\"keyword\">java </span><span class=\"string\">\"head first java\"</span>  </span><br><span class=\"line\">(integer) <span class=\"number\">0</span>        <span class=\"comment\"># 因为是更新操作，所以返回 0</span></span><br><span class=\"line\">&gt; HMSET <span class=\"keyword\">books </span><span class=\"keyword\">java </span><span class=\"string\">\"effetive  java\"</span> python <span class=\"string\">\"learning python\"</span>    <span class=\"comment\"># 批量操作</span></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用场景举例：单点登录。存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果。</li>\n</ul>\n<h4 id=\"4-set\"><a href=\"#4-set\" class=\"headerlink\" title=\"4. set\"></a>4. set</h4><blockquote>\n<p>Redis 的集合相当于 Java 语言中的 <strong>HashSet</strong>，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。</p>\n</blockquote>\n<ul>\n<li>基本操作：</li>\n</ul>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SADD <span class=\"keyword\">books </span><span class=\"keyword\">java</span></span><br><span class=\"line\"><span class=\"keyword\">(integer) </span><span class=\"number\">1</span></span><br><span class=\"line\">&gt; SADD <span class=\"keyword\">books </span><span class=\"keyword\">java </span>   <span class=\"comment\"># 重复</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">&gt; SADD <span class=\"keyword\">books </span>python golang</span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">&gt; SMEMBERS <span class=\"keyword\">books </span>   <span class=\"comment\"># 注意顺序，set 是无序的 </span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"python\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"golang\"</span></span><br><span class=\"line\">&gt; SISMEMBER <span class=\"keyword\">books </span><span class=\"keyword\">java </span>   <span class=\"comment\"># 查询某个 value 是否存在，相当于 contains</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; <span class=\"keyword\">SCARD </span><span class=\"keyword\">books </span>   <span class=\"comment\"># 获取长度</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">&gt; SPOP <span class=\"keyword\">books </span>    <span class=\"comment\"># 弹出一个</span></span><br><span class=\"line\"><span class=\"string\">\"java\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用场景举例：全局去重、计算共同喜好等</li>\n</ul>\n<h4 id=\"5-zset\"><a href=\"#5-zset\" class=\"headerlink\" title=\"5. zset\"></a>5. zset</h4><blockquote>\n<p>这可能使 Redis 最具特色的一个数据结构了，它类似于 Java 中 <strong>SortedSet</strong> 和 <strong>HashMap</strong> 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。它的内部实现用的是一种叫做 <strong>「跳跃表」</strong> 的数据结构。</p>\n</blockquote>\n<ul>\n<li>基本操作</li>\n</ul>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ZADD books <span class=\"number\">9.0</span> <span class=\"string\">\"think in java\"</span></span><br><span class=\"line\">&gt; ZADD books <span class=\"number\">8.9</span> <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\">&gt; ZADD books <span class=\"number\">8.6</span> <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZRANGE books <span class=\"number\">0</span> <span class=\"number\">-1</span>     # 按 score 排序列出，参数区间为排名范围</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"think in java\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZREVRANGE books <span class=\"number\">0</span> <span class=\"number\">-1</span>  # 按 score 逆序列出，参数区间为排名范围</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"think in java\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZCARD books           # 相当于 count()</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZSCORE books <span class=\"string\">\"java concurrency\"</span>   # 获取指定 value 的 score</span><br><span class=\"line\"><span class=\"string\">\"8.9000000000000004\"</span>                # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZRANK books <span class=\"string\">\"java concurrency\"</span>    # 排名</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZRANGEBYSCORE books <span class=\"number\">0</span> <span class=\"number\">8.91</span>        # 根据分值区间遍历 zset</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZRANGEBYSCORE books -inf <span class=\"number\">8.91</span> withscores  # 根据分值区间 (-∞, <span class=\"number\">8.91</span>] 遍历 zset，同时返回分值。inf 代表 infinite。</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"8.5999999999999996\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"8.9000000000000004\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZREM books <span class=\"string\">\"java concurrency\"</span>             # 删除 value</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; ZRANGE books <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"think in java\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用场景举例：排行榜应用取 TOP N 、范围查找</li>\n</ul>\n<h3 id=\"七-Redis常见问题及解决方法\"><a href=\"#七-Redis常见问题及解决方法\" class=\"headerlink\" title=\"七. Redis常见问题及解决方法\"></a>七. Redis常见问题及解决方法</h3><h4 id=\"1-缓存与数据库双写不一致\"><a href=\"#1-缓存与数据库双写不一致\" class=\"headerlink\" title=\"1. 缓存与数据库双写不一致\"></a>1. 缓存与数据库双写不一致</h4><h5 id=\"什么是双写不一致？\"><a href=\"#什么是双写不一致？\" class=\"headerlink\" title=\"什么是双写不一致？\"></a>什么是双写不一致？</h5><p>​        一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是当要执行数据的更新操作的时候，数据库和缓存的数据就会出现不一致的情况。</p>\n<p>从理论上说，只要我们设置了<strong>键的过期时间</strong>，就能保证缓存和数据库的数据<strong>最终一致</strong>。</p>\n<h5 id=\"有哪些解决办法？\"><a href=\"#有哪些解决办法？\" class=\"headerlink\" title=\"有哪些解决办法？\"></a>有哪些解决办法？</h5><ul>\n<li><p>先更新数据库，再删缓存。</p>\n<p>  如果在高并发的场景下，出现数据库与缓存数据不一致的<strong>概率特别低</strong>，也不是没有：</p>\n<blockquote>\n<p>1、 缓存刚好失效<br>2、线程A查询数据库，得一个旧值<br>3、线程B将新值写入数据库<br>4、线程B删除缓存<br>5、线程A将查到的旧值写入缓存</p>\n</blockquote>\n</li>\n<li><p>先删除缓存，再更新数据库。</p>\n<p>  并发场景下分析一下，还是有问题：</p>\n<blockquote>\n<p>线程A删除了缓存<br>线程B查询，发现缓存已不存在<br>线程B去数据库查询得到旧值<br>线程B将旧值写入缓存<br>线程A将新值写入数据库</p>\n</blockquote>\n</li>\n<li><p>将删除缓存、修改数据库、读取缓存等的操作积压到队列里边，实现串行化。</p>\n</li>\n</ul>\n<p>这些方案从根本上来说，只能降低不一致发生的概率，无法完全避免。因此，<strong>有强一致性要求的数据，不能放缓存。</strong></p>\n<h4 id=\"2-缓存穿透\"><a href=\"#2-缓存穿透\" class=\"headerlink\" title=\"2. 缓存穿透\"></a>2. 缓存穿透</h4><h5 id=\"什么是缓存穿透？\"><a href=\"#什么是缓存穿透？\" class=\"headerlink\" title=\"什么是缓存穿透？\"></a>什么是缓存穿透？</h5><p>​        缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：我们有一张数据库表，ID都是从1开始的，但是可能有黑客想把我们的数据库搞垮，每次请求的ID都是负数，导致缓存失去意义，请求都会去找数据库。</p>\n<h5 id=\"有哪些解决办法？-1\"><a href=\"#有哪些解决办法？-1\" class=\"headerlink\" title=\"有哪些解决办法？\"></a>有哪些解决办法？</h5><ol>\n<li><p>缓存无效 key</p>\n<p> ​        如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code>。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。如果用 Java 代码展示的话，差不多是下面这样的：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObjectInclNullById</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从缓存中获取数据</span></span><br><span class=\"line\">    Object cacheValue = cache.get(id);</span><br><span class=\"line\">    <span class=\"comment\">// 缓存为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheValue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从数据库中获取</span></span><br><span class=\"line\">        Object storageValue = storage.get(key);</span><br><span class=\"line\">        <span class=\"comment\">// 缓存空对象</span></span><br><span class=\"line\">        cache.set(key, storageValue);</span><br><span class=\"line\">        <span class=\"comment\">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (storageValue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class=\"line\">            cache.expire(key, <span class=\"number\">60</span> * <span class=\"number\">5</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> storageValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cacheValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>布隆过滤器</p>\n<p> ​        布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中，我们需要的就是判断 key 是否合法。</p>\n<p> ​        具体做法：内部维护一系列合法有效的 Key都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>\n<p> ​        但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>\n<hr>\n<p> <strong><em>布隆过滤器原理</em>：</strong>  </p>\n<p> <strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>\n<ol>\n<li><p>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</p>\n</li>\n<li><p>根据得到的哈希值，在位数组中把对应下标的值置为 1。</p>\n</li>\n</ol>\n<p> <strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p>\n<ol>\n<li><p>对给定元素再次进行相同的哈希计算；</p>\n</li>\n<li><p>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>\n<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-缓存雪崩\"><a href=\"#3-缓存雪崩\" class=\"headerlink\" title=\"3. 缓存雪崩\"></a>3. 缓存雪崩</h4><h5 id=\"什么是缓存雪崩？\"><a href=\"#什么是缓存雪崩？\" class=\"headerlink\" title=\"什么是缓存雪崩？\"></a>什么是缓存雪崩？</h5><p>​        缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，数据库的压力可想而知，可能直接就挂了。</p>\n<p>​        举个例子：系统的缓存模块出了问题比如宕机导致不可用，造成系统的所有访问，都要走数据库。</p>\n<p>​        还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong></p>\n<p>​        举个例子 ：秒杀开始12个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是12个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p>\n<h5 id=\"有哪些解决办法？-2\"><a href=\"#有哪些解决办法？-2\" class=\"headerlink\" title=\"有哪些解决办法？\"></a>有哪些解决办法？</h5><p>Redis服务不可用：</p>\n<ol>\n<li>采用Redis集群，避免单机出现问题整个缓存服务都没办法使用。</li>\n<li>限流，避免同时处理大量的请求。</li>\n</ol>\n<p>热点缓存失效：</p>\n<ol>\n<li>设置不同的失效时间，比如随机设置缓存的失效时间。</li>\n<li>缓存永不失效。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一-什么是Redis\"><a href=\"#一-什么是Redis\" class=\"headerlink\" title=\"一. 什么是Redis\"></a>一. 什么是Redis</h3><p>​        官方简介：Redis是一个基于BSD<strong>开源</strong>的项目，是一个把<strong>结构化</strong>的数据放在<strong>内存</strong>中的一个存储系统，可以把它<strong>作为数据库，缓存和消息中间件</strong>来使用。同时支持<strong>strings，lists，hashes，sets，sorted sets，</strong>bitmaps，hyperloglogs、geospatial indexes和streams等<strong>数据类型</strong>。还内建了<strong>复制、lua脚本、LRU、事务</strong>、不同级别的<strong>持久化</strong>功能，通过redis sentinel实现<strong>高可用</strong>，通过redis cluster实现了<strong>自动分片</strong>，以及<strong>发布/订阅</strong>，<strong>自动故障转移</strong>等等特性。</p>\n<h3 id=\"二-Redis能解决什么问题\"><a href=\"#二-Redis能解决什么问题\" class=\"headerlink\" title=\"二. Redis能解决什么问题\"></a>二. Redis能解决什么问题</h3><blockquote>\n<p><strong>假如我们有个查询列表的API，用户抱怨说每次请求都要2秒左右才能返回结果，如何改善用户体验呢？</strong></p>\n</blockquote>\n<p>​        <strong>方案一、基于HTTP缓存</strong>：</p>\n<p>​        为API的响应头加上缓存控制 <strong>cache-control</strong>:max-age=600 ，即在浏览器缓存这个响应10分钟，简单粗暴。但是这个方法有两个缺点：第一个是在缓存生效的10分钟内，API消费者可能会得到旧的数据；第二个是如果客户端浏览器不使用缓存，方法直接无效。</p>\n<p>​        <strong>方案二、基于本机内存的缓存</strong></p>\n<p>​        该API请求耗时操作主要在于使用SQL查询结果的过程中消耗了将近2秒的时间，于是，我们又想到了一个方案，把SQL查询的结果直接缓存在当前API服务器的内存中，比如使用JDK自带的<strong>HashMap</strong>和ConcurrentHashMap，或者<strong>Guava Cache</strong>、Spring Cache等本地缓存框架，设置缓存有效时间为10分钟，并且在修改和更新操作时同步修改缓存中的数据。这样后续10分钟内的请求直接读缓存，可以做到及时响应，不再花费2秒去执行SQL了。</p>\n<p>​        结果其他API的小伙伴发现这是个好办法，于是很快我们就发现API服务器的内存要爆了…而且对于分布式架构，相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的。</p>\n<p>​        <strong>方案三、使用Redis做缓存</strong></p>\n<p>​        要解决API服务器内存被缓存塞满及各服务间缓存无法共享的问题，最直接的办法就是把这些缓存部署在一台单独的服务器上，即使同一个相同的服务部署在再多机器上，也是使用的同一份缓存。于是我们需要为分布式缓存引入额外的服务，比如 Redis 或Memcached，而且要保证服务的高可用。</p>\n<h4 id=\"Redis主要应用场景\"><a href=\"#Redis主要应用场景\" class=\"headerlink\" title=\"Redis主要应用场景\"></a>Redis主要应用场景</h4><p>​        缓存（数据查询、短连接、新闻内容、商品内容等）、分布式会话（Session）、任务队列（秒杀、抢购、12306等）、应用排行榜、访问统计、数据过期处理（可以精确到毫秒）。</p>\n<h3 id=\"三-Redis-和-Memcached-的区别和共同点\"><a href=\"#三-Redis-和-Memcached-的区别和共同点\" class=\"headerlink\" title=\"三. Redis 和 Memcached 的区别和共同点\"></a>三. Redis 和 Memcached 的区别和共同点</h3><ul>\n<li><strong>共同点</strong> ：</li>\n</ul>\n<ol>\n<li>都是基于内存的缓存。</li>\n<li>都有过期策略。</li>\n<li>两者的性能都非常高。</li>\n</ol>\n<ul>\n<li><strong>区别</strong> ：</li>\n</ul>\n<ol>\n<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li>\n<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存之中。</strong></li>\n<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>\n<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>\n<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li>\n<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li>\n<li><strong>Redis 支持发布订阅模型、Lua脚本、事务等功能，而Memcached不支持。并且，Redis支持更多的编程语言。</strong></li>\n</ol>\n<h3 id=\"四-安装和配置\"><a href=\"#四-安装和配置\" class=\"headerlink\" title=\"四. 安装和配置\"></a>四. 安装和配置</h3><h4 id=\"1-安装：略\"><a href=\"#1-安装：略\" class=\"headerlink\" title=\"1. 安装：略\"></a>1. 安装：略</h4><h4 id=\"2-主要配置：\"><a href=\"#2-主要配置：\" class=\"headerlink\" title=\"2. 主要配置：\"></a>2. 主要配置：</h4><p>​    Linux下配置文件为redis.conf，Windows下配置文件为redis.windows.conf</p>\n<ul>\n<li><p>开启持久化，配置文件装中添加如下内容：</p>\n  <figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">appendonly</span> <span class=\"literal\">yes</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>port：端口配置项，查看和设置Redis监听端口，默认端口为6379。</p>\n</li>\n<li><p>bind：主机地址配置项，查看和绑定的主机地址，默认地址的值为127.0.0.1。这个选项，在单网卡的机器上，一般不需要修改。</p>\n</li>\n<li><p>timeout：连接空闲多长要关闭连接，表示客户端闲置一段时间后，要关闭连接。如果指定为0，表示时长不限制。这个选项的默认值为0，表示默认不限制连接的空闲时长</p>\n</li>\n<li><p>dbfilename：指定保存缓存数据库的本地文件名，默认值为dump.rdb。</p>\n</li>\n<li><p>dir：指定保存缓存数据的本地文件所存放的目录，默认值为安装目录。</p>\n</li>\n<li><p>rdbcompression：指定存储至本地数据库时是否压缩数据，默认为yes,Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变得巨大。</p>\n</li>\n<li><p>save：指定在多长时间内，有多少次Key-Value更新操作，就将数据同步到本地数据库文件，可以设置多个条件。save配置项的格式为save<seconds><changes>:seconds表示时间段的长度，changes表示变化的次数。如设置为900秒（15分钟）内有1个更改，则同步到文件：</p>\n  <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt;<span class=\"built_in\"> config </span><span class=\"builtin-name\">set</span> save <span class=\"string\">\"900 1\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt;<span class=\"built_in\"> config </span><span class=\"builtin-name\">get</span> save</span><br><span class=\"line\">1) <span class=\"string\">\"save\"</span></span><br><span class=\"line\">2) <span class=\"string\">\"900 1\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>requirepass：设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认这个选项是关闭的。</p>\n</li>\n<li><p>slaveof：在主从复制的模式下，设置当前节点为slave（从）节点时，设置master（主）节点的IP地址及端口，在Redis启动时，它会自动从master（主）节点进行数据同步。如果已经是slave（从）服务器，则会丢掉旧数据集，从新的master主服务器同步缓存数据。格式为：</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slaveof<span class=\"tag\">&lt;<span class=\"name\">masterip</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">masterport</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>masterauth：在主从复制的模式下，当master（主）服务器节点设置了密码保护时，slave（从）服务器连接master（主）服务器的密码。格式为:</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">masterauth<span class=\"tag\">&lt;<span class=\"name\">master-password</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>databases：设置缓存数据库的数量，默认数据库数量为16个。这16个数据库的id为0-15，默认使用的数据库是第0个。可以使用SELECT <dbid>命令在连接时通过数据库id来指定要使用的数据库。</p>\n</li>\n</ul>\n<h4 id=\"3-Redis连接客户端命令：\"><a href=\"#3-Redis连接客户端命令：\" class=\"headerlink\" title=\"3. Redis连接客户端命令：\"></a>3. Redis连接客户端命令：</h4><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#redis-cli</span> -h host -<span class=\"selector-tag\">p</span> port -<span class=\"selector-tag\">a</span> password</span><br></pre></td></tr></table></figure>\n\n<p>本地连接：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">root@</span><span class=\"number\">0912</span>b31c4171# redis-cli</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"五-Redis的主要特点\"><a href=\"#五-Redis的主要特点\" class=\"headerlink\" title=\"五. Redis的主要特点\"></a>五. Redis的主要特点</h3><h4 id=\"1-速度异常快\"><a href=\"#1-速度异常快\" class=\"headerlink\" title=\"1. 速度异常快\"></a>1. 速度异常快</h4><p>​        采用多路 IO 复用模型，不需要等待磁盘的IO，在内存之间进行的数据存储和查询，速度非常快。官方数据显示每秒可执行大约 110000 次的设置(SET)操作，每秒大约可执行 81000 次的读取/获取(GET)操作。可以运行命令 <code>redis-benchmark -n 100000 -q</code> 来检测本地同时执行 10 万个请求时的性能：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">root@0912b31c4171:/data#</span> <span class=\"string\">redis-benchmark</span> <span class=\"string\">-n</span> <span class=\"number\">100000</span> <span class=\"string\">-q</span></span><br><span class=\"line\"><span class=\"attr\">PING_INLINE:</span> <span class=\"number\">31172.07</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">PING_BULK:</span> <span class=\"number\">31615.55</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">SET:</span> <span class=\"number\">30432.14</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">GET:</span> <span class=\"number\">31289.11</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">INCR:</span> <span class=\"number\">30441.40</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">LPUSH:</span> <span class=\"number\">29550.83</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">RPUSH:</span> <span class=\"number\">30184.12</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-丰富的数据结构\"><a href=\"#2-丰富的数据结构\" class=\"headerlink\" title=\"2. 丰富的数据结构\"></a>2. 丰富的数据结构</h4><p>​        除了string之外，还有list、hash、set、sortedset、bitmaps、hyperloglogs、geospatial indexes和stream。其中<strong>string(字符串)</strong>、<strong>list(列表)</strong>、<strong>hash(字典)</strong>、<strong>set(集合)</strong> 和 <strong>zset(有序集合)</strong>这 5 种是 Redis 最基础、最重要的部分。</p>\n<h4 id=\"3-单线程\"><a href=\"#3-单线程\" class=\"headerlink\" title=\"3. 单线程\"></a>3. 单线程</h4><p>​        避免了频繁的上下文切换。Redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p>\n<p>文件事件处理器的结构包含 4 个部分：</p>\n<ul>\n<li><p>多个 socket</p>\n</li>\n<li><p>IO 多路复用程序</p>\n</li>\n<li><p>文件事件分派器</p>\n</li>\n<li><p>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</p>\n<p>  ​        多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>\n<p>  <strong><em>传统的并发模型，每个 I/O 流都有一个新的线程管理</em></strong></p>\n<p>   <strong><em>I/O 多路复用，只有单个线程，通过跟踪每个 I/O 流的状态，来管理多个 I/O 流。</em></strong></p>\n</li>\n</ul>\n<h4 id=\"4-可持久化\"><a href=\"#4-可持久化\" class=\"headerlink\" title=\"4. 可持久化\"></a>4. 可持久化</h4><p>​        支持RDB与AOF两种方式，将内存中的数据写入外部的物理存储设备。</p>\n<p>​        <strong>RDB</strong>(Redis DataBase)：是最简单的 Redis 持久性模式。当满足特定条件时，它将生成数据集的时间点<strong>快照</strong>，例如，如果先前的快照是在2分钟前创建的，并且现在已经至少有 <em>100</em> 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 <code>.rdb</code> 文件生成。</p>\n<p>​        <strong>AOF</strong> (Append Only File - 仅追加文件)：它的工作方式非常简单：每次执行 <strong>修改内存</strong> 中数据集的写操作时，都会 <strong>记录</strong> 该操作。假设 AOF 日志记录了自 Redis 实例创建以来 <strong>所有的修改性指令序列</strong>，那么就可以通过对一个空的 Redis 实例 <strong>顺序执行所有的指令</strong>，也就是 <strong>「重放」</strong>，来恢复 Redis 当前实例的内存数据结构的状态。</p>\n<p>​        <strong>RDB优势</strong></p>\n<ul>\n<li><p>RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</p>\n</li>\n<li><p>生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p>\n</li>\n<li><p>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p>\n</li>\n</ul>\n<p>​        <strong>RDB劣势</strong></p>\n<ul>\n<li>RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</li>\n</ul>\n<p>​        <strong>AOF优势</strong></p>\n<ul>\n<li><p>AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。（2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</p>\n</li>\n<li><p>AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</p>\n</li>\n<li><p>AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p>\n</li>\n</ul>\n<p>​        <strong>AOF劣势</strong></p>\n<ul>\n<li><p>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</p>\n</li>\n<li><p>AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</p>\n</li>\n<li><p>以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。</p>\n</li>\n</ul>\n<h4 id=\"5-支持发布、订阅、管道。\"><a href=\"#5-支持发布、订阅、管道。\" class=\"headerlink\" title=\"5. 支持发布、订阅、管道。\"></a>5. 支持发布、订阅、管道。</h4><p>​        <strong>发布/ 订阅系统</strong> 是 Web 系统中比较常用的一个功能。简单点说就是 <strong>发布者发布消息，订阅者接受消息</strong>，这有点类似于我们的报纸/ 杂志社之类的。我们可以使用redis的一个 <code>list</code> 列表结构结合 <code>lpush</code> 和 <code>rpop</code> 来实现消息队列的功能，但是似乎很难实现实现 <strong>消息多播</strong> 的功能：</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gopdit62wmj30yg0ccgmp.jpg\" alt=\"image\"></p>\n<p>​        <strong>Redis</strong>为了消除<code>Publisher</code> 与 <code>Consumer</code> 的强关联，支持消息多播，引入了另一种概念：<strong>频道</strong> <em>(channel)</em>：</p>\n<p><img src=\"https://tvax1.sinaimg.cn/large/006YzKDNly1gopdjtvehij30yg0cbmy0.jpg\" alt=\"image\"></p>\n<p>当 <code>Publisher</code> 往 <code>channel</code> 中发布消息时，关注了指定 <code>channel</code> 的 <code>Consumer</code> 就能够同时受到消息。但这里的 <strong>问题</strong> 是，消费者订阅一个频道是必须 <strong>明确指定频道名称</strong> 的，这意味着，如果我们想要 <strong>订阅多个</strong> 频道，那么就必须 <strong>显式地关注多个</strong> 名称。</p>\n<p>为了简化订阅的繁琐操作，<strong>Redis</strong> 提供了 <strong>模式订阅</strong> 的功能 <strong>Pattern Subscribe</strong>，这样就可以 <strong>一次性关注多个频道</strong> 了，即使生产者新增了同模式的频道，消费者也可以立即受到消息：</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gopdkll7gtj30yg0cb0ul.jpg\" alt=\"image\"></p>\n<p>例如上图中，<strong>所有</strong> 位于图片下方的 <strong><code>Consumer</code> 都能够受到消息</strong>。</p>\n<p><code>Publisher</code> 往 <code>wmyskxz.chat</code> 这个 <code>channel</code> 中发送了一条消息，不仅仅关注了这个频道的 <code>Consumer 1</code> 和 <code>Consumer 2</code> 能够受到消息，图片中的两个 <code>channel</code> 都和模式 <code>wmyskxz.*</code> 匹配，所以 <strong>Redis</strong> 此时会同样发送消息给订阅了 <code>wmyskxz.*</code> 这个模式的 <code>Consumer 3</code> 和关注了在这个模式下的另一个频道 <code>wmyskxz.log</code> 下的 <code>Consumer 4</code> 和 <code>Consumer 5</code>。</p>\n<p>另一方面，如果接收消息的频道是 <code>wmyskxz.chat</code>，那么 <code>Consumer 3</code> 也会受到消息。  </p>\n<h5 id=\"快速体验\"><a href=\"#快速体验\" class=\"headerlink\" title=\"快速体验\"></a><em>快速体验</em></h5><p>在 <strong>Redis</strong> 中，<strong>PubSub</strong> 模块的使用非常简单，常用的命令也就下面这么几条：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 订阅频道：</span></span><br><span class=\"line\">SUBSCRIBE channel [channel ....]   <span class=\"comment\"># 订阅给定的一个或多个频道的信息</span></span><br><span class=\"line\">PSUBSCRIBE pattern [pattern ....]  <span class=\"comment\"># 订阅一个或多个符合给定模式的频道</span></span><br><span class=\"line\"><span class=\"comment\"># 发布频道：</span></span><br><span class=\"line\">PUBLISH channel message  <span class=\"comment\"># 将消息发送到指定的频道</span></span><br><span class=\"line\"><span class=\"comment\"># 退订频道：</span></span><br><span class=\"line\">UNSUBSCRIBE [channel [channel ....]]   <span class=\"comment\"># 退订指定的频道</span></span><br><span class=\"line\">PUNSUBSCRIBE [pattern [pattern ....]]  <span class=\"comment\">#退订所有给定模式的频道</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以在本地快速地来体验一下 <strong>PubSub</strong>：</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gopdlahl8sg30qq0cenpg.gif\" alt=\"\"></p>\n<p>具体步骤如下：</p>\n<ol>\n<li>开启本地 Redis 服务，新建两个控制台窗口；</li>\n<li>在其中一个窗口输入 <code>SUBSCRIBE wmyskxz.chat</code> 关注 <code>wmyskxz.chat</code> 频道，让这个窗口成为 <strong>消费者</strong>。</li>\n<li>在另一个窗口输入 <code>PUBLISH wmyskxz.chat &#39;message&#39;</code> 往这个频道发送消息，这个时候就会看到 <strong>另一个窗口实时地出现</strong> 了发送的测试消息。</li>\n</ol>\n<h4 id=\"6-支持分布式锁\"><a href=\"#6-支持分布式锁\" class=\"headerlink\" title=\"6. 支持分布式锁\"></a>6. 支持分布式锁</h4><p>​        在分布式系统中，如果不同的节点需要访同到一个资源，往往需要通过互斥机制来防止彼此干扰，并且保证数据的一致性。在这种情况下，需要使用到分布式锁。分布式锁和Java的锁用于实现不同线程之间的同步访问，原理上是类似的。</p>\n<h4 id=\"7-支持原子操作和事务\"><a href=\"#7-支持原子操作和事务\" class=\"headerlink\" title=\"7.支持原子操作和事务\"></a>7.支持原子操作和事务</h4><p>​        Redis事务是一组命令的集合。一个事务中的命令要么都执行，要么都不执行。如果命令在运行期间出现错误，不会自动回滚。</p>\n<h4 id=\"8-支持主-从（Master-Slave）复制与高可用（Redis-Sentinel）集群\"><a href=\"#8-支持主-从（Master-Slave）复制与高可用（Redis-Sentinel）集群\" class=\"headerlink\" title=\"8.支持主-从（Master-Slave）复制与高可用（Redis Sentinel）集群\"></a>8.支持主-从（Master-Slave）复制与高可用（Redis Sentinel）集群</h4><p>​        3.0版本以上功能</p>\n<h3 id=\"六-常见数据结构及使用操作\"><a href=\"#六-常见数据结构及使用操作\" class=\"headerlink\" title=\"六.常见数据结构及使用操作\"></a>六.常见数据结构及使用操作</h3><p><em>一般情况下是这样设计 key 的： <code>表名:列名:主键名:主键值</code></em></p>\n<h4 id=\"1-string：\"><a href=\"#1-string：\" class=\"headerlink\" title=\"1. string：\"></a>1. string：</h4><blockquote>\n<p>值可以是任何种类的字符串（包括二进制数据），例如你可以在一个键下保存一张 <code>.jpeg</code> 图片，需要注意不要超过 512 MB 。</p>\n</blockquote>\n<ul>\n<li><strong>设置和获取键值对</strong>：</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"builtin-name\">SET</span> key value</span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; <span class=\"builtin-name\">GET</span> key</span><br><span class=\"line\"><span class=\"string\">\"value\"</span></span><br></pre></td></tr></table></figure>\n\n<p>当 key 存在时，<code>SET</code> 命令会覆盖掉你上一次设置的值：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"builtin-name\">SET</span> key newValue</span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; <span class=\"builtin-name\">GET</span> key</span><br><span class=\"line\"><span class=\"string\">\"newValue\"</span></span><br></pre></td></tr></table></figure>\n\n<p>另外还可以使用 <code>EXISTS</code> 和 <code>DEL</code> 关键字来查询是否存在和删除键值对：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; EXISTS <span class=\"type\">key</span></span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; DEL <span class=\"type\">key</span></span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; GET <span class=\"type\">key</span></span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>批量设置键值对</strong></li>\n</ul>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">SET</span> key1 <span class=\"comment\">value1</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; <span class=\"keyword\">SET</span> <span class=\"comment\">key2 value2</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; MGET <span class=\"comment\">key1 key2 key3    #</span> 返回一个列表</span><br><span class=\"line\">1) <span class=\"string\">\"value1\"</span></span><br><span class=\"line\">2) <span class=\"string\">\"value2\"</span></span><br><span class=\"line\">3) (nil)</span><br><span class=\"line\">&gt; MSET <span class=\"comment\">key1 value1 key2 value2</span></span><br><span class=\"line\">&gt; MGET <span class=\"comment\">key1 key2</span></span><br><span class=\"line\">1) <span class=\"string\">\"value1\"</span></span><br><span class=\"line\">2) <span class=\"string\">\"value2\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>过期和 SET 命令扩展</strong></li>\n</ul>\n<p>可以对 key 设置过期时间，到时间会被自动删除，这个功能常用来控制缓存的失效时间。<em>(过期可以是任意数据结构)</em></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"builtin-name\">SET</span> key value1</span><br><span class=\"line\">&gt; <span class=\"builtin-name\">GET</span> key</span><br><span class=\"line\"><span class=\"string\">\"value1\"</span></span><br><span class=\"line\">&gt; EXPIRE name 5    # 5s 后过期</span><br><span class=\"line\"><span class=\"built_in\">..</span>.                # 等待 5s</span><br><span class=\"line\">&gt; <span class=\"builtin-name\">GET</span> key</span><br><span class=\"line\">(<span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n\n<p>等价于 <code>SET</code> + <code>EXPIRE</code> 的 <code>SETEX</code> 命令：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SETEX <span class=\"type\">key</span> <span class=\"number\">5</span> value1</span><br><span class=\"line\">...                # 等待 <span class=\"number\">5</span>s 后获取</span><br><span class=\"line\">&gt; GET <span class=\"type\">key</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; SETNX <span class=\"type\">key</span> value1  # 如果 <span class=\"type\">key</span> 不存在则 SET 成功</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; SETNX <span class=\"type\">key</span> value1  # 如果 <span class=\"type\">key</span> 存在则 SET 失败</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">0</span></span><br><span class=\"line\">&gt; GET <span class=\"type\">key</span></span><br><span class=\"line\"><span class=\"string\">\"value\"</span>             # 没有改变</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>计数</strong></li>\n</ul>\n<p>如果 value 是一个整数，还可以对它使用 <code>INCR</code> 命令进行 <strong>原子性</strong> 的自增操作，这意味着及时多个客户端对同一个 key 进行操作，也决不会导致竞争的情况：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SET counter <span class=\"number\">100</span></span><br><span class=\"line\">&gt; INCR counter</span><br><span class=\"line\">(<span class=\"built_in\">int</span>eger) <span class=\"number\">101</span></span><br><span class=\"line\">&gt; INCRBY counter <span class=\"number\">50</span></span><br><span class=\"line\">(<span class=\"built_in\">int</span>eger) <span class=\"number\">151</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-list\"><a href=\"#2-list\" class=\"headerlink\" title=\"2. list\"></a>2. list</h4><blockquote>\n<p>Redis 的列表相当于 Java 语言中的 <strong>LinkedList</strong>，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。</p>\n</blockquote>\n<p><strong>链表的基本操作</strong></p>\n<ul>\n<li><code>LPUSH</code> 和 <code>RPUSH</code> 分别可以向 list 的左边（头部）和右边（尾部）添加一个新元素；</li>\n<li><code>LRANGE</code> 命令可以从 list 中取出一定范围的元素；</li>\n<li><code>LINDEX</code> 命令可以从 list 中取出指定下表的元素，相当于 Java 链表操作中的 <code>get(int index)</code> 操作；</li>\n</ul>\n<p>示范：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> rpush mylist A</span></span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> rpush mylist B</span></span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> lpush mylist first</span></span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> lrange mylist 0 -1    <span class=\"comment\"># -1 表示倒数第一个元素, 这里表示从第一个元素到最后一个元素，即所有</span></span></span><br><span class=\"line\">1) \"first\"</span><br><span class=\"line\">2) \"A\"</span><br><span class=\"line\">3) \"B\"</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>list 实现队列</li>\n</ul>\n<p>队列是先进先出的数据结构，常用于消息排队和异步逻辑处理，它会确保元素的访问顺序：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPUSH books python java golang</span></span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> LPOP books</span></span><br><span class=\"line\">\"python\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> LPOP books</span></span><br><span class=\"line\">\"java\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> LPOP books</span></span><br><span class=\"line\">\"golang\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> LPOP books</span></span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>list 实现栈</li>\n</ul>\n<p>栈是先进后出的数据结构，跟队列正好相反：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPUSH books python java golang</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPOP books</span></span><br><span class=\"line\">\"golang\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPOP books</span></span><br><span class=\"line\">\"java\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPOP books</span></span><br><span class=\"line\">\"python\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPOP books</span></span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用场景举例：简单的消息队列、分页功能（lrange ）</li>\n</ul>\n<h4 id=\"3-hash\"><a href=\"#3-hash\" class=\"headerlink\" title=\"3. hash\"></a>3. hash</h4><blockquote>\n<p>Redis 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，都是通过 <strong>“数组 + 链表”</strong> 的链地址法来解决部分 <strong>哈希冲突</strong>，同时这样的结构也吸收了两种不同数据结构的优点。</p>\n</blockquote>\n<ul>\n<li>基本操作：</li>\n</ul>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; HSET <span class=\"keyword\">books </span><span class=\"keyword\">java </span><span class=\"string\">\"think in java\"</span>    <span class=\"comment\"># 命令行的字符串如果包含空格则需要使用引号包裹</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; HSET <span class=\"keyword\">books </span>python <span class=\"string\">\"python cookbook\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; HGETALL <span class=\"keyword\">books </span>   <span class=\"comment\"># key 和 value 间隔出现</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"think in java\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"python\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"python cookbook\"</span></span><br><span class=\"line\">&gt; HGET <span class=\"keyword\">books </span><span class=\"keyword\">java</span></span><br><span class=\"line\"><span class=\"keyword\">\"think </span>in <span class=\"keyword\">java\"</span></span><br><span class=\"line\"><span class=\"keyword\">&gt; </span>HSET <span class=\"keyword\">books </span><span class=\"keyword\">java </span><span class=\"string\">\"head first java\"</span>  </span><br><span class=\"line\">(integer) <span class=\"number\">0</span>        <span class=\"comment\"># 因为是更新操作，所以返回 0</span></span><br><span class=\"line\">&gt; HMSET <span class=\"keyword\">books </span><span class=\"keyword\">java </span><span class=\"string\">\"effetive  java\"</span> python <span class=\"string\">\"learning python\"</span>    <span class=\"comment\"># 批量操作</span></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用场景举例：单点登录。存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果。</li>\n</ul>\n<h4 id=\"4-set\"><a href=\"#4-set\" class=\"headerlink\" title=\"4. set\"></a>4. set</h4><blockquote>\n<p>Redis 的集合相当于 Java 语言中的 <strong>HashSet</strong>，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。</p>\n</blockquote>\n<ul>\n<li>基本操作：</li>\n</ul>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SADD <span class=\"keyword\">books </span><span class=\"keyword\">java</span></span><br><span class=\"line\"><span class=\"keyword\">(integer) </span><span class=\"number\">1</span></span><br><span class=\"line\">&gt; SADD <span class=\"keyword\">books </span><span class=\"keyword\">java </span>   <span class=\"comment\"># 重复</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">&gt; SADD <span class=\"keyword\">books </span>python golang</span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">&gt; SMEMBERS <span class=\"keyword\">books </span>   <span class=\"comment\"># 注意顺序，set 是无序的 </span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"python\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"golang\"</span></span><br><span class=\"line\">&gt; SISMEMBER <span class=\"keyword\">books </span><span class=\"keyword\">java </span>   <span class=\"comment\"># 查询某个 value 是否存在，相当于 contains</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; <span class=\"keyword\">SCARD </span><span class=\"keyword\">books </span>   <span class=\"comment\"># 获取长度</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">&gt; SPOP <span class=\"keyword\">books </span>    <span class=\"comment\"># 弹出一个</span></span><br><span class=\"line\"><span class=\"string\">\"java\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用场景举例：全局去重、计算共同喜好等</li>\n</ul>\n<h4 id=\"5-zset\"><a href=\"#5-zset\" class=\"headerlink\" title=\"5. zset\"></a>5. zset</h4><blockquote>\n<p>这可能使 Redis 最具特色的一个数据结构了，它类似于 Java 中 <strong>SortedSet</strong> 和 <strong>HashMap</strong> 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。它的内部实现用的是一种叫做 <strong>「跳跃表」</strong> 的数据结构。</p>\n</blockquote>\n<ul>\n<li>基本操作</li>\n</ul>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ZADD books <span class=\"number\">9.0</span> <span class=\"string\">\"think in java\"</span></span><br><span class=\"line\">&gt; ZADD books <span class=\"number\">8.9</span> <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\">&gt; ZADD books <span class=\"number\">8.6</span> <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZRANGE books <span class=\"number\">0</span> <span class=\"number\">-1</span>     # 按 score 排序列出，参数区间为排名范围</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"think in java\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZREVRANGE books <span class=\"number\">0</span> <span class=\"number\">-1</span>  # 按 score 逆序列出，参数区间为排名范围</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"think in java\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZCARD books           # 相当于 count()</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZSCORE books <span class=\"string\">\"java concurrency\"</span>   # 获取指定 value 的 score</span><br><span class=\"line\"><span class=\"string\">\"8.9000000000000004\"</span>                # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZRANK books <span class=\"string\">\"java concurrency\"</span>    # 排名</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZRANGEBYSCORE books <span class=\"number\">0</span> <span class=\"number\">8.91</span>        # 根据分值区间遍历 zset</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZRANGEBYSCORE books -inf <span class=\"number\">8.91</span> withscores  # 根据分值区间 (-∞, <span class=\"number\">8.91</span>] 遍历 zset，同时返回分值。inf 代表 infinite。</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"8.5999999999999996\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"8.9000000000000004\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZREM books <span class=\"string\">\"java concurrency\"</span>             # 删除 value</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; ZRANGE books <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"think in java\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用场景举例：排行榜应用取 TOP N 、范围查找</li>\n</ul>\n<h3 id=\"七-Redis常见问题及解决方法\"><a href=\"#七-Redis常见问题及解决方法\" class=\"headerlink\" title=\"七. Redis常见问题及解决方法\"></a>七. Redis常见问题及解决方法</h3><h4 id=\"1-缓存与数据库双写不一致\"><a href=\"#1-缓存与数据库双写不一致\" class=\"headerlink\" title=\"1. 缓存与数据库双写不一致\"></a>1. 缓存与数据库双写不一致</h4><h5 id=\"什么是双写不一致？\"><a href=\"#什么是双写不一致？\" class=\"headerlink\" title=\"什么是双写不一致？\"></a>什么是双写不一致？</h5><p>​        一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是当要执行数据的更新操作的时候，数据库和缓存的数据就会出现不一致的情况。</p>\n<p>从理论上说，只要我们设置了<strong>键的过期时间</strong>，就能保证缓存和数据库的数据<strong>最终一致</strong>。</p>\n<h5 id=\"有哪些解决办法？\"><a href=\"#有哪些解决办法？\" class=\"headerlink\" title=\"有哪些解决办法？\"></a>有哪些解决办法？</h5><ul>\n<li><p>先更新数据库，再删缓存。</p>\n<p>  如果在高并发的场景下，出现数据库与缓存数据不一致的<strong>概率特别低</strong>，也不是没有：</p>\n<blockquote>\n<p>1、 缓存刚好失效<br>2、线程A查询数据库，得一个旧值<br>3、线程B将新值写入数据库<br>4、线程B删除缓存<br>5、线程A将查到的旧值写入缓存</p>\n</blockquote>\n</li>\n<li><p>先删除缓存，再更新数据库。</p>\n<p>  并发场景下分析一下，还是有问题：</p>\n<blockquote>\n<p>线程A删除了缓存<br>线程B查询，发现缓存已不存在<br>线程B去数据库查询得到旧值<br>线程B将旧值写入缓存<br>线程A将新值写入数据库</p>\n</blockquote>\n</li>\n<li><p>将删除缓存、修改数据库、读取缓存等的操作积压到队列里边，实现串行化。</p>\n</li>\n</ul>\n<p>这些方案从根本上来说，只能降低不一致发生的概率，无法完全避免。因此，<strong>有强一致性要求的数据，不能放缓存。</strong></p>\n<h4 id=\"2-缓存穿透\"><a href=\"#2-缓存穿透\" class=\"headerlink\" title=\"2. 缓存穿透\"></a>2. 缓存穿透</h4><h5 id=\"什么是缓存穿透？\"><a href=\"#什么是缓存穿透？\" class=\"headerlink\" title=\"什么是缓存穿透？\"></a>什么是缓存穿透？</h5><p>​        缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：我们有一张数据库表，ID都是从1开始的，但是可能有黑客想把我们的数据库搞垮，每次请求的ID都是负数，导致缓存失去意义，请求都会去找数据库。</p>\n<h5 id=\"有哪些解决办法？-1\"><a href=\"#有哪些解决办法？-1\" class=\"headerlink\" title=\"有哪些解决办法？\"></a>有哪些解决办法？</h5><ol>\n<li><p>缓存无效 key</p>\n<p> ​        如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code>。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。如果用 Java 代码展示的话，差不多是下面这样的：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObjectInclNullById</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从缓存中获取数据</span></span><br><span class=\"line\">    Object cacheValue = cache.get(id);</span><br><span class=\"line\">    <span class=\"comment\">// 缓存为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheValue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从数据库中获取</span></span><br><span class=\"line\">        Object storageValue = storage.get(key);</span><br><span class=\"line\">        <span class=\"comment\">// 缓存空对象</span></span><br><span class=\"line\">        cache.set(key, storageValue);</span><br><span class=\"line\">        <span class=\"comment\">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (storageValue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class=\"line\">            cache.expire(key, <span class=\"number\">60</span> * <span class=\"number\">5</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> storageValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cacheValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>布隆过滤器</p>\n<p> ​        布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中，我们需要的就是判断 key 是否合法。</p>\n<p> ​        具体做法：内部维护一系列合法有效的 Key都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>\n<p> ​        但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>\n<hr>\n<p> <strong><em>布隆过滤器原理</em>：</strong>  </p>\n<p> <strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>\n<ol>\n<li><p>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</p>\n</li>\n<li><p>根据得到的哈希值，在位数组中把对应下标的值置为 1。</p>\n</li>\n</ol>\n<p> <strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p>\n<ol>\n<li><p>对给定元素再次进行相同的哈希计算；</p>\n</li>\n<li><p>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>\n<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-缓存雪崩\"><a href=\"#3-缓存雪崩\" class=\"headerlink\" title=\"3. 缓存雪崩\"></a>3. 缓存雪崩</h4><h5 id=\"什么是缓存雪崩？\"><a href=\"#什么是缓存雪崩？\" class=\"headerlink\" title=\"什么是缓存雪崩？\"></a>什么是缓存雪崩？</h5><p>​        缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，数据库的压力可想而知，可能直接就挂了。</p>\n<p>​        举个例子：系统的缓存模块出了问题比如宕机导致不可用，造成系统的所有访问，都要走数据库。</p>\n<p>​        还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong></p>\n<p>​        举个例子 ：秒杀开始12个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是12个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p>\n<h5 id=\"有哪些解决办法？-2\"><a href=\"#有哪些解决办法？-2\" class=\"headerlink\" title=\"有哪些解决办法？\"></a>有哪些解决办法？</h5><p>Redis服务不可用：</p>\n<ol>\n<li>采用Redis集群，避免单机出现问题整个缓存服务都没办法使用。</li>\n<li>限流，避免同时处理大量的请求。</li>\n</ol>\n<p>热点缓存失效：</p>\n<ol>\n<li>设置不同的失效时间，比如随机设置缓存的失效时间。</li>\n<li>缓存永不失效。</li>\n</ol>\n"},{"title":"滚雪球","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":null,"abbrlink":"c15d","date":"2020-12-19T16:00:00.000Z","subtitle":null,"_content":"\n### 滚雪球","source":"_posts/read-test2.md","raw":"---\ntitle: 滚雪球\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop:\ntags:\n  - finance\ncategories:\n  - life\nabbrlink: c15d\ndate: 2020-12-20 00:00:00\nsubtitle:\n---\n\n### 滚雪球","slug":"read-test2","published":1,"updated":"2021-08-18T12:40:50.754Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshhgzjp0017iobf2lng60t5","content":"<h3 id=\"滚雪球\"><a href=\"#滚雪球\" class=\"headerlink\" title=\"滚雪球\"></a>滚雪球</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"滚雪球\"><a href=\"#滚雪球\" class=\"headerlink\" title=\"滚雪球\"></a>滚雪球</h3>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckshhgzj20009iobf97s66xyt","category_id":"ckshhgzix0005iobf1wh2dcfr","_id":"ckshhgzjc000iiobfgs7e5vul"},{"post_id":"ckshhgziq0001iobff8m9bgw5","category_id":"ckshhgzix0005iobf1wh2dcfr","_id":"ckshhgzjf000niobf8lvzhhmv"},{"post_id":"ckshhgzj4000biobfhb1afxml","category_id":"ckshhgzix0005iobf1wh2dcfr","_id":"ckshhgzjh000qiobfbeqtcn3j"},{"post_id":"ckshhgzj9000fiobf4x856558","category_id":"ckshhgzix0005iobf1wh2dcfr","_id":"ckshhgzjk000uiobffxgzgvgf"},{"post_id":"ckshhgziu0003iobfgatzggus","category_id":"ckshhgzix0005iobf1wh2dcfr","_id":"ckshhgzjl000xiobfgdtmcgxl"},{"post_id":"ckshhgzje000miobf5gx84cdk","category_id":"ckshhgzix0005iobf1wh2dcfr","_id":"ckshhgzjn0012iobfff3xdf2g"},{"post_id":"ckshhgzj00007iobfgg4e2bcf","category_id":"ckshhgzix0005iobf1wh2dcfr","_id":"ckshhgzjo0015iobf4sn6a4g2"},{"post_id":"ckshhgzjj000tiobf1dfo3bmj","category_id":"ckshhgzix0005iobf1wh2dcfr","_id":"ckshhgzjp0018iobf783cacg6"},{"post_id":"ckshhgzjb000hiobfauto8dfk","category_id":"ckshhgzji000riobf2s6lc45h","_id":"ckshhgzjq001aiobf8aepgkal"},{"post_id":"ckshhgzjl000wiobf9gs10iae","category_id":"ckshhgzix0005iobf1wh2dcfr","_id":"ckshhgzjt001diobf7sl9gbpj"},{"post_id":"ckshhgzjn0011iobf2wrd6c34","category_id":"ckshhgzix0005iobf1wh2dcfr","_id":"ckshhgzjt001fiobf3k764avj"},{"post_id":"ckshhgzjg000piobfb9dq1i4q","category_id":"ckshhgzji000riobf2s6lc45h","_id":"ckshhgzjt001giobf157w24s5"},{"post_id":"ckshhgzjo0014iobf08vo10s6","category_id":"ckshhgzix0005iobf1wh2dcfr","_id":"ckshhgzjt001jiobf9o5009vf"},{"post_id":"ckshhgzjp0017iobf2lng60t5","category_id":"ckshhgzji000riobf2s6lc45h","_id":"ckshhgzjt001kiobfa2nfgbjd"}],"PostTag":[{"post_id":"ckshhgzj20009iobf97s66xyt","tag_id":"ckshhgziz0006iobf6dtdaokb","_id":"ckshhgzj9000eiobfglqud169"},{"post_id":"ckshhgziq0001iobff8m9bgw5","tag_id":"ckshhgziz0006iobf6dtdaokb","_id":"ckshhgzja000giobfeboddcoo"},{"post_id":"ckshhgzj9000fiobf4x856558","tag_id":"ckshhgziz0006iobf6dtdaokb","_id":"ckshhgzjd000liobf1e2shh9q"},{"post_id":"ckshhgziu0003iobfgatzggus","tag_id":"ckshhgziz0006iobf6dtdaokb","_id":"ckshhgzjg000oiobfcwwmf5ez"},{"post_id":"ckshhgzj00007iobfgg4e2bcf","tag_id":"ckshhgzjc000kiobf76561gns","_id":"ckshhgzjk000viobf903lexwd"},{"post_id":"ckshhgzjj000tiobf1dfo3bmj","tag_id":"ckshhgzji000siobfexalb7bk","_id":"ckshhgzjm0010iobf19ow5a9k"},{"post_id":"ckshhgzj4000biobfhb1afxml","tag_id":"ckshhgzji000siobfexalb7bk","_id":"ckshhgzjo0013iobfh9ingas8"},{"post_id":"ckshhgzjb000hiobfauto8dfk","tag_id":"ckshhgzjm000ziobfhbn1b011","_id":"ckshhgzjq0019iobf3sz95f4a"},{"post_id":"ckshhgzjo0014iobf08vo10s6","tag_id":"ckshhgzjc000kiobf76561gns","_id":"ckshhgzjq001biobf28ooe87v"},{"post_id":"ckshhgzje000miobf5gx84cdk","tag_id":"ckshhgzji000siobfexalb7bk","_id":"ckshhgzjt001eiobfdzus5yfs"},{"post_id":"ckshhgzjg000piobfb9dq1i4q","tag_id":"ckshhgzjq001ciobf3uq8d5by","_id":"ckshhgzjt001iiobf4qql1uk0"},{"post_id":"ckshhgzjl000wiobf9gs10iae","tag_id":"ckshhgzjt001hiobf4v7x8jwd","_id":"ckshhgzju001miobf06xeb0xr"},{"post_id":"ckshhgzjn0011iobf2wrd6c34","tag_id":"ckshhgzjt001hiobf4v7x8jwd","_id":"ckshhgzjz001oiobfe40t0ohm"},{"post_id":"ckshhgzjp0017iobf2lng60t5","tag_id":"ckshhgzjq001ciobf3uq8d5by","_id":"ckshhgzk0001piobf0c4f77c1"}],"Tag":[{"name":"algorithm","_id":"ckshhgziz0006iobf6dtdaokb"},{"name":"tools","_id":"ckshhgzjc000kiobf76561gns"},{"name":"git","_id":"ckshhgzji000siobfexalb7bk"},{"name":"map","_id":"ckshhgzjm000ziobfhbn1b011"},{"name":"finance","_id":"ckshhgzjq001ciobf3uq8d5by"},{"name":"IO","_id":"ckshhgzjt001hiobf4v7x8jwd"}]}}