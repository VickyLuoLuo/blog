{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/LICENSE","path":"LICENSE","modified":1,"renderable":0},{"_id":"themes/livemylife/source/baidu_verify_code-jayy2pLM52.html","path":"baidu_verify_code-jayy2pLM52.html","modified":1,"renderable":1},{"_id":"themes/livemylife/source/baidu_verify_code-rpJMBPgyFA.html","path":"baidu_verify_code-rpJMBPgyFA.html","modified":1,"renderable":1},{"_id":"themes/livemylife/source/google0915f5e354aeae89.html","path":"google0915f5e354aeae89.html","modified":1,"renderable":1},{"_id":"source/img/avatar/avatar.png","path":"img/avatar/avatar.png","modified":1,"renderable":0},{"_id":"source/img/avatar/fatpeople.jpg","path":"img/avatar/fatpeople.jpg","modified":1,"renderable":0},{"_id":"source/img/signature/vicky-white.png","path":"img/signature/vicky-white.png","modified":1,"renderable":0},{"_id":"themes/livemylife/source/css/archive.styl","path":"css/archive.styl","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/beantech.css","path":"css/beantech.css","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/beantech.min.css","path":"css/beantech.min.css","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/catalog.styl","path":"css/catalog.styl","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/highlight_normal.css","path":"css/highlight_normal.css","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/livemylife.css","path":"css/livemylife.css","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/rocket.styl","path":"css/rocket.styl","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/search.css","path":"css/search.css","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/scroll.css","path":"css/scroll.css","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/themecolor.css","path":"css/themecolor.css","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/top.css","path":"css/top.css","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/viewer.min.css","path":"css/viewer.min.css","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/wave.css","path":"css/wave.css","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/widget.styl","path":"css/widget.styl","modified":1,"renderable":1},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/busuanzi.pure.mini.js","path":"js/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/catalog.js","path":"js/catalog.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/signature.styl","path":"css/signature.styl","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/scroll.js","path":"js/scroll.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/themecolor.js","path":"js/themecolor.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/ziploader.js","path":"js/ziploader.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"source/img/avatar/about-me.jpg","path":"img/avatar/about-me.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg.jpg","path":"img/header_img/home-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/post-bg-desk.jpg","path":"img/header_img/post-bg-desk.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/categories_bg.jpg","path":"img/header_img/categories_bg.jpg","modified":1,"renderable":0},{"_id":"source/img/scenery/about_bg.jpg","path":"img/scenery/about_bg.jpg","modified":1,"renderable":0},{"_id":"source/img/scenery/about_bg4.jpg","path":"img/scenery/about_bg4.jpg","modified":1,"renderable":0},{"_id":"themes/livemylife/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/img/1-work/tools/create_gitee_repo.png","path":"img/1-work/tools/create_gitee_repo.png","modified":1,"renderable":0},{"_id":"source/img/1-work/tools/import-github-repo.png","path":"img/1-work/tools/import-github-repo.png","modified":1,"renderable":0},{"_id":"source/img/header_img/archive_bg.jpg","path":"img/header_img/archive_bg.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/ebooks-bg.jpg","path":"img/header_img/ebooks-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/scenery/treat_me_to_coffee.jpg","path":"img/scenery/treat_me_to_coffee.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/post-bg-swift.jpg","path":"img/header_img/post-bg-swift.jpg","modified":1,"renderable":0},{"_id":"themes/livemylife/source/css/images/beside_up.png","path":"css/images/beside_up.png","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/images/beside_up2.png","path":"css/images/beside_up2.png","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/images/beside_up_white.png","path":"css/images/beside_up_white.png","modified":1,"renderable":1},{"_id":"themes/livemylife/source/css/images/beside_up_white2.png","path":"css/images/beside_up_white2.png","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/china-contour.js","path":"js/echarts/china-contour.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/src/chinamap.js","path":"js/src/chinamap.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/viewer/pic-viewer.js","path":"js/viewer/pic-viewer.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/viewer/viewer.min.js","path":"js/viewer/viewer.min.js","modified":1,"renderable":1},{"_id":"source/img/header_img/404_bg.jpg","path":"img/header_img/404_bg.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/tag_bg.jpg","path":"img/header_img/tag_bg.jpg","modified":1,"renderable":0},{"_id":"source/img/scenery/about_bg2.jpg","path":"img/scenery/about_bg2.jpg","modified":1,"renderable":0},{"_id":"themes/livemylife/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/china.js","path":"js/echarts/china.js","modified":1,"renderable":1},{"_id":"source/img/header_img/dawn.jpg","path":"img/header_img/dawn.jpg","modified":1,"renderable":0},{"_id":"themes/livemylife/source/js/echarts/province/anhui.js","path":"js/echarts/province/anhui.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/beijing.js","path":"js/echarts/province/beijing.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/fujian.js","path":"js/echarts/province/fujian.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/chongqing.js","path":"js/echarts/province/chongqing.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/guangxi.js","path":"js/echarts/province/guangxi.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/aomen.js","path":"js/echarts/province/aomen.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/guizhou.js","path":"js/echarts/province/guizhou.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/hainan.js","path":"js/echarts/province/hainan.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/hebei.js","path":"js/echarts/province/hebei.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/henan.js","path":"js/echarts/province/henan.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/hubei.js","path":"js/echarts/province/hubei.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/hunan.js","path":"js/echarts/province/hunan.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/jiangsu.js","path":"js/echarts/province/jiangsu.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/jiangxi.js","path":"js/echarts/province/jiangxi.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/jilin.js","path":"js/echarts/province/jilin.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/liaoning.js","path":"js/echarts/province/liaoning.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/ningxia.js","path":"js/echarts/province/ningxia.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/neimenggu.js","path":"js/echarts/province/neimenggu.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/shanghai.js","path":"js/echarts/province/shanghai.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/shanxi.js","path":"js/echarts/province/shanxi.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/shanxi1.js","path":"js/echarts/province/shanxi1.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/taiwan.js","path":"js/echarts/province/taiwan.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/tianjin.js","path":"js/echarts/province/tianjin.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/xianggang.js","path":"js/echarts/province/xianggang.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/zhejiang.js","path":"js/echarts/province/zhejiang.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/avatar/roguerabbit.jpg","path":"img/avatar/roguerabbit.jpg","modified":1,"renderable":0},{"_id":"themes/livemylife/source/js/echarts/province/gansu.js","path":"js/echarts/province/gansu.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/guangdong.js","path":"js/echarts/province/guangdong.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/heilongjiang.js","path":"js/echarts/province/heilongjiang.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/qinghai.js","path":"js/echarts/province/qinghai.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/shandong.js","path":"js/echarts/province/shandong.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/sichuan.js","path":"js/echarts/province/sichuan.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/xinjiang.js","path":"js/echarts/province/xinjiang.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/xizang.js","path":"js/echarts/province/xizang.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/province/yunnan.js","path":"js/echarts/province/yunnan.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/world.js","path":"js/echarts/world.js","modified":1,"renderable":1},{"_id":"source/img/header_img/squirrel.jpg","path":"img/header_img/squirrel.jpg","modified":1,"renderable":0},{"_id":"themes/livemylife/source/js/comment/gitalk.js","path":"js/comment/gitalk.js","modified":1,"renderable":1},{"_id":"themes/livemylife/source/js/echarts/echarts.min.js","path":"js/echarts/echarts.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/404.md","hash":"3bdf0ec6214c65c8e924c8f716fe73f13471ae3c","modified":1639127127057},{"_id":"source/CNAME","hash":"fa4ed0bd15b8167ee4e134821e3bb58a69a4d1a9","modified":1639127127057},{"_id":"source/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1639127127057},{"_id":"source/_readme.txt","hash":"1d6fc9b02cb7b2438e9e32dc211c801e672c786a","modified":1639127127058},{"_id":"themes/livemylife/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1639127127353},{"_id":"themes/livemylife/_config.yml","hash":"7638a858e59f075c4066eb9ca880f3bce75ccd04","modified":1639127127353},{"_id":"source/_posts/algorithm-datastructure-outline.md","hash":"ba1dc53b6e40512aeb89d82d220cf1e7fd41cbff","modified":1639127127057},{"_id":"source/_posts/algorithm-dp-thinking.md","hash":"624c70cefbf770fe944a67e42138eece3d71480b","modified":1639129830252},{"_id":"source/_posts/algorithm-heap.md","hash":"c2ab6bf954ca98157a7bd14a3d14c03e30f62891","modified":1639127127057},{"_id":"source/_posts/chinamap.md","hash":"36ba243694e51d850ee19e8dcb02895c0bcf64c1","modified":1639129713346},{"_id":"source/_posts/centos-config.md","hash":"c8ae6e13e7000b84758496727f971745649225d2","modified":1639130057314},{"_id":"source/_posts/algorithm-sort.md","hash":"b900e09094f17b71f9be5349b2df8ceae8516694","modified":1639127127057},{"_id":"source/_posts/git-push-two-repo.md","hash":"f75811e034b6cd6ea114962ff8661db68c756838","modified":1639127127058},{"_id":"source/_posts/git-reset.md","hash":"e9fc05c89b4593f6e923956812745ded869a3b0f","modified":1639129713335},{"_id":"source/_posts/io.md","hash":"d6bb84b5bd979ec853769a3e992ebcb3d09bc447","modified":1639127127058},{"_id":"source/_posts/java-nio.md","hash":"478eab136a9c459b02fb55c1f909abfa5bf662dc","modified":1639127127058},{"_id":"source/_posts/algorithm-tree.md","hash":"62e1eaba26fc8bb29ebfcc7dfd11a2886a324bc3","modified":1639127127057},{"_id":"source/_posts/nginx-cors.md","hash":"3118cb2c56a83c81bdbaf11337687632215c9b75","modified":1639127127058},{"_id":"source/_posts/git-push-error.md","hash":"cd692fa386fb321333c589afa254b4b3526cb7bf","modified":1639129752892},{"_id":"source/_posts/read-test2.md","hash":"e1e2a7fb899b4bea2da057e5fdfab40cc87b3533","modified":1639127127058},{"_id":"source/_posts/redis.md","hash":"698cabf5d93675d7b2b5acdc1ffc6ceb3de910f5","modified":1639129713345},{"_id":"source/_posts/source-code.md","hash":"690d6a90e2bc397cecfbeb92dad8a4ed889cc635","modified":1639129713325},{"_id":"source/_posts/java-outline.md","hash":"09460a7ec2a644e1d3ffbc670bb3f077151070e4","modified":1639127127058},{"_id":"source/_posts/read-test.md","hash":"2c48de686846485145693e17f559f9d433ceb042","modified":1639127127058},{"_id":"source/about/index.md","hash":"00bbdbf721b12f9db3eb0aed17c549286812c2f5","modified":1639127127058},{"_id":"source/categories/index.md","hash":"91fff40dea4be55c903b76375ed43a88f67cf4f9","modified":1639127127058},{"_id":"source/archive/index.md","hash":"f7439e98582e265745f2301fb980a1940426c8b7","modified":1639127127058},{"_id":"source/ebooks/index.md","hash":"2b64f3f75175fb2fe119cf1e3f9623ded7ab2c9e","modified":1639127127058},{"_id":"source/tags/index.md","hash":"e4060fc3a8aa9de589a6b5ab12ae2210d3db2b51","modified":1639127127353},{"_id":"themes/livemylife/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1639127127353},{"_id":"themes/livemylife/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1639127127353},{"_id":"themes/livemylife/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1639127127353},{"_id":"themes/livemylife/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1639127127353},{"_id":"themes/livemylife/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1639127127353},{"_id":"themes/livemylife/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1639127127353},{"_id":"themes/livemylife/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1639127127353},{"_id":"themes/livemylife/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1639127127353},{"_id":"themes/livemylife/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1639127127353},{"_id":"themes/livemylife/layout/about.ejs","hash":"9dbbb4fd7d0a08c766e71a161650704a507b854c","modified":1639127127363},{"_id":"themes/livemylife/layout/archive.ejs","hash":"13df65b0707210c0960d193001cce7f363df509a","modified":1639127127363},{"_id":"themes/livemylife/layout/categories.ejs","hash":"fa1d1bebf4c696929c8c89a127fa4b64cd478d0f","modified":1639127127363},{"_id":"themes/livemylife/layout/index.ejs","hash":"0e06c2c74b646a8610b4c1e014935617b4871cc0","modified":1639127127363},{"_id":"themes/livemylife/layout/keynote.ejs","hash":"549ab47e8b6b384cd935882d67a8ceb3e9c3f6f5","modified":1639127127363},{"_id":"themes/livemylife/layout/layout.ejs","hash":"2d2ca4424de53e9b52318750e4b1b8aa27ee3101","modified":1639127127363},{"_id":"themes/livemylife/layout/page.ejs","hash":"5b894299659f66162e01ee8bc73678aad1ac04c6","modified":1639127127363},{"_id":"themes/livemylife/layout/post.ejs","hash":"62dac197816ff4b2e95ceb57bdf6c501b393d13d","modified":1639127127363},{"_id":"themes/livemylife/layout/tags.ejs","hash":"bcbde51624034c243ea0649099d0f1600ae00f71","modified":1639127127363},{"_id":"themes/livemylife/source/baidu_verify_code-jayy2pLM52.html","hash":"58fc353e353e2dedb8bcd7f9ffe62ec1b2ba81d7","modified":1639127127363},{"_id":"themes/livemylife/source/baidu_verify_code-rpJMBPgyFA.html","hash":"7ee3e15a6b854a6f1131bf731fff4c9d61b8f431","modified":1639127127363},{"_id":"themes/livemylife/source/google0915f5e354aeae89.html","hash":"dacc570438035c30f92d0c9d97eacc9b0f09cc46","modified":1639127127384},{"_id":"themes/livemylife/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1639127127353},{"_id":"source/_posts/bio-nio-netty.md","hash":"c935ecb260fd554e4b38ca628400a69c7c87c642","modified":1639128644328},{"_id":"source/img/avatar/avatar.png","hash":"e6c1c40fb523d94779d95aa2dc7bf0b4259bacf2","modified":1639127127058},{"_id":"source/img/avatar/fatpeople.jpg","hash":"04cc046c50473ab78aee784df62f05448be8b884","modified":1639127127058},{"_id":"source/img/signature/vicky-white.png","hash":"efb6c7e1ccbded551759c9997b108a20c15f0c09","modified":1639127127353},{"_id":"themes/livemylife/layout/_widget/archive.ejs","hash":"f896506edb810b1d3fe479c03ac92ab627ea21e6","modified":1639127127363},{"_id":"themes/livemylife/layout/_widget/featured-tags.ejs","hash":"4e8fdc9890d281e6a22a9032098d6ef15eef7848","modified":1639127127363},{"_id":"themes/livemylife/layout/_widget/category.ejs","hash":"15f667fc7a69eb2b738672ccb7a9072d2bdec140","modified":1639127127363},{"_id":"themes/livemylife/layout/_widget/friends-blog.ejs","hash":"4fe9d34bc9b8fc89b2b339496f3f0dae1e0c7fee","modified":1639127127363},{"_id":"themes/livemylife/layout/_widget/recent-posts.ejs","hash":"257a486fd4bfac693201818efb198d7c8fcf19ba","modified":1639127127363},{"_id":"themes/livemylife/layout/_widget/short-about.ejs","hash":"038032cf6e205aa8f07d65819deec2339d9376a4","modified":1639127127363},{"_id":"themes/livemylife/layout/_widget/visitor.ejs","hash":"61f5d15d6be1f047b06a736c3e39457bd36dedcd","modified":1639127127363},{"_id":"themes/livemylife/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1639127127363},{"_id":"themes/livemylife/source/css/beantech.css","hash":"c192d3170301f774fa4c2185dc125cb3d6ec4929","modified":1639127127363},{"_id":"themes/livemylife/source/css/beantech.min.css","hash":"66f124242893cae4517119e39e75d7f23eef01ae","modified":1639127127364},{"_id":"themes/livemylife/source/css/catalog.styl","hash":"6c9a2d5f6f981624e0c4b64323493e8614efea29","modified":1639127127364},{"_id":"themes/livemylife/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1639127127364},{"_id":"themes/livemylife/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1639127127364},{"_id":"themes/livemylife/source/css/highlight_normal.css","hash":"6a40a9a0f268fb17d9002cb49a16946444ef5f34","modified":1639127127364},{"_id":"themes/livemylife/source/css/livemylife.css","hash":"dbf2b89627f55e7f8ef12730e822319859f25767","modified":1639127127364},{"_id":"themes/livemylife/source/css/rocket.styl","hash":"7c08bbc803a9d191e495ffc22a6530d602ec45cf","modified":1639127127364},{"_id":"themes/livemylife/source/css/search.css","hash":"a941f2f3d05d43e0a1517ae6923e848638b9ff7c","modified":1639127127364},{"_id":"themes/livemylife/source/css/scroll.css","hash":"254c14f514de149e1d95a9c583e8af0dbacb306d","modified":1639127127364},{"_id":"themes/livemylife/source/css/gitalk.css","hash":"51783fd60dff05e8e339ff83b41504538662f6ca","modified":1639127127364},{"_id":"themes/livemylife/source/css/themecolor.css","hash":"725b0e534f7c6c80e2e9a47d1c93ee9f03d7458a","modified":1639127127364},{"_id":"themes/livemylife/source/css/top.css","hash":"0303375fbe2ca942cd3d86f31d12fef9bf5785af","modified":1639127127364},{"_id":"themes/livemylife/source/css/viewer.min.css","hash":"0e045aa3df1be7d138caa701ec3aa623ccc7a52d","modified":1639127127364},{"_id":"themes/livemylife/source/css/wave.css","hash":"041f3b4a78e2840ba17679cea05fb14bb646722f","modified":1639127127364},{"_id":"themes/livemylife/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1639127127364},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1639127127374},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1639127127384},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1639127127384},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1639127127384},{"_id":"themes/livemylife/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1639127127384},{"_id":"themes/livemylife/source/js/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1639127127384},{"_id":"themes/livemylife/source/js/catalog.js","hash":"059f3f31492e5b1a9dddf422a48c32969d247415","modified":1639127127384},{"_id":"themes/livemylife/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1639127127364},{"_id":"themes/livemylife/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1639127127415},{"_id":"themes/livemylife/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1639127127415},{"_id":"themes/livemylife/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1639127127415},{"_id":"themes/livemylife/source/js/scroll.js","hash":"265a4c4fc33b5b44b620db64ff31d2bc05d233e9","modified":1639127127425},{"_id":"themes/livemylife/source/js/themecolor.js","hash":"8295e112233778d8f20c31b06c19659f60edbb22","modified":1639127127425},{"_id":"themes/livemylife/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1639127127425},{"_id":"themes/livemylife/source/js/ziploader.js","hash":"9c25324caf53b56cb68839dcfb34e61e5a6a63f3","modified":1639127127425},{"_id":"themes/livemylife/layout/_partial/anchorjs.ejs","hash":"9a9ff58f3767c7d23c029fcb2030ea353824f79a","modified":1639127127353},{"_id":"themes/livemylife/layout/_partial/catalog.ejs","hash":"98e4dece360e03ac0e43acec95239b9b3157f398","modified":1639127127363},{"_id":"themes/livemylife/layout/_partial/comment.ejs","hash":"842c1afa76d8d802db0a5dbe02967e2bf87289cc","modified":1639127127363},{"_id":"themes/livemylife/layout/_partial/gitter.ejs","hash":"a492bfd63baddc70a082643178d0bdf4385ea126","modified":1639127127363},{"_id":"themes/livemylife/layout/_partial/footer.ejs","hash":"61418f8e06c8f7b4cace484ebcccffc1eed9deb2","modified":1639127127363},{"_id":"themes/livemylife/layout/_partial/nav.ejs","hash":"5245e5f32f041a78163c31187634960bc373cb49","modified":1639127127363},{"_id":"themes/livemylife/layout/_partial/head.ejs","hash":"9abb5ef8026a44bb8b3d149dfc728537322cdeb6","modified":1639127127363},{"_id":"themes/livemylife/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1639127127363},{"_id":"themes/livemylife/layout/_partial/header.ejs","hash":"c2299bfff6d8437417960a814ef887bbd232634e","modified":1639127127363},{"_id":"themes/livemylife/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1639127127363},{"_id":"themes/livemylife/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1639127127415},{"_id":"themes/livemylife/layout/_partial/search.ejs","hash":"3651c99b9284cdad8a22979c4e6e03e7ca1b5151","modified":1639127127363},{"_id":"themes/livemylife/layout/_partial/socialshare.ejs","hash":"1df693cf21a2f4af133fb0da0d2352ee2aa556e0","modified":1639127127363},{"_id":"themes/livemylife/layout/_partial/themecolor.ejs","hash":"e9472d324af1eb821550b64834e198753b46e4d7","modified":1639127127363},{"_id":"source/img/avatar/about-me.jpg","hash":"4fc7c645f502bb38cb2a672bd95d478e8be0493a","modified":1639127127058},{"_id":"source/img/header_img/home-bg.jpg","hash":"6bbe3de397f929a7ca0a49c88779a4a8dd904a88","modified":1639127127301},{"_id":"source/img/header_img/post-bg-desk.jpg","hash":"6bbe3de397f929a7ca0a49c88779a4a8dd904a88","modified":1639127127333},{"_id":"source/img/header_img/categories_bg.jpg","hash":"a8a46a06f566e13a919d9cbca6a66ae5a3b78b1e","modified":1639127127301},{"_id":"source/img/scenery/about_bg.jpg","hash":"462c14b9b00ab2153e579f14cb1e44aa56704ce8","modified":1639127127353},{"_id":"source/img/scenery/about_bg4.jpg","hash":"272f0d4233aea38f32311439f8528d2b3bebd546","modified":1639127127353},{"_id":"themes/livemylife/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1639127127364},{"_id":"themes/livemylife/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1639127127384},{"_id":"themes/livemylife/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1639127127384},{"_id":"themes/livemylife/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1639127127415},{"_id":"source/img/1-work/tools/create_gitee_repo.png","hash":"ebd7bd2ba944d5428c2f8b0f58e2d4477952ee63","modified":1639127127058},{"_id":"source/img/1-work/tools/import-github-repo.png","hash":"4ecfeb1dd598d0a17e278da065c38a5523823250","modified":1639127127058},{"_id":"source/img/header_img/archive_bg.jpg","hash":"fc4bdf7fa98346ea35115151e4914cd1e5a946d9","modified":1639127127270},{"_id":"source/img/header_img/ebooks-bg.jpg","hash":"84b61541d90457dbc74fd3a6aa91029e61524a2a","modified":1639127127301},{"_id":"source/img/scenery/treat_me_to_coffee.jpg","hash":"e307178429b98962ff3918e12427b3e7db6d10df","modified":1639127127353},{"_id":"source/img/header_img/post-bg-swift.jpg","hash":"12552e545ca35a93f0050a5417de5d302f1a4f5e","modified":1639127127333},{"_id":"themes/livemylife/source/css/images/beside_up.png","hash":"183d87f1a99e93fc663ec798fa8c94cb87c83bcb","modified":1639127127364},{"_id":"themes/livemylife/source/css/images/beside_up2.png","hash":"ef066ba2e93a4738df45ae05020726e066c4dd1f","modified":1639127127364},{"_id":"themes/livemylife/source/css/images/beside_up_white.png","hash":"49c5922a8de63dcf9468fbcffc70d2ec36b1b527","modified":1639127127364},{"_id":"themes/livemylife/source/css/images/beside_up_white2.png","hash":"52e9d5715def1d3d09ab076d5eb3d22916d8f7d7","modified":1639127127364},{"_id":"themes/livemylife/source/js/echarts/china-contour.js","hash":"46069d796fb1dd191cdd6a0806570700ae9c0347","modified":1639127127384},{"_id":"themes/livemylife/source/js/src/chinamap.js","hash":"37bb53e16eca9e5f0f8ff1b5581286d651aec3b4","modified":1639127127425},{"_id":"themes/livemylife/source/js/viewer/pic-viewer.js","hash":"9bf7c37cce781628346803ed7ce8f02623c2d013","modified":1639127127425},{"_id":"themes/livemylife/source/js/viewer/viewer.min.js","hash":"ae5380974b6fb8b0e15356c8418186c6c0821222","modified":1639127127425},{"_id":"source/img/header_img/404_bg.jpg","hash":"e51ce60c4e13cfd57c825d241dae23ac988cd796","modified":1609320411804},{"_id":"source/img/header_img/tag_bg.jpg","hash":"35131c8b7ab3943c9fe4577329cd1c412d1c4fac","modified":1639127127343},{"_id":"source/img/scenery/about_bg2.jpg","hash":"bdffbe6a94f9c5be1b9353fc2b4f28a74677939f","modified":1639127127353},{"_id":"themes/livemylife/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1639127127364},{"_id":"themes/livemylife/source/js/echarts/china.js","hash":"0aaf91ed666621d0aa269d4ee5e1c0a9dc06235e","modified":1639127127384},{"_id":"source/img/header_img/dawn.jpg","hash":"2e9291c0a9d255c203fb11fd4f471b28459287b0","modified":1639127127301},{"_id":"themes/livemylife/source/js/echarts/province/anhui.js","hash":"a17708654277222014c1ba7005dd58bc7b6d54ce","modified":1639127127394},{"_id":"themes/livemylife/source/js/echarts/province/beijing.js","hash":"1f33aeb4ff666ceefa75c304f3f853f5dd3591a1","modified":1639127127394},{"_id":"themes/livemylife/source/js/echarts/province/fujian.js","hash":"9c125baa9912134be8b28336ef70cdec842f195a","modified":1639127127394},{"_id":"themes/livemylife/source/js/echarts/province/chongqing.js","hash":"55661b00c1bfc3d505466c6b3c9a06df826ffa45","modified":1639127127394},{"_id":"themes/livemylife/source/js/echarts/province/guangxi.js","hash":"31ed274566e6369e568be67588033f43c2e902be","modified":1639127127394},{"_id":"themes/livemylife/source/js/echarts/province/aomen.js","hash":"8558d9a5bf394a03d93ea85159c828d23b9b56d6","modified":1639127127394},{"_id":"themes/livemylife/source/js/echarts/province/guizhou.js","hash":"9eac20cb6f36e717d364ca2c4860292b8fe1128e","modified":1639127127394},{"_id":"themes/livemylife/source/js/echarts/province/hainan.js","hash":"10b313c1fdfe1a966163c92c333a766e10e96d27","modified":1639127127395},{"_id":"themes/livemylife/source/js/echarts/province/hebei.js","hash":"d76f7ffba58d553d50acba3114c9cc776d0d59e4","modified":1639127127395},{"_id":"themes/livemylife/source/js/echarts/province/henan.js","hash":"a7c25e0f04470c5da5f36d70738156c35228ef7e","modified":1639127127395},{"_id":"themes/livemylife/source/js/echarts/province/hubei.js","hash":"4797d4615ee167b8711091ab4eea1e97a4c545bd","modified":1639127127395},{"_id":"themes/livemylife/source/js/echarts/province/hunan.js","hash":"b49abde15a3e60ae3898c0f2f5989c7a759c20c2","modified":1639127127395},{"_id":"themes/livemylife/source/js/echarts/province/jiangsu.js","hash":"15a2820d2b1829614befd24fde73b69568ff7d4f","modified":1639127127395},{"_id":"themes/livemylife/source/js/echarts/province/jiangxi.js","hash":"dc078183c43df9e91cfb46b02e9e7fdcb7a96ca3","modified":1639127127395},{"_id":"themes/livemylife/source/js/echarts/province/jilin.js","hash":"737c4416708b1ef3b49be328ed7a9896439df1d3","modified":1639127127395},{"_id":"themes/livemylife/source/js/echarts/province/liaoning.js","hash":"250fbaa3cb8297139e348249243eab6b277d24b6","modified":1639127127395},{"_id":"themes/livemylife/source/js/echarts/province/ningxia.js","hash":"c25daa696558129fe018ff7c5de6126eabfda663","modified":1639127127395},{"_id":"themes/livemylife/source/js/echarts/province/neimenggu.js","hash":"f26fcccdce99132d24c54f99d52179a11b30269a","modified":1639127127395},{"_id":"themes/livemylife/source/js/echarts/province/shanghai.js","hash":"456974123ab5ed51993e6e7fba8f200f556c0751","modified":1639127127395},{"_id":"themes/livemylife/source/js/echarts/province/shanxi.js","hash":"da043410b84996e2fc7c27b8010497ad45a9e464","modified":1639127127405},{"_id":"themes/livemylife/source/js/echarts/province/shanxi1.js","hash":"d16d41750d066776846329dd44691d39cc9a133e","modified":1639127127415},{"_id":"themes/livemylife/source/js/echarts/province/taiwan.js","hash":"1a18b39463a2a15dfb96d1823f84bd91b0099a04","modified":1639127127415},{"_id":"themes/livemylife/source/js/echarts/province/tianjin.js","hash":"c0f4bb6ae03bd3175203fd9cd70983059a3a636f","modified":1639127127415},{"_id":"themes/livemylife/source/js/echarts/province/xianggang.js","hash":"c34ca0c6974964b776ab64aff135a6630dac86ed","modified":1639127127415},{"_id":"themes/livemylife/source/js/echarts/province/zhejiang.js","hash":"4768c4a4aee38ff6f2568fe8c7b33a3555145220","modified":1639127127415},{"_id":"themes/livemylife/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1639127127415},{"_id":"source/img/avatar/roguerabbit.jpg","hash":"3c71801016fc2b587c128d42f45438f523bb1a1a","modified":1639127127058},{"_id":"themes/livemylife/source/js/echarts/province/gansu.js","hash":"e030cf4fbe48b2467176771dbee9adc4111f47de","modified":1639127127394},{"_id":"themes/livemylife/source/js/echarts/province/guangdong.js","hash":"e199d2277a076aafea04e8531ed621b792ae63cd","modified":1639127127394},{"_id":"themes/livemylife/source/js/echarts/province/heilongjiang.js","hash":"bd0453fc68288a5f1886ce233a54823377e73132","modified":1639127127395},{"_id":"themes/livemylife/source/js/echarts/province/qinghai.js","hash":"25dd767a0d1ddbea6db57f0ab86ab315215dec1d","modified":1639127127395},{"_id":"themes/livemylife/source/js/echarts/province/shandong.js","hash":"2f8035028a27dc47fe85bb8c8f3700c08c546a55","modified":1639127127395},{"_id":"themes/livemylife/source/js/echarts/province/sichuan.js","hash":"917d59cccf0a4eb98ae71f3e4ef5b5e508415352","modified":1639127127415},{"_id":"themes/livemylife/source/js/echarts/province/xinjiang.js","hash":"f432c61109275274fac2c20e69103f6c96f287c9","modified":1639127127415},{"_id":"themes/livemylife/source/js/echarts/province/xizang.js","hash":"9e51acbff27c6b4664dbaf37adcfb851e8acd025","modified":1639127127415},{"_id":"themes/livemylife/source/js/echarts/province/yunnan.js","hash":"183aeee5c67ea236a51bf31ad1e89aeb2feacd4b","modified":1639127127415},{"_id":"themes/livemylife/source/js/echarts/world.js","hash":"7c57299eabf0e80868d447830ddfef1290695193","modified":1639127127415},{"_id":"source/img/header_img/squirrel.jpg","hash":"6d9fe36a3a2d362fa2308e894088a11b39426c96","modified":1639127127333},{"_id":"themes/livemylife/source/js/comment/gitalk.js","hash":"560f027317869f39da9d13b0393e3bf98d081b12","modified":1639127127384},{"_id":"themes/livemylife/source/js/echarts/echarts.min.js","hash":"eec6c0cc35c819602747de4574b4d77a773ae6bc","modified":1639127127394},{"_id":"public/baidusitemap.xml","hash":"f869045381b9ae617c00c4eb58c1163bad7cdd56","modified":1639130303296},{"_id":"public/sitemap.xml","hash":"08f221c9742d361f807096b4e55dbe135b43adc2","modified":1639130303296},{"_id":"public/searchVersion.json","hash":"5366b2d213a34ad680056af640a6685dd3984438","modified":1639130303296},{"_id":"public/404.html","hash":"270559faf14a1a0435642b49b289b0c234467d92","modified":1639130303296},{"_id":"public/ebooks/index.html","hash":"26657a90a7e48fd1a136f8da69ea158ece9bd4e5","modified":1639130303296},{"_id":"public/categories/index.html","hash":"f0479831da27982fcc3998cffca6182a7f73444f","modified":1639130303296},{"_id":"public/tags/index.html","hash":"8d5c2f68bd2dd9af6d430cba8e107b09848c3e3b","modified":1639130303296},{"_id":"public/2021/11/10/6fff.html","hash":"282a743e2c75b6aff77383146347b83606a28a9d","modified":1639130303296},{"_id":"public/2021/10/28/9f48.html","hash":"a5e12ab64a0d9d37a724d324b018b96e4a0570a8","modified":1639130303296},{"_id":"public/2021/08/25/5dae.html","hash":"3d90df9490127368b08f5a737697b6cf228f7052","modified":1639130303296},{"_id":"public/2021/08/18/86e5.html","hash":"d37a375ea5af5e7cfcd25d8ba524dde6ad32322c","modified":1639130303296},{"_id":"public/2021/07/15/f6ae.html","hash":"9e39b375388d903f83832162bf307a4559f90839","modified":1639130303296},{"_id":"public/2021/06/04/9f70.html","hash":"acc4742c35d237d4bff8e022d0d2debe4e83a5bb","modified":1639130303296},{"_id":"public/2021/04/15/a10a.html","hash":"a46731388f4c0812538cc655503d69d29e1f0ef0","modified":1639130303296},{"_id":"public/2021/03/31/57bd.html","hash":"a7ef97d33264587aa29ee38ffd1050d0af9d38b9","modified":1639130303296},{"_id":"public/2021/03/24/1af5.html","hash":"77856ac0517986657cc5d767b891757a029b36eb","modified":1639130303296},{"_id":"public/2020/12/22/73b3.html","hash":"c8f886b829c6acb80ce6982a66f878c8df8af590","modified":1639130303296},{"_id":"public/2020/12/21/211a.html","hash":"b2706566fce98714ab13f1e318fc7c04b99bd5ab","modified":1639130303296},{"_id":"public/2020/12/21/c608.html","hash":"b56c48177bddadddf3c2c6ff2eddbe38b66ffa49","modified":1639130303296},{"_id":"public/2020/12/20/c15d.html","hash":"85c00d8622995582cb5df4b2ec755889a3c1e9a1","modified":1639130303296},{"_id":"public/2020/12/19/7b21.html","hash":"d35402b7c38fce050a54e691c3405d44317d01bf","modified":1639130303296},{"_id":"public/2020/12/18/1af5.html","hash":"97062b2e5d8269d392a8210dd3bf12bd0eadc6f5","modified":1639130303296},{"_id":"public/2020/11/26/2312.html","hash":"48510620fb779f100fc3a879fdb1fdea52e070c0","modified":1639130303296},{"_id":"public/2020/11/26/6186.html","hash":"ff466631baa0732f162b5584ef0b6f7786121f19","modified":1639130303296},{"_id":"public/2020/10/23/130.html","hash":"c622a041e9f1f1b5b9a3cbc1e8a8311524727ece","modified":1639130303296},{"_id":"public/2020/10/15/2de3.html","hash":"612ff4f07ed6fdce483c81f35c9e0150e370a990","modified":1639130303296},{"_id":"public/about/index.html","hash":"4f9f35ad9668ba7cf293dfc0670de0a54396b9d4","modified":1639130303296},{"_id":"public/archive/index.html","hash":"2df223bda5573eedb5f081c3bf65cf50afa546dd","modified":1639130303296},{"_id":"public/archives/index.html","hash":"46d409abb558ab5a439fbdf5e6ed95b94f4f8d9a","modified":1639130303296},{"_id":"public/archives/archives/2/index.html","hash":"a831ff21862c16898de48ae6be81fe5597b0ce3d","modified":1639130303296},{"_id":"public/archives/2020/index.html","hash":"689772aded11d0ed0a62e933ac10907a0b1ba078","modified":1639130303296},{"_id":"public/archives/2020/10/index.html","hash":"936fcba9c0b2a57641dd77ce6fe1e58fdfd1ec27","modified":1639130303296},{"_id":"public/archives/2020/11/index.html","hash":"48cbd4cd45a3d556803c744b462cd888cd7e8888","modified":1639130303296},{"_id":"public/archives/2020/12/index.html","hash":"f1159a7f24b264f8544d480ef589cce3e26bc792","modified":1639130303296},{"_id":"public/archives/2021/index.html","hash":"7d560248284153690be6f1a5eb50fa85f5f59971","modified":1639130303296},{"_id":"public/archives/2021/03/index.html","hash":"f343b47649d13137eaf50a1166cd8de4a0ea6a78","modified":1639130303296},{"_id":"public/archives/2021/04/index.html","hash":"34bc84765d3368c9d603c43a8c8d01ba12d0f452","modified":1639130303296},{"_id":"public/archives/2021/06/index.html","hash":"273f6f5354d91e345e7544a079e8f6b1d5fb00be","modified":1639130303296},{"_id":"public/archives/2021/07/index.html","hash":"558a6850c8bf6e91465a9d05d2e341229a19b454","modified":1639130303296},{"_id":"public/archives/2021/08/index.html","hash":"2e23024abc996616375115c9822f792778769b40","modified":1639130303296},{"_id":"public/archives/2021/10/index.html","hash":"3a44b9d79aa9ca4fb9dbf04b0ccea615cfb66289","modified":1639130303296},{"_id":"public/archives/2021/11/index.html","hash":"18caa6b10ed558b7a3e4534ad36fe376c44c3033","modified":1639130303296},{"_id":"public/categories/work/index.html","hash":"0624aec36edce41afc6bc7ef4b4ad992ed84c753","modified":1639130303296},{"_id":"public/categories/work/archives/2/index.html","hash":"1a7bcb6463cc5854e548aecea49c822d6072908a","modified":1639130303296},{"_id":"public/categories/life/index.html","hash":"faa270dfe25cfc594fdf9e45240574bdd248abb9","modified":1639130303296},{"_id":"public/index.html","hash":"35e3ce0a8103829c3e3ea25c00da3d2006910864","modified":1639130303296},{"_id":"public/archives/2/index.html","hash":"fbf38bf3f6219dcbc601460d31c9f6f180162024","modified":1639130303296},{"_id":"public/tags/algorithm/index.html","hash":"b9a0a8010ede80c0378e01e87e81e86d7c0db6b9","modified":1639130303296},{"_id":"public/tags/data-structure/index.html","hash":"6c508a293cb70ab3e98162633f00895e7eb70d08","modified":1639130303296},{"_id":"public/tags/map/index.html","hash":"ff035ee7ca7743b09db160bcb99f0c4743ec9f8a","modified":1639130303296},{"_id":"public/tags/tools/index.html","hash":"973dc86cd684a4eaa44d43f4a260a17cd09d3b6d","modified":1639130303296},{"_id":"public/tags/git/index.html","hash":"a4f4bb9c028af52ce8c0d87ab1c99bebf7338458","modified":1639130303296},{"_id":"public/tags/IO/index.html","hash":"624f3e418d5492550c9d6cab465578f778d0e8bc","modified":1639130303296},{"_id":"public/tags/nginx/index.html","hash":"d5f96017354830afa23b2db35637c04ceb81f381","modified":1639130303296},{"_id":"public/tags/redis/index.html","hash":"7c324e1ec7e7282d54b9e615739836f715e555f5","modified":1639130303296},{"_id":"public/tags/finance/index.html","hash":"d878d8219e994e2358d935f81d79f2c29d29dc55","modified":1639130303296},{"_id":"public/tags/source-code/index.html","hash":"2a3a03252106399fe6b66f1f9f49067f76448aac","modified":1639130303296},{"_id":"public/tags/java/index.html","hash":"c44abe480c00fc471207010e6b788ae75a9c141e","modified":1639130303296},{"_id":"public/tags/spring/index.html","hash":"02793e6a856be9262d456d1fe6191fed478abf16","modified":1639130303296},{"_id":"public/tags/mysql/index.html","hash":"5f923cc8fab5cf74eba2f3d106e05072c9e7c474","modified":1639130303296},{"_id":"public/tags/http/index.html","hash":"197f3d2521c906bcaf8799ce286db48824baf4f9","modified":1639130303296},{"_id":"public/tags/netty/index.html","hash":"a94fba870c5b8dc90b8d37e33ff853ed8c47f6f0","modified":1639130303296},{"_id":"public/CNAME","hash":"fa4ed0bd15b8167ee4e134821e3bb58a69a4d1a9","modified":1639130303296},{"_id":"public/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1639130303296},{"_id":"public/img/avatar/avatar.png","hash":"e6c1c40fb523d94779d95aa2dc7bf0b4259bacf2","modified":1639130303296},{"_id":"public/img/signature/vicky-white.png","hash":"efb6c7e1ccbded551759c9997b108a20c15f0c09","modified":1639130303296},{"_id":"public/img/avatar/fatpeople.jpg","hash":"04cc046c50473ab78aee784df62f05448be8b884","modified":1639130303296},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1639130303296},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1639130303296},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1639130303296},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1639130303296},{"_id":"public/img/1-work/tools/create_gitee_repo.png","hash":"ebd7bd2ba944d5428c2f8b0f58e2d4477952ee63","modified":1639130303296},{"_id":"public/img/1-work/tools/import-github-repo.png","hash":"4ecfeb1dd598d0a17e278da065c38a5523823250","modified":1639130303296},{"_id":"public/css/images/beside_up.png","hash":"183d87f1a99e93fc663ec798fa8c94cb87c83bcb","modified":1639130303296},{"_id":"public/css/images/beside_up2.png","hash":"ef066ba2e93a4738df45ae05020726e066c4dd1f","modified":1639130303296},{"_id":"public/css/images/beside_up_white.png","hash":"49c5922a8de63dcf9468fbcffc70d2ec36b1b527","modified":1639130303296},{"_id":"public/css/images/beside_up_white2.png","hash":"52e9d5715def1d3d09ab076d5eb3d22916d8f7d7","modified":1639130303296},{"_id":"public/img/avatar/about-me.jpg","hash":"4fc7c645f502bb38cb2a672bd95d478e8be0493a","modified":1639130303296},{"_id":"public/img/header_img/home-bg.jpg","hash":"6bbe3de397f929a7ca0a49c88779a4a8dd904a88","modified":1639130303296},{"_id":"public/img/header_img/post-bg-desk.jpg","hash":"6bbe3de397f929a7ca0a49c88779a4a8dd904a88","modified":1639130303296},{"_id":"public/img/header_img/categories_bg.jpg","hash":"a8a46a06f566e13a919d9cbca6a66ae5a3b78b1e","modified":1639130303296},{"_id":"public/img/scenery/about_bg.jpg","hash":"462c14b9b00ab2153e579f14cb1e44aa56704ce8","modified":1639130303296},{"_id":"public/img/scenery/about_bg4.jpg","hash":"272f0d4233aea38f32311439f8528d2b3bebd546","modified":1639130303296},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1639130303296},{"_id":"public/img/header_img/archive_bg.jpg","hash":"fc4bdf7fa98346ea35115151e4914cd1e5a946d9","modified":1639130303296},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1639130303296},{"_id":"public/css/highlight.css","hash":"03d1f0a648e9bdf7b1f57d217313cbac5d0c7eb1","modified":1639130303296},{"_id":"public/css/highlight_normal.css","hash":"6a40a9a0f268fb17d9002cb49a16946444ef5f34","modified":1639130303296},{"_id":"public/css/livemylife.css","hash":"dbf2b89627f55e7f8ef12730e822319859f25767","modified":1639130303296},{"_id":"public/css/rocket.css","hash":"ec8abdba1cdd362d03fd8ffe182213aa4cbd449c","modified":1639130303296},{"_id":"public/css/search.css","hash":"a941f2f3d05d43e0a1517ae6923e848638b9ff7c","modified":1639130303296},{"_id":"public/css/scroll.css","hash":"254c14f514de149e1d95a9c583e8af0dbacb306d","modified":1639130303296},{"_id":"public/css/top.css","hash":"0303375fbe2ca942cd3d86f31d12fef9bf5785af","modified":1639130303296},{"_id":"public/css/viewer.min.css","hash":"0e045aa3df1be7d138caa701ec3aa623ccc7a52d","modified":1639130303296},{"_id":"public/css/wave.css","hash":"041f3b4a78e2840ba17679cea05fb14bb646722f","modified":1639130303296},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1639130303296},{"_id":"public/js/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1639130303296},{"_id":"public/js/catalog.js","hash":"059f3f31492e5b1a9dddf422a48c32969d247415","modified":1639130303296},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1639130303296},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1639130303296},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1639130303296},{"_id":"public/js/scroll.js","hash":"265a4c4fc33b5b44b620db64ff31d2bc05d233e9","modified":1639130303296},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1639130303296},{"_id":"public/js/themecolor.js","hash":"8295e112233778d8f20c31b06c19659f60edbb22","modified":1639130303296},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1639130303296},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1639130303296},{"_id":"public/css/catalog.css","hash":"2062bf4e5b219654e0d4bf470f5eef1be213da95","modified":1639130303296},{"_id":"public/js/echarts/china-contour.js","hash":"46069d796fb1dd191cdd6a0806570700ae9c0347","modified":1639130303296},{"_id":"public/js/viewer/pic-viewer.js","hash":"9bf7c37cce781628346803ed7ce8f02623c2d013","modified":1639130303296},{"_id":"public/js/src/chinamap.js","hash":"37bb53e16eca9e5f0f8ff1b5581286d651aec3b4","modified":1639130303296},{"_id":"public/js/echarts/province/aomen.js","hash":"8558d9a5bf394a03d93ea85159c828d23b9b56d6","modified":1639130303296},{"_id":"public/js/echarts/province/ningxia.js","hash":"c25daa696558129fe018ff7c5de6126eabfda663","modified":1639130303296},{"_id":"public/js/echarts/province/shanghai.js","hash":"456974123ab5ed51993e6e7fba8f200f556c0751","modified":1639130303296},{"_id":"public/js/echarts/province/tianjin.js","hash":"c0f4bb6ae03bd3175203fd9cd70983059a3a636f","modified":1639130303296},{"_id":"public/js/echarts/province/xianggang.js","hash":"c34ca0c6974964b776ab64aff135a6630dac86ed","modified":1639130303296},{"_id":"public/baidu_verify_code-jayy2pLM52.html","hash":"58fc353e353e2dedb8bcd7f9ffe62ec1b2ba81d7","modified":1639130303296},{"_id":"public/baidu_verify_code-rpJMBPgyFA.html","hash":"7ee3e15a6b854a6f1131bf731fff4c9d61b8f431","modified":1639130303296},{"_id":"public/google0915f5e354aeae89.html","hash":"dacc570438035c30f92d0c9d97eacc9b0f09cc46","modified":1639130303296},{"_id":"public/css/beantech.min.css","hash":"66f124242893cae4517119e39e75d7f23eef01ae","modified":1639130303296},{"_id":"public/css/beantech.css","hash":"c192d3170301f774fa4c2185dc125cb3d6ec4929","modified":1639130303296},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1639130303296},{"_id":"public/css/gitalk.css","hash":"51783fd60dff05e8e339ff83b41504538662f6ca","modified":1639130303296},{"_id":"public/css/themecolor.css","hash":"725b0e534f7c6c80e2e9a47d1c93ee9f03d7458a","modified":1639130303296},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1639130303296},{"_id":"public/js/ziploader.js","hash":"9c25324caf53b56cb68839dcfb34e61e5a6a63f3","modified":1639130303296},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1639130303296},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1639130303296},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1639130303296},{"_id":"public/js/viewer/viewer.min.js","hash":"ae5380974b6fb8b0e15356c8418186c6c0821222","modified":1639130303296},{"_id":"public/js/echarts/china.js","hash":"0aaf91ed666621d0aa269d4ee5e1c0a9dc06235e","modified":1639130303296},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1639130303296},{"_id":"public/js/echarts/province/beijing.js","hash":"1f33aeb4ff666ceefa75c304f3f853f5dd3591a1","modified":1639130303296},{"_id":"public/js/echarts/province/anhui.js","hash":"a17708654277222014c1ba7005dd58bc7b6d54ce","modified":1639130303296},{"_id":"public/js/echarts/province/fujian.js","hash":"9c125baa9912134be8b28336ef70cdec842f195a","modified":1639130303296},{"_id":"public/js/echarts/province/guangxi.js","hash":"31ed274566e6369e568be67588033f43c2e902be","modified":1639130303296},{"_id":"public/js/echarts/province/guizhou.js","hash":"9eac20cb6f36e717d364ca2c4860292b8fe1128e","modified":1639130303296},{"_id":"public/js/echarts/province/hainan.js","hash":"10b313c1fdfe1a966163c92c333a766e10e96d27","modified":1639130303296},{"_id":"public/js/echarts/province/hebei.js","hash":"d76f7ffba58d553d50acba3114c9cc776d0d59e4","modified":1639130303296},{"_id":"public/js/echarts/province/chongqing.js","hash":"55661b00c1bfc3d505466c6b3c9a06df826ffa45","modified":1639130303296},{"_id":"public/js/echarts/province/henan.js","hash":"a7c25e0f04470c5da5f36d70738156c35228ef7e","modified":1639130303296},{"_id":"public/js/echarts/province/jiangsu.js","hash":"15a2820d2b1829614befd24fde73b69568ff7d4f","modified":1639130303296},{"_id":"public/js/echarts/province/hunan.js","hash":"b49abde15a3e60ae3898c0f2f5989c7a759c20c2","modified":1639130303296},{"_id":"public/js/echarts/province/hubei.js","hash":"4797d4615ee167b8711091ab4eea1e97a4c545bd","modified":1639130303296},{"_id":"public/js/echarts/province/jiangxi.js","hash":"dc078183c43df9e91cfb46b02e9e7fdcb7a96ca3","modified":1639130303296},{"_id":"public/js/echarts/province/jilin.js","hash":"737c4416708b1ef3b49be328ed7a9896439df1d3","modified":1639130303296},{"_id":"public/js/echarts/province/liaoning.js","hash":"250fbaa3cb8297139e348249243eab6b277d24b6","modified":1639130303296},{"_id":"public/js/echarts/province/shanxi.js","hash":"da043410b84996e2fc7c27b8010497ad45a9e464","modified":1639130303296},{"_id":"public/js/echarts/province/neimenggu.js","hash":"f26fcccdce99132d24c54f99d52179a11b30269a","modified":1639130303296},{"_id":"public/js/echarts/province/taiwan.js","hash":"1a18b39463a2a15dfb96d1823f84bd91b0099a04","modified":1639130303296},{"_id":"public/js/echarts/province/shanxi1.js","hash":"d16d41750d066776846329dd44691d39cc9a133e","modified":1639130303296},{"_id":"public/js/echarts/province/gansu.js","hash":"e030cf4fbe48b2467176771dbee9adc4111f47de","modified":1639130303296},{"_id":"public/js/echarts/province/zhejiang.js","hash":"4768c4a4aee38ff6f2568fe8c7b33a3555145220","modified":1639130303296},{"_id":"public/js/echarts/province/guangdong.js","hash":"e199d2277a076aafea04e8531ed621b792ae63cd","modified":1639130303296},{"_id":"public/js/echarts/province/heilongjiang.js","hash":"bd0453fc68288a5f1886ce233a54823377e73132","modified":1639130303296},{"_id":"public/js/echarts/province/qinghai.js","hash":"25dd767a0d1ddbea6db57f0ab86ab315215dec1d","modified":1639130303296},{"_id":"public/js/echarts/province/shandong.js","hash":"2f8035028a27dc47fe85bb8c8f3700c08c546a55","modified":1639130303296},{"_id":"public/js/echarts/province/sichuan.js","hash":"917d59cccf0a4eb98ae71f3e4ef5b5e508415352","modified":1639130303296},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1639130303296},{"_id":"public/js/echarts/province/xizang.js","hash":"9e51acbff27c6b4664dbaf37adcfb851e8acd025","modified":1639130303296},{"_id":"public/js/echarts/province/xinjiang.js","hash":"f432c61109275274fac2c20e69103f6c96f287c9","modified":1639130303296},{"_id":"public/js/echarts/province/yunnan.js","hash":"183aeee5c67ea236a51bf31ad1e89aeb2feacd4b","modified":1639130303296},{"_id":"public/js/echarts/world.js","hash":"7c57299eabf0e80868d447830ddfef1290695193","modified":1639130303296},{"_id":"public/img/header_img/ebooks-bg.jpg","hash":"84b61541d90457dbc74fd3a6aa91029e61524a2a","modified":1639130303296},{"_id":"public/img/scenery/treat_me_to_coffee.jpg","hash":"e307178429b98962ff3918e12427b3e7db6d10df","modified":1639130303296},{"_id":"public/img/header_img/post-bg-swift.jpg","hash":"12552e545ca35a93f0050a5417de5d302f1a4f5e","modified":1639130303296},{"_id":"public/js/echarts/echarts.min.js","hash":"eec6c0cc35c819602747de4574b4d77a773ae6bc","modified":1639130303296},{"_id":"public/js/comment/gitalk.js","hash":"560f027317869f39da9d13b0393e3bf98d081b12","modified":1639130303296},{"_id":"public/img/header_img/404_bg.jpg","hash":"e51ce60c4e13cfd57c825d241dae23ac988cd796","modified":1639130303296},{"_id":"public/img/header_img/tag_bg.jpg","hash":"35131c8b7ab3943c9fe4577329cd1c412d1c4fac","modified":1639130303296},{"_id":"public/img/header_img/dawn.jpg","hash":"2e9291c0a9d255c203fb11fd4f471b28459287b0","modified":1639130303296},{"_id":"public/img/scenery/about_bg2.jpg","hash":"bdffbe6a94f9c5be1b9353fc2b4f28a74677939f","modified":1639130303296},{"_id":"public/img/avatar/roguerabbit.jpg","hash":"3c71801016fc2b587c128d42f45438f523bb1a1a","modified":1639130303296},{"_id":"public/img/header_img/squirrel.jpg","hash":"6d9fe36a3a2d362fa2308e894088a11b39426c96","modified":1639130303296}],"Category":[{"name":"work","_id":"ckx07v1al0003acbf5cqqalcq"},{"name":"life","_id":"ckx07v1aw000jacbf39na7hxg"}],"Data":[],"Page":[{"layout":"404","description":"I'm sorry there is nothing that you want , but you can enjoy the scenery here ...","header-img":"img/header_img/404_bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"I'm sorry there is nothing that you want , but you can enjoy the scenery here ...\"\nheader-img: \"img/header_img/404_bg.jpg\"\n---\n","date":"2021-12-10T09:05:27.057Z","updated":"2021-12-10T09:05:27.057Z","path":"404.html","title":"","comments":1,"_id":"ckx07v19a0000acbfaf1qhe54","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"EBooks","description":"Good Reads.","header-img":"img/header_img/ebooks-bg.jpg","abbrlink":"4635","_content":"\n### [凤凰架构](https://icyfenix.cn/) - 构筑可靠的大型分布式系统\n\n**------ by 周志明**\n\n------\n\n### [labuladong 的算法小抄](https://labuladong.gitee.io/algo/)\n\n\n\n\n\n\n","source":"ebooks/index.md","raw":"---\ntitle: EBooks\ndescription: Good Reads.\nheader-img: img/header_img/ebooks-bg.jpg\nabbrlink: '4635'\n---\n\n### [凤凰架构](https://icyfenix.cn/) - 构筑可靠的大型分布式系统\n\n**------ by 周志明**\n\n------\n\n### [labuladong 的算法小抄](https://labuladong.gitee.io/algo/)\n\n\n\n\n\n\n","date":"2021-12-10T09:05:27.058Z","updated":"2021-12-10T09:05:27.058Z","path":"ebooks/index.html","comments":1,"layout":"page","_id":"ckx07v1bq001uacbffn6thput","content":"<h3 id=\"凤凰架构-构筑可靠的大型分布式系统\"><a href=\"#凤凰架构-构筑可靠的大型分布式系统\" class=\"headerlink\" title=\"凤凰架构 - 构筑可靠的大型分布式系统\"></a><a href=\"https://icyfenix.cn/\" target=\"_blank\" rel=\"noopener\">凤凰架构</a> - 构筑可靠的大型分布式系统</h3><p><strong>—— by 周志明</strong></p>\n<hr>\n<h3 id=\"labuladong-的算法小抄\"><a href=\"#labuladong-的算法小抄\" class=\"headerlink\" title=\"labuladong 的算法小抄\"></a><a href=\"https://labuladong.gitee.io/algo/\" target=\"_blank\" rel=\"noopener\">labuladong 的算法小抄</a></h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"凤凰架构-构筑可靠的大型分布式系统\"><a href=\"#凤凰架构-构筑可靠的大型分布式系统\" class=\"headerlink\" title=\"凤凰架构 - 构筑可靠的大型分布式系统\"></a><a href=\"https://icyfenix.cn/\" target=\"_blank\" rel=\"noopener\">凤凰架构</a> - 构筑可靠的大型分布式系统</h3><p><strong>—— by 周志明</strong></p>\n<hr>\n<h3 id=\"labuladong-的算法小抄\"><a href=\"#labuladong-的算法小抄\" class=\"headerlink\" title=\"labuladong 的算法小抄\"></a><a href=\"https://labuladong.gitee.io/algo/\" target=\"_blank\" rel=\"noopener\">labuladong 的算法小抄</a></h3>"},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","description":"Sleep early. Please.","header-img":"img/header_img/post-bg-swift.jpg","_content":"\n## Follow With Interest Blogs\n\n> Sage Renn：https://sagerenn.github.io/\n\n\n## Contact me\n\n> Email：vicky123.luo@outlook.com\n\n## Treat me to coffee\n>  If you feel that what I have written is of some value to you, I am glad that you are willing to invite me to drink coffee...\n\n<img src=\"../img/scenery/treat_me_to_coffee.jpg\" width=\"350\" alt=\"treat_me_to_coffee.jpg\"></img>\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Sleep early. Please.\"\nheader-img: \"img/header_img/post-bg-swift.jpg\"\n---\n\n## Follow With Interest Blogs\n\n> Sage Renn：https://sagerenn.github.io/\n\n\n## Contact me\n\n> Email：vicky123.luo@outlook.com\n\n## Treat me to coffee\n>  If you feel that what I have written is of some value to you, I am glad that you are willing to invite me to drink coffee...\n\n<img src=\"../img/scenery/treat_me_to_coffee.jpg\" width=\"350\" alt=\"treat_me_to_coffee.jpg\"></img>\n","updated":"2021-12-10T09:05:27.058Z","path":"about/index.html","comments":1,"_id":"ckx07v1br001wacbfh08abx6p","content":"<h2 id=\"Follow-With-Interest-Blogs\"><a href=\"#Follow-With-Interest-Blogs\" class=\"headerlink\" title=\"Follow With Interest Blogs\"></a>Follow With Interest Blogs</h2><blockquote>\n<p>Sage Renn：<a href=\"https://sagerenn.github.io/\" target=\"_blank\" rel=\"noopener\">https://sagerenn.github.io/</a></p>\n</blockquote>\n<h2 id=\"Contact-me\"><a href=\"#Contact-me\" class=\"headerlink\" title=\"Contact me\"></a>Contact me</h2><blockquote>\n<p>Email：<a href=\"mailto:vicky123.luo@outlook.com\">vicky123.luo@outlook.com</a></p>\n</blockquote>\n<h2 id=\"Treat-me-to-coffee\"><a href=\"#Treat-me-to-coffee\" class=\"headerlink\" title=\"Treat me to coffee\"></a>Treat me to coffee</h2><blockquote>\n<p> If you feel that what I have written is of some value to you, I am glad that you are willing to invite me to drink coffee…</p>\n</blockquote>\n<p><img src=\"../img/scenery/treat_me_to_coffee.jpg\" width=\"350\" alt=\"treat_me_to_coffee.jpg\"></img></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Follow-With-Interest-Blogs\"><a href=\"#Follow-With-Interest-Blogs\" class=\"headerlink\" title=\"Follow With Interest Blogs\"></a>Follow With Interest Blogs</h2><blockquote>\n<p>Sage Renn：<a href=\"https://sagerenn.github.io/\" target=\"_blank\" rel=\"noopener\">https://sagerenn.github.io/</a></p>\n</blockquote>\n<h2 id=\"Contact-me\"><a href=\"#Contact-me\" class=\"headerlink\" title=\"Contact me\"></a>Contact me</h2><blockquote>\n<p>Email：<a href=\"mailto:vicky123.luo@outlook.com\">vicky123.luo@outlook.com</a></p>\n</blockquote>\n<h2 id=\"Treat-me-to-coffee\"><a href=\"#Treat-me-to-coffee\" class=\"headerlink\" title=\"Treat me to coffee\"></a>Treat me to coffee</h2><blockquote>\n<p> If you feel that what I have written is of some value to you, I am glad that you are willing to invite me to drink coffee…</p>\n</blockquote>\n<p><img src=\"../img/scenery/treat_me_to_coffee.jpg\" width=\"350\" alt=\"treat_me_to_coffee.jpg\"></img></p>\n"},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive_bg.jpg","date":"2020-12-23T04:49:56.000Z","description":"Stay hungry, stay foolish.","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive_bg.jpg\"\ndate: 2020-12-23 12:49:56\ndescription: \"Stay hungry, stay foolish.\"\n---\n","updated":"2021-12-10T09:05:27.058Z","path":"archive/index.html","comments":1,"_id":"ckx07v1bv001zacbfe0it9ddr","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"categories","title":"Categories","description":"Life should be easy.","header-img":"img/header_img/categories_bg.jpg","_content":"","source":"categories/index.md","raw":"---\nlayout: \"categories\"\ntitle: \"Categories\"\ndescription: \"Life should be easy.\"\nheader-img: \"img/header_img/categories_bg.jpg\"\n---\n","date":"2021-12-10T09:05:27.058Z","updated":"2021-12-10T09:05:27.058Z","path":"categories/index.html","comments":1,"_id":"ckx07v1bw0021acbf4n10cfuv","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Make life better.","header-img":"img/header_img/tag_bg.jpg","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Make life better.\"\nheader-img: \"img/header_img/tag_bg.jpg\"\n---\n","date":"2021-12-10T09:05:27.353Z","updated":"2021-12-10T09:05:27.353Z","path":"tags/index.html","comments":1,"_id":"ckx07v1bx0025acbf7eblggiv","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"数据结构和算法大纲","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":1,"abbrlink":"2312","date":"2020-11-26T09:33:24.000Z","subtitle":null,"_content":"\n# 数据结构\n\n## 一、线性表\n\n### 1. 数组\n\n-  动态数组\n\n### 2. 链表\n\n-  单链表\n-  双向链表\n-  循环链表\n-  双向循环链表\n-  静态链表\n\n### 3. 栈\n\n-  顺序栈\n-  链式栈\n\n### 4. 队列\n\n-  普通队列\n-  双端队列\n-  阻塞队列\n-  并发队列\n-  阻塞并发队列\n\n## 二、散列表\n\n### 1. 散列函数\n\n### 2. 冲突解决\n\n-  链表法\n-  开放寻址\n-  其他\n\n### 3. 动态扩容\n\n### 4. 位图\n\n## 三、树\n\n### 1. 二叉树\n\n-  平衡二叉树\n-  二叉查找树\n-  平衡二叉查找树\n\n    - AVL树\n    - 红黑树\n\n-  完全二叉树\n-  满二叉树\n\n### 2. 多路查找树\n\n-  B树\n-  B+树\n-  2-3树\n-  2-3-4树\n\n### 3. 堆\n\n-  小顶堆\n-  大顶堆\n-  优先级队列\n\n    - 与普通队列区别：保证每次取出的元素是队列中优先级最高的，优先级别克自定义\n    - 常用场景：从杂乱的数据中按照一定顺序筛选数据\n    - 本质：二叉堆结构，binary heap. 利用数组来实现完全二叉树\n    - 特性\n\n        - 1.数组中第一个元素拥有最高优先级\n        - 2.给定下标i，那么对于arr[i]：\n\n            -  1）父节点：对应元素下标为（i - 1）/ 2\n            -  2）左侧子节点：对应下标为2*i + 1\n            -  3）右侧子结点：对应下标为2*i + 2\n\n        - 3.每个元素的优先级都必须高于两侧子节点\n\n    - 基本操作\n\n        - 1.向上筛选（shift up / bubble up）\n        - 2.向下筛选 （shift down / bubble down）\n\n    - 时间复杂度：\n        长度为n的数组，取前k个：O（logn）\n        初始化：O(k)\n    - Leetcode\n\n        - [347. 前 K 个高频元素-中等](https://leetcode-cn.com/problems/top-k-frequent-elements/)\n\n-  斐波那契堆\n-  二项堆\n\n-  其他\n\n    - 树状数组 Binary Indexed Tree\n\n        - 求数组中前K个元素的总和（或平均值）\n        - LeetCode\n\n    - 线段树Segment Tree\n\n        - 按照二叉树的形式存储数据的结构，每个结点保存数组中某一段的总和\n        - Leetcode \n\n            - [315. 计算右侧小于当前元素的个数-困难](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)\n\n## 四、图\n\n### 1. 图的存储\n\n-  邻接矩阵\n-  邻接表\n\n### 2. 拓扑排序\n\n### 3. 最短路径\n\n### 4. 关键路径\n\n### 5. 最小生成树\n\n### 6. 二分图\n\n### 7. 最大流\n\n# 算法\n\n## 一、复杂度\n\n### 1. 时间复杂度\n\n- 如何分析\n\n    - 1. 只关注循环执行次数最多的一段代码\n    - 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度\n    - 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n- 常见时间复杂度实例分析\n\n    ![image-20210917165515820](https://tva2.sinaimg.cn/large/006YzKDNly1gujq7ui7kaj60vq0fwadg02.jpg)\n\n    - 1. O(1)\n\n        - 一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。\n\n    - 2. O(logn)、O(nlogn)\n\n        - i=1; while (i <= n) { i = i * 2; }\n            在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。\n        - 如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。归并排序、快速排序的时间复杂度都是 O(nlogn)\n\n    - 3. O(m+n)、O(m*n)\n\n        - 代码的复杂度由两个数据的规模来决定，无法事先评估 m 和 n 谁的量级大\n\n### 2. 空间复杂度\n\n- 时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。\n- 常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。\n\n### 3. Tips\n\n- 越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n^2 )。\n\n    ![image-20210917165700182](https://tvax2.sinaimg.cn/large/006YzKDNly1gujq9nxktgj60vq0hsgno02.jpg)\n\n## 二、基本算法思想\n\n### 1. 贪心算法\n\n### 2. 分治算法\n\n- 快排、归并\n- 在O(n)内查找一个无序数组中第K大元素\n\n### 3. 动态规划\n\n### 4. 回溯算法\n\n### 5. 枚举算法\n\n## 三、排序\n\n![image-20210917165757241](https://tva3.sinaimg.cn/large/006YzKDNly1gujqana3gej60vq0je42y02.jpg)\n\n### 1. O(n^2) \n\n![image-20210917165853155](https://tvax2.sinaimg.cn/large/006YzKDNly1gujqbw4ot7j60vq0g8dk802.jpg)\n\n- 冒泡排序\n\n    - 原地排序、稳定排序\n\n- 插入排序\n\n    - 原地排序、稳定排序\n    - leetcode:\n\n    [147. 对链表进行插入排序-中等](https://leetcode-cn.com/problems/insertion-sort-list/)\n\n- 选择排序\n\n    - 原地、不稳定\n\n- 希尔排序\n\n### 2. O(nlogn)\n\n![image-20210917165958632](https://tvax3.sinaimg.cn/large/006YzKDNly1gujqcqpdquj60vq0l1wl602.jpg)\n\n-  归并排序\n\n    - 分治思想、递归实现\n    - 稳定排序、非原地排序，空间复杂度高O(n)\n    - 先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。\n    - 递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))\n        终止条件：p >= r 不用再继续分解\n    - 处理过程从下到上个，先处理子问题，再合并\n\n-  快速排序\n\n    - 分治思想、递归实现\n    - 原地排序，空间复杂度O(1)，不稳定\n    - 选择 p 到 r 之间的任意一个数据作为 pivot（分区点），遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，大于 pivot 的放到右边， pivot 放到中间。根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1\n    - 递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)\n        终止条件：p >= r\n    - 处理过程从上到下，先分区，再处理子问题\n\n-  堆排序\n\n### 3. O(n)\n\n- 计数排序\n    - 1.算法原理\n        1）计数其实就是桶排序的一种特殊情况。\n        2）当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶\n        3）每个桶内的数据值都是相同的，就省掉了桶内排序的时间。\n    - 2.使用条件\n        1）只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序；\n        2）计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数；\n        3）比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数。\n    - 2. 案例分析：\n            假设只有8个考生分数在0-5分之间，成绩存于数组A[8] = [2，5，3，0，2，3，0，3]。\n            使用大小为6的数组C[6]表示桶，下标对应分数，即0，1，2，3，4，5。\n            C[6]存储的是考生人数，只需遍历一边考生分数，就可以得到C[6] = [2，0，2，3，0，1]。\n            对C[6]数组顺序求和则C[6]=[2，2，4，7，7，8]，c[k]存储的是小于等于分数k的考生个数。\n\n- 基数排序\n\n    - 1.算法原理（以排序10万个手机号为例来说明）\n        1）比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。\n        2）借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。\n        3）经过11次排序后，手机号码就变为有序的了。\n        4）每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。\n    - 2.使用条件\n        1）要求数据可以分割独立的“位”来比较；\n        2）位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了；\n        3）每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。\n\n- 桶排序\n\n    - 1.算法原理：\n        1）将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。\n        2）桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。\n    - 2.使用条件\n        1）要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。\n        2）数据在各个桶之间分布是均匀的。\n    - 3.适用场景\n        1）桶排序比较适合用在外部排序中。\n        2）外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中。\n    - 4.应用案例\n        1）需求描述：\n        有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序\n        但内存有限，仅几百MB\n        2）解决思路：\n        扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。\n        第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。\n        每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。\n        将100个小文件依次放入内存并用快排排序。\n        所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。\n        3）注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。\n\n## 四、搜索\n\n### 1. 深度优先搜索\n\n### 2. 广度优先搜索\n\n### 3. A*启发式搜索\n\n## 五、查找\n\n### 1. 线性表查找（二分查找）\n\n### 2. 树结构查找\n\n### 3. 散列表查找\n\n## 六、字符串匹配\n\n### 1. 朴素\n\n### 2. KMP\n\n### 3. Robin-karp\n\n### 4. Boyer-Moore\n\n### 5. AC自动机\n\n### 6. 前缀树（字典树）Trie\n\n- 用于字典查找：如给定一系列构成字典的字符串（个数为N），在字典中找出所有以“ABC”开头的字符串，其中最长的为M\n\n    - 暴力搜索：O(M*N)\n    - 前缀树：O(M)\n\n- 经典应用：搜索框自动补全、拼写检查、IP 路由 (最长前缀匹配)、九宫格打字预测\n\n- 特性\n\n    - 1.每个结点至少包含两个基本属性\n\n        - 1）children：数组或集合，罗列每个分支中包含的所有字符\n        - 2）isEnd：布尔值，表示该结点是否为某个字符串的结尾\n\n    - 2.根节点为空\n    - 3.除根结点外，其他节点都可能是单词的结尾，叶子结点一定是单词的结尾\n\n- 基本操作\n\n    - 1.向 Trie 树中插入键\n\n        ![image-20210917170051035](https://tvax3.sinaimg.cn/large/006YzKDNly1gujqdl7gvfj60xc0go42z02.jpg)\n\n        - 算法分析\n\n            - 从根开始搜索它对应于第一个键字符的链接。有两种情况：\n\n                - 1.链接存在。沿着链接移动到树的下一个子层。算法继续搜索下一个键字符。\n                - 2.链接不存在。创建一个新的节点，并将它与父节点的链接相连，该链接与当前的键字符相匹配\n                    重复以上步骤，直到到达键的最后一个字符，然后将当前节点标记为结束节点，算法完成。\n\n        - 复杂度分析\n\n            - 时间复杂度：O(m)，其中 m为键长。在算法的每次迭代中，我们要么检查要么创建一个节点，直到到达键尾。只需要 m次操作。\n            - 空间复杂度：O(m)。最坏的情况下，新插入的键和 Trie 树中已有的键没有公共前缀。此时需要添加 m 个结点，使用 O(m) 空间。\n\n    - 2.在 Trie 树中查找键\n\n        ![image-20210917170128796](https://tva4.sinaimg.cn/large/006YzKDNly1gujqe8598lj60lu0gon0902.jpg)\n\n        - 算法分析\n\n            - 每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始，。检查当前节点中与键字符对应的链接。有两种情况：\n\n            - 1. 存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。\n\n                - 2. 不存在链接。若已无键字符，且当前结点标记为 isEnd，则返回 true。否则有两种可能，均返回 false :\n\n                - 1）还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。\n                    - 2）没有键字符剩余，但当前结点没有标记为 isEnd。也就是说，待查找键只是Trie树中另一个键的前缀。\n\n        - 复杂度分析\n\n            - 时间复杂度 : O(m)。算法的每一步均搜索下一个键字符。最坏的情况下需要 m 次操作。\n            - 空间复杂度 : O(1)。\n\n- Leetcode \n\n    - [208. 实现 Trie (前缀树) -中等](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)\n    - [211. 添加与搜索单词 - 数据结构设计-中等](https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/)\n    - [212. 单词搜索 II-困难](https://leetcode-cn.com/problems/word-search-ii/)\n\n### 7. 后缀数组\n\n## 七、其他\n\n### 1. 数论\n\n### 2. 计算几何\n\n### 3. 概率分析\n\n### 4. 并查集\n\n### 5. 拓扑网络\n\n### 6. 矩阵计算\n\n### 7. 线性规划\n\n","source":"_posts/algorithm-datastructure-outline.md","raw":"---\ntitle: 数据结构和算法大纲\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop: 1\ntags:\n  - algorithm\n  - data structure\ncategories:\n  - work\nabbrlink: '2312'\ndate: 2020-11-26 17:33:24\nsubtitle:\n---\n\n# 数据结构\n\n## 一、线性表\n\n### 1. 数组\n\n-  动态数组\n\n### 2. 链表\n\n-  单链表\n-  双向链表\n-  循环链表\n-  双向循环链表\n-  静态链表\n\n### 3. 栈\n\n-  顺序栈\n-  链式栈\n\n### 4. 队列\n\n-  普通队列\n-  双端队列\n-  阻塞队列\n-  并发队列\n-  阻塞并发队列\n\n## 二、散列表\n\n### 1. 散列函数\n\n### 2. 冲突解决\n\n-  链表法\n-  开放寻址\n-  其他\n\n### 3. 动态扩容\n\n### 4. 位图\n\n## 三、树\n\n### 1. 二叉树\n\n-  平衡二叉树\n-  二叉查找树\n-  平衡二叉查找树\n\n    - AVL树\n    - 红黑树\n\n-  完全二叉树\n-  满二叉树\n\n### 2. 多路查找树\n\n-  B树\n-  B+树\n-  2-3树\n-  2-3-4树\n\n### 3. 堆\n\n-  小顶堆\n-  大顶堆\n-  优先级队列\n\n    - 与普通队列区别：保证每次取出的元素是队列中优先级最高的，优先级别克自定义\n    - 常用场景：从杂乱的数据中按照一定顺序筛选数据\n    - 本质：二叉堆结构，binary heap. 利用数组来实现完全二叉树\n    - 特性\n\n        - 1.数组中第一个元素拥有最高优先级\n        - 2.给定下标i，那么对于arr[i]：\n\n            -  1）父节点：对应元素下标为（i - 1）/ 2\n            -  2）左侧子节点：对应下标为2*i + 1\n            -  3）右侧子结点：对应下标为2*i + 2\n\n        - 3.每个元素的优先级都必须高于两侧子节点\n\n    - 基本操作\n\n        - 1.向上筛选（shift up / bubble up）\n        - 2.向下筛选 （shift down / bubble down）\n\n    - 时间复杂度：\n        长度为n的数组，取前k个：O（logn）\n        初始化：O(k)\n    - Leetcode\n\n        - [347. 前 K 个高频元素-中等](https://leetcode-cn.com/problems/top-k-frequent-elements/)\n\n-  斐波那契堆\n-  二项堆\n\n-  其他\n\n    - 树状数组 Binary Indexed Tree\n\n        - 求数组中前K个元素的总和（或平均值）\n        - LeetCode\n\n    - 线段树Segment Tree\n\n        - 按照二叉树的形式存储数据的结构，每个结点保存数组中某一段的总和\n        - Leetcode \n\n            - [315. 计算右侧小于当前元素的个数-困难](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)\n\n## 四、图\n\n### 1. 图的存储\n\n-  邻接矩阵\n-  邻接表\n\n### 2. 拓扑排序\n\n### 3. 最短路径\n\n### 4. 关键路径\n\n### 5. 最小生成树\n\n### 6. 二分图\n\n### 7. 最大流\n\n# 算法\n\n## 一、复杂度\n\n### 1. 时间复杂度\n\n- 如何分析\n\n    - 1. 只关注循环执行次数最多的一段代码\n    - 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度\n    - 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n- 常见时间复杂度实例分析\n\n    ![image-20210917165515820](https://tva2.sinaimg.cn/large/006YzKDNly1gujq7ui7kaj60vq0fwadg02.jpg)\n\n    - 1. O(1)\n\n        - 一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。\n\n    - 2. O(logn)、O(nlogn)\n\n        - i=1; while (i <= n) { i = i * 2; }\n            在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。\n        - 如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。归并排序、快速排序的时间复杂度都是 O(nlogn)\n\n    - 3. O(m+n)、O(m*n)\n\n        - 代码的复杂度由两个数据的规模来决定，无法事先评估 m 和 n 谁的量级大\n\n### 2. 空间复杂度\n\n- 时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。\n- 常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。\n\n### 3. Tips\n\n- 越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n^2 )。\n\n    ![image-20210917165700182](https://tvax2.sinaimg.cn/large/006YzKDNly1gujq9nxktgj60vq0hsgno02.jpg)\n\n## 二、基本算法思想\n\n### 1. 贪心算法\n\n### 2. 分治算法\n\n- 快排、归并\n- 在O(n)内查找一个无序数组中第K大元素\n\n### 3. 动态规划\n\n### 4. 回溯算法\n\n### 5. 枚举算法\n\n## 三、排序\n\n![image-20210917165757241](https://tva3.sinaimg.cn/large/006YzKDNly1gujqana3gej60vq0je42y02.jpg)\n\n### 1. O(n^2) \n\n![image-20210917165853155](https://tvax2.sinaimg.cn/large/006YzKDNly1gujqbw4ot7j60vq0g8dk802.jpg)\n\n- 冒泡排序\n\n    - 原地排序、稳定排序\n\n- 插入排序\n\n    - 原地排序、稳定排序\n    - leetcode:\n\n    [147. 对链表进行插入排序-中等](https://leetcode-cn.com/problems/insertion-sort-list/)\n\n- 选择排序\n\n    - 原地、不稳定\n\n- 希尔排序\n\n### 2. O(nlogn)\n\n![image-20210917165958632](https://tvax3.sinaimg.cn/large/006YzKDNly1gujqcqpdquj60vq0l1wl602.jpg)\n\n-  归并排序\n\n    - 分治思想、递归实现\n    - 稳定排序、非原地排序，空间复杂度高O(n)\n    - 先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。\n    - 递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))\n        终止条件：p >= r 不用再继续分解\n    - 处理过程从下到上个，先处理子问题，再合并\n\n-  快速排序\n\n    - 分治思想、递归实现\n    - 原地排序，空间复杂度O(1)，不稳定\n    - 选择 p 到 r 之间的任意一个数据作为 pivot（分区点），遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，大于 pivot 的放到右边， pivot 放到中间。根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1\n    - 递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)\n        终止条件：p >= r\n    - 处理过程从上到下，先分区，再处理子问题\n\n-  堆排序\n\n### 3. O(n)\n\n- 计数排序\n    - 1.算法原理\n        1）计数其实就是桶排序的一种特殊情况。\n        2）当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶\n        3）每个桶内的数据值都是相同的，就省掉了桶内排序的时间。\n    - 2.使用条件\n        1）只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序；\n        2）计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数；\n        3）比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数。\n    - 2. 案例分析：\n            假设只有8个考生分数在0-5分之间，成绩存于数组A[8] = [2，5，3，0，2，3，0，3]。\n            使用大小为6的数组C[6]表示桶，下标对应分数，即0，1，2，3，4，5。\n            C[6]存储的是考生人数，只需遍历一边考生分数，就可以得到C[6] = [2，0，2，3，0，1]。\n            对C[6]数组顺序求和则C[6]=[2，2，4，7，7，8]，c[k]存储的是小于等于分数k的考生个数。\n\n- 基数排序\n\n    - 1.算法原理（以排序10万个手机号为例来说明）\n        1）比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。\n        2）借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。\n        3）经过11次排序后，手机号码就变为有序的了。\n        4）每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。\n    - 2.使用条件\n        1）要求数据可以分割独立的“位”来比较；\n        2）位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了；\n        3）每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。\n\n- 桶排序\n\n    - 1.算法原理：\n        1）将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。\n        2）桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。\n    - 2.使用条件\n        1）要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。\n        2）数据在各个桶之间分布是均匀的。\n    - 3.适用场景\n        1）桶排序比较适合用在外部排序中。\n        2）外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中。\n    - 4.应用案例\n        1）需求描述：\n        有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序\n        但内存有限，仅几百MB\n        2）解决思路：\n        扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。\n        第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。\n        每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。\n        将100个小文件依次放入内存并用快排排序。\n        所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。\n        3）注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。\n\n## 四、搜索\n\n### 1. 深度优先搜索\n\n### 2. 广度优先搜索\n\n### 3. A*启发式搜索\n\n## 五、查找\n\n### 1. 线性表查找（二分查找）\n\n### 2. 树结构查找\n\n### 3. 散列表查找\n\n## 六、字符串匹配\n\n### 1. 朴素\n\n### 2. KMP\n\n### 3. Robin-karp\n\n### 4. Boyer-Moore\n\n### 5. AC自动机\n\n### 6. 前缀树（字典树）Trie\n\n- 用于字典查找：如给定一系列构成字典的字符串（个数为N），在字典中找出所有以“ABC”开头的字符串，其中最长的为M\n\n    - 暴力搜索：O(M*N)\n    - 前缀树：O(M)\n\n- 经典应用：搜索框自动补全、拼写检查、IP 路由 (最长前缀匹配)、九宫格打字预测\n\n- 特性\n\n    - 1.每个结点至少包含两个基本属性\n\n        - 1）children：数组或集合，罗列每个分支中包含的所有字符\n        - 2）isEnd：布尔值，表示该结点是否为某个字符串的结尾\n\n    - 2.根节点为空\n    - 3.除根结点外，其他节点都可能是单词的结尾，叶子结点一定是单词的结尾\n\n- 基本操作\n\n    - 1.向 Trie 树中插入键\n\n        ![image-20210917170051035](https://tvax3.sinaimg.cn/large/006YzKDNly1gujqdl7gvfj60xc0go42z02.jpg)\n\n        - 算法分析\n\n            - 从根开始搜索它对应于第一个键字符的链接。有两种情况：\n\n                - 1.链接存在。沿着链接移动到树的下一个子层。算法继续搜索下一个键字符。\n                - 2.链接不存在。创建一个新的节点，并将它与父节点的链接相连，该链接与当前的键字符相匹配\n                    重复以上步骤，直到到达键的最后一个字符，然后将当前节点标记为结束节点，算法完成。\n\n        - 复杂度分析\n\n            - 时间复杂度：O(m)，其中 m为键长。在算法的每次迭代中，我们要么检查要么创建一个节点，直到到达键尾。只需要 m次操作。\n            - 空间复杂度：O(m)。最坏的情况下，新插入的键和 Trie 树中已有的键没有公共前缀。此时需要添加 m 个结点，使用 O(m) 空间。\n\n    - 2.在 Trie 树中查找键\n\n        ![image-20210917170128796](https://tva4.sinaimg.cn/large/006YzKDNly1gujqe8598lj60lu0gon0902.jpg)\n\n        - 算法分析\n\n            - 每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始，。检查当前节点中与键字符对应的链接。有两种情况：\n\n            - 1. 存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。\n\n                - 2. 不存在链接。若已无键字符，且当前结点标记为 isEnd，则返回 true。否则有两种可能，均返回 false :\n\n                - 1）还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。\n                    - 2）没有键字符剩余，但当前结点没有标记为 isEnd。也就是说，待查找键只是Trie树中另一个键的前缀。\n\n        - 复杂度分析\n\n            - 时间复杂度 : O(m)。算法的每一步均搜索下一个键字符。最坏的情况下需要 m 次操作。\n            - 空间复杂度 : O(1)。\n\n- Leetcode \n\n    - [208. 实现 Trie (前缀树) -中等](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)\n    - [211. 添加与搜索单词 - 数据结构设计-中等](https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/)\n    - [212. 单词搜索 II-困难](https://leetcode-cn.com/problems/word-search-ii/)\n\n### 7. 后缀数组\n\n## 七、其他\n\n### 1. 数论\n\n### 2. 计算几何\n\n### 3. 概率分析\n\n### 4. 并查集\n\n### 5. 拓扑网络\n\n### 6. 矩阵计算\n\n### 7. 线性规划\n\n","slug":"algorithm-datastructure-outline","published":1,"updated":"2021-12-10T09:05:27.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1ah0001acbf9gged9mf","content":"<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"一、线性表\"><a href=\"#一、线性表\" class=\"headerlink\" title=\"一、线性表\"></a>一、线性表</h2><h3 id=\"1-数组\"><a href=\"#1-数组\" class=\"headerlink\" title=\"1. 数组\"></a>1. 数组</h3><ul>\n<li>动态数组</li>\n</ul>\n<h3 id=\"2-链表\"><a href=\"#2-链表\" class=\"headerlink\" title=\"2. 链表\"></a>2. 链表</h3><ul>\n<li>单链表</li>\n<li>双向链表</li>\n<li>循环链表</li>\n<li>双向循环链表</li>\n<li>静态链表</li>\n</ul>\n<h3 id=\"3-栈\"><a href=\"#3-栈\" class=\"headerlink\" title=\"3. 栈\"></a>3. 栈</h3><ul>\n<li>顺序栈</li>\n<li>链式栈</li>\n</ul>\n<h3 id=\"4-队列\"><a href=\"#4-队列\" class=\"headerlink\" title=\"4. 队列\"></a>4. 队列</h3><ul>\n<li>普通队列</li>\n<li>双端队列</li>\n<li>阻塞队列</li>\n<li>并发队列</li>\n<li>阻塞并发队列</li>\n</ul>\n<h2 id=\"二、散列表\"><a href=\"#二、散列表\" class=\"headerlink\" title=\"二、散列表\"></a>二、散列表</h2><h3 id=\"1-散列函数\"><a href=\"#1-散列函数\" class=\"headerlink\" title=\"1. 散列函数\"></a>1. 散列函数</h3><h3 id=\"2-冲突解决\"><a href=\"#2-冲突解决\" class=\"headerlink\" title=\"2. 冲突解决\"></a>2. 冲突解决</h3><ul>\n<li>链表法</li>\n<li>开放寻址</li>\n<li>其他</li>\n</ul>\n<h3 id=\"3-动态扩容\"><a href=\"#3-动态扩容\" class=\"headerlink\" title=\"3. 动态扩容\"></a>3. 动态扩容</h3><h3 id=\"4-位图\"><a href=\"#4-位图\" class=\"headerlink\" title=\"4. 位图\"></a>4. 位图</h3><h2 id=\"三、树\"><a href=\"#三、树\" class=\"headerlink\" title=\"三、树\"></a>三、树</h2><h3 id=\"1-二叉树\"><a href=\"#1-二叉树\" class=\"headerlink\" title=\"1. 二叉树\"></a>1. 二叉树</h3><ul>\n<li><p>平衡二叉树</p>\n</li>\n<li><p>二叉查找树</p>\n</li>\n<li><p>平衡二叉查找树</p>\n<ul>\n<li>AVL树</li>\n<li>红黑树</li>\n</ul>\n</li>\n<li><p>完全二叉树</p>\n</li>\n<li><p>满二叉树</p>\n</li>\n</ul>\n<h3 id=\"2-多路查找树\"><a href=\"#2-多路查找树\" class=\"headerlink\" title=\"2. 多路查找树\"></a>2. 多路查找树</h3><ul>\n<li>B树</li>\n<li>B+树</li>\n<li>2-3树</li>\n<li>2-3-4树</li>\n</ul>\n<h3 id=\"3-堆\"><a href=\"#3-堆\" class=\"headerlink\" title=\"3. 堆\"></a>3. 堆</h3><ul>\n<li><p>小顶堆</p>\n</li>\n<li><p>大顶堆</p>\n</li>\n<li><p>优先级队列</p>\n<ul>\n<li><p>与普通队列区别：保证每次取出的元素是队列中优先级最高的，优先级别克自定义</p>\n</li>\n<li><p>常用场景：从杂乱的数据中按照一定顺序筛选数据</p>\n</li>\n<li><p>本质：二叉堆结构，binary heap. 利用数组来实现完全二叉树</p>\n</li>\n<li><p>特性</p>\n<ul>\n<li><p>1.数组中第一个元素拥有最高优先级</p>\n</li>\n<li><p>2.给定下标i，那么对于arr[i]：</p>\n<ul>\n<li>1）父节点：对应元素下标为（i - 1）/ 2</li>\n<li>2）左侧子节点：对应下标为2*i + 1</li>\n<li>3）右侧子结点：对应下标为2*i + 2</li>\n</ul>\n</li>\n<li><p>3.每个元素的优先级都必须高于两侧子节点</p>\n</li>\n</ul>\n</li>\n<li><p>基本操作</p>\n<ul>\n<li>1.向上筛选（shift up / bubble up）</li>\n<li>2.向下筛选 （shift down / bubble down）</li>\n</ul>\n</li>\n<li><p>时间复杂度：<br>  长度为n的数组，取前k个：O（logn）<br>  初始化：O(k)</p>\n</li>\n<li><p>Leetcode</p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/top-k-frequent-elements/\" target=\"_blank\" rel=\"noopener\">347. 前 K 个高频元素-中等</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>斐波那契堆</p>\n</li>\n<li><p>二项堆</p>\n</li>\n<li><p>其他</p>\n<ul>\n<li><p>树状数组 Binary Indexed Tree</p>\n<ul>\n<li>求数组中前K个元素的总和（或平均值）</li>\n<li>LeetCode</li>\n</ul>\n</li>\n<li><p>线段树Segment Tree</p>\n<ul>\n<li><p>按照二叉树的形式存储数据的结构，每个结点保存数组中某一段的总和</p>\n</li>\n<li><p>Leetcode </p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/\" target=\"_blank\" rel=\"noopener\">315. 计算右侧小于当前元素的个数-困难</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"四、图\"><a href=\"#四、图\" class=\"headerlink\" title=\"四、图\"></a>四、图</h2><h3 id=\"1-图的存储\"><a href=\"#1-图的存储\" class=\"headerlink\" title=\"1. 图的存储\"></a>1. 图的存储</h3><ul>\n<li>邻接矩阵</li>\n<li>邻接表</li>\n</ul>\n<h3 id=\"2-拓扑排序\"><a href=\"#2-拓扑排序\" class=\"headerlink\" title=\"2. 拓扑排序\"></a>2. 拓扑排序</h3><h3 id=\"3-最短路径\"><a href=\"#3-最短路径\" class=\"headerlink\" title=\"3. 最短路径\"></a>3. 最短路径</h3><h3 id=\"4-关键路径\"><a href=\"#4-关键路径\" class=\"headerlink\" title=\"4. 关键路径\"></a>4. 关键路径</h3><h3 id=\"5-最小生成树\"><a href=\"#5-最小生成树\" class=\"headerlink\" title=\"5. 最小生成树\"></a>5. 最小生成树</h3><h3 id=\"6-二分图\"><a href=\"#6-二分图\" class=\"headerlink\" title=\"6. 二分图\"></a>6. 二分图</h3><h3 id=\"7-最大流\"><a href=\"#7-最大流\" class=\"headerlink\" title=\"7. 最大流\"></a>7. 最大流</h3><h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><h2 id=\"一、复杂度\"><a href=\"#一、复杂度\" class=\"headerlink\" title=\"一、复杂度\"></a>一、复杂度</h2><h3 id=\"1-时间复杂度\"><a href=\"#1-时间复杂度\" class=\"headerlink\" title=\"1. 时间复杂度\"></a>1. 时间复杂度</h3><ul>\n<li><p>如何分析</p>\n<ul>\n<li><ol>\n<li>只关注循环执行次数最多的一段代码</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>常见时间复杂度实例分析</p>\n<p>  <img src=\"https://tva2.sinaimg.cn/large/006YzKDNly1gujq7ui7kaj60vq0fwadg02.jpg\" alt=\"image-20210917165515820\"></p>\n<ul>\n<li><ol>\n<li><p>O(1)</p>\n<ul>\n<li>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li><p>O(logn)、O(nlogn)</p>\n<ul>\n<li>i=1; while (i &lt;= n) { i = i * 2; }<br> 在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</li>\n<li>如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。归并排序、快速排序的时间复杂度都是 O(nlogn)</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li><p>O(m+n)、O(m*n)</p>\n<ul>\n<li>代码的复杂度由两个数据的规模来决定，无法事先评估 m 和 n 谁的量级大</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-空间复杂度\"><a href=\"#2-空间复杂度\" class=\"headerlink\" title=\"2. 空间复杂度\"></a>2. 空间复杂度</h3><ul>\n<li>时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</li>\n<li>常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。</li>\n</ul>\n<h3 id=\"3-Tips\"><a href=\"#3-Tips\" class=\"headerlink\" title=\"3. Tips\"></a>3. Tips</h3><ul>\n<li><p>越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n^2 )。</p>\n<p>  <img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gujq9nxktgj60vq0hsgno02.jpg\" alt=\"image-20210917165700182\"></p>\n</li>\n</ul>\n<h2 id=\"二、基本算法思想\"><a href=\"#二、基本算法思想\" class=\"headerlink\" title=\"二、基本算法思想\"></a>二、基本算法思想</h2><h3 id=\"1-贪心算法\"><a href=\"#1-贪心算法\" class=\"headerlink\" title=\"1. 贪心算法\"></a>1. 贪心算法</h3><h3 id=\"2-分治算法\"><a href=\"#2-分治算法\" class=\"headerlink\" title=\"2. 分治算法\"></a>2. 分治算法</h3><ul>\n<li>快排、归并</li>\n<li>在O(n)内查找一个无序数组中第K大元素</li>\n</ul>\n<h3 id=\"3-动态规划\"><a href=\"#3-动态规划\" class=\"headerlink\" title=\"3. 动态规划\"></a>3. 动态规划</h3><h3 id=\"4-回溯算法\"><a href=\"#4-回溯算法\" class=\"headerlink\" title=\"4. 回溯算法\"></a>4. 回溯算法</h3><h3 id=\"5-枚举算法\"><a href=\"#5-枚举算法\" class=\"headerlink\" title=\"5. 枚举算法\"></a>5. 枚举算法</h3><h2 id=\"三、排序\"><a href=\"#三、排序\" class=\"headerlink\" title=\"三、排序\"></a>三、排序</h2><p><img src=\"https://tva3.sinaimg.cn/large/006YzKDNly1gujqana3gej60vq0je42y02.jpg\" alt=\"image-20210917165757241\"></p>\n<h3 id=\"1-O-n-2\"><a href=\"#1-O-n-2\" class=\"headerlink\" title=\"1. O(n^2)\"></a>1. O(n^2)</h3><p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gujqbw4ot7j60vq0g8dk802.jpg\" alt=\"image-20210917165853155\"></p>\n<ul>\n<li><p>冒泡排序</p>\n<ul>\n<li>原地排序、稳定排序</li>\n</ul>\n</li>\n<li><p>插入排序</p>\n<ul>\n<li><p>原地排序、稳定排序</p>\n</li>\n<li><p>leetcode:</p>\n<p><a href=\"https://leetcode-cn.com/problems/insertion-sort-list/\" target=\"_blank\" rel=\"noopener\">147. 对链表进行插入排序-中等</a></p>\n</li>\n</ul>\n</li>\n<li><p>选择排序</p>\n<ul>\n<li>原地、不稳定</li>\n</ul>\n</li>\n<li><p>希尔排序</p>\n</li>\n</ul>\n<h3 id=\"2-O-nlogn\"><a href=\"#2-O-nlogn\" class=\"headerlink\" title=\"2. O(nlogn)\"></a>2. O(nlogn)</h3><p><img src=\"https://tvax3.sinaimg.cn/large/006YzKDNly1gujqcqpdquj60vq0l1wl602.jpg\" alt=\"image-20210917165958632\"></p>\n<ul>\n<li><p>归并排序</p>\n<ul>\n<li>分治思想、递归实现</li>\n<li>稳定排序、非原地排序，空间复杂度高O(n)</li>\n<li>先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</li>\n<li>递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))<br>  终止条件：p &gt;= r 不用再继续分解</li>\n<li>处理过程从下到上个，先处理子问题，再合并</li>\n</ul>\n</li>\n<li><p>快速排序</p>\n<ul>\n<li>分治思想、递归实现</li>\n<li>原地排序，空间复杂度O(1)，不稳定</li>\n<li>选择 p 到 r 之间的任意一个数据作为 pivot（分区点），遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，大于 pivot 的放到右边， pivot 放到中间。根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1</li>\n<li>递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)<br>  终止条件：p &gt;= r</li>\n<li>处理过程从上到下，先分区，再处理子问题</li>\n</ul>\n</li>\n<li><p>堆排序</p>\n</li>\n</ul>\n<h3 id=\"3-O-n\"><a href=\"#3-O-n\" class=\"headerlink\" title=\"3. O(n)\"></a>3. O(n)</h3><ul>\n<li><p>计数排序</p>\n<ul>\n<li>1.算法原理<br>  1）计数其实就是桶排序的一种特殊情况。<br>  2）当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶<br>  3）每个桶内的数据值都是相同的，就省掉了桶内排序的时间。</li>\n<li>2.使用条件<br>  1）只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序；<br>  2）计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数；<br>  3）比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数。</li>\n<li><ol start=\"2\">\n<li>案例分析：<br>   假设只有8个考生分数在0-5分之间，成绩存于数组A[8] = [2，5，3，0，2，3，0，3]。<br>   使用大小为6的数组C[6]表示桶，下标对应分数，即0，1，2，3，4，5。<br>   C[6]存储的是考生人数，只需遍历一边考生分数，就可以得到C[6] = [2，0，2，3，0，1]。<br>   对C[6]数组顺序求和则C[6]=[2，2，4，7，7，8]，c[k]存储的是小于等于分数k的考生个数。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>基数排序</p>\n<ul>\n<li>1.算法原理（以排序10万个手机号为例来说明）<br>  1）比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。<br>  2）借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。<br>  3）经过11次排序后，手机号码就变为有序的了。<br>  4）每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。</li>\n<li>2.使用条件<br>  1）要求数据可以分割独立的“位”来比较；<br>  2）位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了；<br>  3）每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。</li>\n</ul>\n</li>\n<li><p>桶排序</p>\n<ul>\n<li>1.算法原理：<br>  1）将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。<br>  2）桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</li>\n<li>2.使用条件<br>  1）要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。<br>  2）数据在各个桶之间分布是均匀的。</li>\n<li>3.适用场景<br>  1）桶排序比较适合用在外部排序中。<br>  2）外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中。</li>\n<li>4.应用案例<br>  1）需求描述：<br>  有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序<br>  但内存有限，仅几百MB<br>  2）解决思路：<br>  扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。<br>  第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。<br>  每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。<br>  将100个小文件依次放入内存并用快排排序。<br>  所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。<br>  3）注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"四、搜索\"><a href=\"#四、搜索\" class=\"headerlink\" title=\"四、搜索\"></a>四、搜索</h2><h3 id=\"1-深度优先搜索\"><a href=\"#1-深度优先搜索\" class=\"headerlink\" title=\"1. 深度优先搜索\"></a>1. 深度优先搜索</h3><h3 id=\"2-广度优先搜索\"><a href=\"#2-广度优先搜索\" class=\"headerlink\" title=\"2. 广度优先搜索\"></a>2. 广度优先搜索</h3><h3 id=\"3-A-启发式搜索\"><a href=\"#3-A-启发式搜索\" class=\"headerlink\" title=\"3. A*启发式搜索\"></a>3. A*启发式搜索</h3><h2 id=\"五、查找\"><a href=\"#五、查找\" class=\"headerlink\" title=\"五、查找\"></a>五、查找</h2><h3 id=\"1-线性表查找（二分查找）\"><a href=\"#1-线性表查找（二分查找）\" class=\"headerlink\" title=\"1. 线性表查找（二分查找）\"></a>1. 线性表查找（二分查找）</h3><h3 id=\"2-树结构查找\"><a href=\"#2-树结构查找\" class=\"headerlink\" title=\"2. 树结构查找\"></a>2. 树结构查找</h3><h3 id=\"3-散列表查找\"><a href=\"#3-散列表查找\" class=\"headerlink\" title=\"3. 散列表查找\"></a>3. 散列表查找</h3><h2 id=\"六、字符串匹配\"><a href=\"#六、字符串匹配\" class=\"headerlink\" title=\"六、字符串匹配\"></a>六、字符串匹配</h2><h3 id=\"1-朴素\"><a href=\"#1-朴素\" class=\"headerlink\" title=\"1. 朴素\"></a>1. 朴素</h3><h3 id=\"2-KMP\"><a href=\"#2-KMP\" class=\"headerlink\" title=\"2. KMP\"></a>2. KMP</h3><h3 id=\"3-Robin-karp\"><a href=\"#3-Robin-karp\" class=\"headerlink\" title=\"3. Robin-karp\"></a>3. Robin-karp</h3><h3 id=\"4-Boyer-Moore\"><a href=\"#4-Boyer-Moore\" class=\"headerlink\" title=\"4. Boyer-Moore\"></a>4. Boyer-Moore</h3><h3 id=\"5-AC自动机\"><a href=\"#5-AC自动机\" class=\"headerlink\" title=\"5. AC自动机\"></a>5. AC自动机</h3><h3 id=\"6-前缀树（字典树）Trie\"><a href=\"#6-前缀树（字典树）Trie\" class=\"headerlink\" title=\"6. 前缀树（字典树）Trie\"></a>6. 前缀树（字典树）Trie</h3><ul>\n<li><p>用于字典查找：如给定一系列构成字典的字符串（个数为N），在字典中找出所有以“ABC”开头的字符串，其中最长的为M</p>\n<ul>\n<li>暴力搜索：O(M*N)</li>\n<li>前缀树：O(M)</li>\n</ul>\n</li>\n<li><p>经典应用：搜索框自动补全、拼写检查、IP 路由 (最长前缀匹配)、九宫格打字预测</p>\n</li>\n<li><p>特性</p>\n<ul>\n<li><p>1.每个结点至少包含两个基本属性</p>\n<ul>\n<li>1）children：数组或集合，罗列每个分支中包含的所有字符</li>\n<li>2）isEnd：布尔值，表示该结点是否为某个字符串的结尾</li>\n</ul>\n</li>\n<li><p>2.根节点为空</p>\n</li>\n<li><p>3.除根结点外，其他节点都可能是单词的结尾，叶子结点一定是单词的结尾</p>\n</li>\n</ul>\n</li>\n<li><p>基本操作</p>\n<ul>\n<li><p>1.向 Trie 树中插入键</p>\n<p>  <img src=\"https://tvax3.sinaimg.cn/large/006YzKDNly1gujqdl7gvfj60xc0go42z02.jpg\" alt=\"image-20210917170051035\"></p>\n<ul>\n<li><p>算法分析</p>\n<ul>\n<li><p>从根开始搜索它对应于第一个键字符的链接。有两种情况：</p>\n<ul>\n<li>1.链接存在。沿着链接移动到树的下一个子层。算法继续搜索下一个键字符。</li>\n<li>2.链接不存在。创建一个新的节点，并将它与父节点的链接相连，该链接与当前的键字符相匹配<br>  重复以上步骤，直到到达键的最后一个字符，然后将当前节点标记为结束节点，算法完成。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>复杂度分析</p>\n<ul>\n<li>时间复杂度：O(m)，其中 m为键长。在算法的每次迭代中，我们要么检查要么创建一个节点，直到到达键尾。只需要 m次操作。</li>\n<li>空间复杂度：O(m)。最坏的情况下，新插入的键和 Trie 树中已有的键没有公共前缀。此时需要添加 m 个结点，使用 O(m) 空间。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>2.在 Trie 树中查找键</p>\n<p>  <img src=\"https://tva4.sinaimg.cn/large/006YzKDNly1gujqe8598lj60lu0gon0902.jpg\" alt=\"image-20210917170128796\"></p>\n<ul>\n<li><p>算法分析</p>\n<ul>\n<li><p>每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始，。检查当前节点中与键字符对应的链接。有两种情况：</p>\n</li>\n<li><ol>\n<li><p>存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。</p>\n<ul>\n<li><ol start=\"2\">\n<li>不存在链接。若已无键字符，且当前结点标记为 isEnd，则返回 true。否则有两种可能，均返回 false :</li>\n</ol>\n</li>\n<li><p>1）还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。</p>\n<ul>\n<li>2）没有键字符剩余，但当前结点没有标记为 isEnd。也就是说，待查找键只是Trie树中另一个键的前缀。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>复杂度分析</p>\n<ul>\n<li>时间复杂度 : O(m)。算法的每一步均搜索下一个键字符。最坏的情况下需要 m 次操作。</li>\n<li>空间复杂度 : O(1)。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Leetcode </p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/implement-trie-prefix-tree/\" target=\"_blank\" rel=\"noopener\">208. 实现 Trie (前缀树) -中等</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/\" target=\"_blank\" rel=\"noopener\">211. 添加与搜索单词 - 数据结构设计-中等</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/word-search-ii/\" target=\"_blank\" rel=\"noopener\">212. 单词搜索 II-困难</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"7-后缀数组\"><a href=\"#7-后缀数组\" class=\"headerlink\" title=\"7. 后缀数组\"></a>7. 后缀数组</h3><h2 id=\"七、其他\"><a href=\"#七、其他\" class=\"headerlink\" title=\"七、其他\"></a>七、其他</h2><h3 id=\"1-数论\"><a href=\"#1-数论\" class=\"headerlink\" title=\"1. 数论\"></a>1. 数论</h3><h3 id=\"2-计算几何\"><a href=\"#2-计算几何\" class=\"headerlink\" title=\"2. 计算几何\"></a>2. 计算几何</h3><h3 id=\"3-概率分析\"><a href=\"#3-概率分析\" class=\"headerlink\" title=\"3. 概率分析\"></a>3. 概率分析</h3><h3 id=\"4-并查集\"><a href=\"#4-并查集\" class=\"headerlink\" title=\"4. 并查集\"></a>4. 并查集</h3><h3 id=\"5-拓扑网络\"><a href=\"#5-拓扑网络\" class=\"headerlink\" title=\"5. 拓扑网络\"></a>5. 拓扑网络</h3><h3 id=\"6-矩阵计算\"><a href=\"#6-矩阵计算\" class=\"headerlink\" title=\"6. 矩阵计算\"></a>6. 矩阵计算</h3><h3 id=\"7-线性规划\"><a href=\"#7-线性规划\" class=\"headerlink\" title=\"7. 线性规划\"></a>7. 线性规划</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"一、线性表\"><a href=\"#一、线性表\" class=\"headerlink\" title=\"一、线性表\"></a>一、线性表</h2><h3 id=\"1-数组\"><a href=\"#1-数组\" class=\"headerlink\" title=\"1. 数组\"></a>1. 数组</h3><ul>\n<li>动态数组</li>\n</ul>\n<h3 id=\"2-链表\"><a href=\"#2-链表\" class=\"headerlink\" title=\"2. 链表\"></a>2. 链表</h3><ul>\n<li>单链表</li>\n<li>双向链表</li>\n<li>循环链表</li>\n<li>双向循环链表</li>\n<li>静态链表</li>\n</ul>\n<h3 id=\"3-栈\"><a href=\"#3-栈\" class=\"headerlink\" title=\"3. 栈\"></a>3. 栈</h3><ul>\n<li>顺序栈</li>\n<li>链式栈</li>\n</ul>\n<h3 id=\"4-队列\"><a href=\"#4-队列\" class=\"headerlink\" title=\"4. 队列\"></a>4. 队列</h3><ul>\n<li>普通队列</li>\n<li>双端队列</li>\n<li>阻塞队列</li>\n<li>并发队列</li>\n<li>阻塞并发队列</li>\n</ul>\n<h2 id=\"二、散列表\"><a href=\"#二、散列表\" class=\"headerlink\" title=\"二、散列表\"></a>二、散列表</h2><h3 id=\"1-散列函数\"><a href=\"#1-散列函数\" class=\"headerlink\" title=\"1. 散列函数\"></a>1. 散列函数</h3><h3 id=\"2-冲突解决\"><a href=\"#2-冲突解决\" class=\"headerlink\" title=\"2. 冲突解决\"></a>2. 冲突解决</h3><ul>\n<li>链表法</li>\n<li>开放寻址</li>\n<li>其他</li>\n</ul>\n<h3 id=\"3-动态扩容\"><a href=\"#3-动态扩容\" class=\"headerlink\" title=\"3. 动态扩容\"></a>3. 动态扩容</h3><h3 id=\"4-位图\"><a href=\"#4-位图\" class=\"headerlink\" title=\"4. 位图\"></a>4. 位图</h3><h2 id=\"三、树\"><a href=\"#三、树\" class=\"headerlink\" title=\"三、树\"></a>三、树</h2><h3 id=\"1-二叉树\"><a href=\"#1-二叉树\" class=\"headerlink\" title=\"1. 二叉树\"></a>1. 二叉树</h3><ul>\n<li><p>平衡二叉树</p>\n</li>\n<li><p>二叉查找树</p>\n</li>\n<li><p>平衡二叉查找树</p>\n<ul>\n<li>AVL树</li>\n<li>红黑树</li>\n</ul>\n</li>\n<li><p>完全二叉树</p>\n</li>\n<li><p>满二叉树</p>\n</li>\n</ul>\n<h3 id=\"2-多路查找树\"><a href=\"#2-多路查找树\" class=\"headerlink\" title=\"2. 多路查找树\"></a>2. 多路查找树</h3><ul>\n<li>B树</li>\n<li>B+树</li>\n<li>2-3树</li>\n<li>2-3-4树</li>\n</ul>\n<h3 id=\"3-堆\"><a href=\"#3-堆\" class=\"headerlink\" title=\"3. 堆\"></a>3. 堆</h3><ul>\n<li><p>小顶堆</p>\n</li>\n<li><p>大顶堆</p>\n</li>\n<li><p>优先级队列</p>\n<ul>\n<li><p>与普通队列区别：保证每次取出的元素是队列中优先级最高的，优先级别克自定义</p>\n</li>\n<li><p>常用场景：从杂乱的数据中按照一定顺序筛选数据</p>\n</li>\n<li><p>本质：二叉堆结构，binary heap. 利用数组来实现完全二叉树</p>\n</li>\n<li><p>特性</p>\n<ul>\n<li><p>1.数组中第一个元素拥有最高优先级</p>\n</li>\n<li><p>2.给定下标i，那么对于arr[i]：</p>\n<ul>\n<li>1）父节点：对应元素下标为（i - 1）/ 2</li>\n<li>2）左侧子节点：对应下标为2*i + 1</li>\n<li>3）右侧子结点：对应下标为2*i + 2</li>\n</ul>\n</li>\n<li><p>3.每个元素的优先级都必须高于两侧子节点</p>\n</li>\n</ul>\n</li>\n<li><p>基本操作</p>\n<ul>\n<li>1.向上筛选（shift up / bubble up）</li>\n<li>2.向下筛选 （shift down / bubble down）</li>\n</ul>\n</li>\n<li><p>时间复杂度：<br>  长度为n的数组，取前k个：O（logn）<br>  初始化：O(k)</p>\n</li>\n<li><p>Leetcode</p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/top-k-frequent-elements/\" target=\"_blank\" rel=\"noopener\">347. 前 K 个高频元素-中等</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>斐波那契堆</p>\n</li>\n<li><p>二项堆</p>\n</li>\n<li><p>其他</p>\n<ul>\n<li><p>树状数组 Binary Indexed Tree</p>\n<ul>\n<li>求数组中前K个元素的总和（或平均值）</li>\n<li>LeetCode</li>\n</ul>\n</li>\n<li><p>线段树Segment Tree</p>\n<ul>\n<li><p>按照二叉树的形式存储数据的结构，每个结点保存数组中某一段的总和</p>\n</li>\n<li><p>Leetcode </p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/\" target=\"_blank\" rel=\"noopener\">315. 计算右侧小于当前元素的个数-困难</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"四、图\"><a href=\"#四、图\" class=\"headerlink\" title=\"四、图\"></a>四、图</h2><h3 id=\"1-图的存储\"><a href=\"#1-图的存储\" class=\"headerlink\" title=\"1. 图的存储\"></a>1. 图的存储</h3><ul>\n<li>邻接矩阵</li>\n<li>邻接表</li>\n</ul>\n<h3 id=\"2-拓扑排序\"><a href=\"#2-拓扑排序\" class=\"headerlink\" title=\"2. 拓扑排序\"></a>2. 拓扑排序</h3><h3 id=\"3-最短路径\"><a href=\"#3-最短路径\" class=\"headerlink\" title=\"3. 最短路径\"></a>3. 最短路径</h3><h3 id=\"4-关键路径\"><a href=\"#4-关键路径\" class=\"headerlink\" title=\"4. 关键路径\"></a>4. 关键路径</h3><h3 id=\"5-最小生成树\"><a href=\"#5-最小生成树\" class=\"headerlink\" title=\"5. 最小生成树\"></a>5. 最小生成树</h3><h3 id=\"6-二分图\"><a href=\"#6-二分图\" class=\"headerlink\" title=\"6. 二分图\"></a>6. 二分图</h3><h3 id=\"7-最大流\"><a href=\"#7-最大流\" class=\"headerlink\" title=\"7. 最大流\"></a>7. 最大流</h3><h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><h2 id=\"一、复杂度\"><a href=\"#一、复杂度\" class=\"headerlink\" title=\"一、复杂度\"></a>一、复杂度</h2><h3 id=\"1-时间复杂度\"><a href=\"#1-时间复杂度\" class=\"headerlink\" title=\"1. 时间复杂度\"></a>1. 时间复杂度</h3><ul>\n<li><p>如何分析</p>\n<ul>\n<li><ol>\n<li>只关注循环执行次数最多的一段代码</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>常见时间复杂度实例分析</p>\n<p>  <img src=\"https://tva2.sinaimg.cn/large/006YzKDNly1gujq7ui7kaj60vq0fwadg02.jpg\" alt=\"image-20210917165515820\"></p>\n<ul>\n<li><ol>\n<li><p>O(1)</p>\n<ul>\n<li>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li><p>O(logn)、O(nlogn)</p>\n<ul>\n<li>i=1; while (i &lt;= n) { i = i * 2; }<br> 在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</li>\n<li>如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。归并排序、快速排序的时间复杂度都是 O(nlogn)</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li><p>O(m+n)、O(m*n)</p>\n<ul>\n<li>代码的复杂度由两个数据的规模来决定，无法事先评估 m 和 n 谁的量级大</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-空间复杂度\"><a href=\"#2-空间复杂度\" class=\"headerlink\" title=\"2. 空间复杂度\"></a>2. 空间复杂度</h3><ul>\n<li>时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</li>\n<li>常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。</li>\n</ul>\n<h3 id=\"3-Tips\"><a href=\"#3-Tips\" class=\"headerlink\" title=\"3. Tips\"></a>3. Tips</h3><ul>\n<li><p>越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n^2 )。</p>\n<p>  <img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gujq9nxktgj60vq0hsgno02.jpg\" alt=\"image-20210917165700182\"></p>\n</li>\n</ul>\n<h2 id=\"二、基本算法思想\"><a href=\"#二、基本算法思想\" class=\"headerlink\" title=\"二、基本算法思想\"></a>二、基本算法思想</h2><h3 id=\"1-贪心算法\"><a href=\"#1-贪心算法\" class=\"headerlink\" title=\"1. 贪心算法\"></a>1. 贪心算法</h3><h3 id=\"2-分治算法\"><a href=\"#2-分治算法\" class=\"headerlink\" title=\"2. 分治算法\"></a>2. 分治算法</h3><ul>\n<li>快排、归并</li>\n<li>在O(n)内查找一个无序数组中第K大元素</li>\n</ul>\n<h3 id=\"3-动态规划\"><a href=\"#3-动态规划\" class=\"headerlink\" title=\"3. 动态规划\"></a>3. 动态规划</h3><h3 id=\"4-回溯算法\"><a href=\"#4-回溯算法\" class=\"headerlink\" title=\"4. 回溯算法\"></a>4. 回溯算法</h3><h3 id=\"5-枚举算法\"><a href=\"#5-枚举算法\" class=\"headerlink\" title=\"5. 枚举算法\"></a>5. 枚举算法</h3><h2 id=\"三、排序\"><a href=\"#三、排序\" class=\"headerlink\" title=\"三、排序\"></a>三、排序</h2><p><img src=\"https://tva3.sinaimg.cn/large/006YzKDNly1gujqana3gej60vq0je42y02.jpg\" alt=\"image-20210917165757241\"></p>\n<h3 id=\"1-O-n-2\"><a href=\"#1-O-n-2\" class=\"headerlink\" title=\"1. O(n^2)\"></a>1. O(n^2)</h3><p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gujqbw4ot7j60vq0g8dk802.jpg\" alt=\"image-20210917165853155\"></p>\n<ul>\n<li><p>冒泡排序</p>\n<ul>\n<li>原地排序、稳定排序</li>\n</ul>\n</li>\n<li><p>插入排序</p>\n<ul>\n<li><p>原地排序、稳定排序</p>\n</li>\n<li><p>leetcode:</p>\n<p><a href=\"https://leetcode-cn.com/problems/insertion-sort-list/\" target=\"_blank\" rel=\"noopener\">147. 对链表进行插入排序-中等</a></p>\n</li>\n</ul>\n</li>\n<li><p>选择排序</p>\n<ul>\n<li>原地、不稳定</li>\n</ul>\n</li>\n<li><p>希尔排序</p>\n</li>\n</ul>\n<h3 id=\"2-O-nlogn\"><a href=\"#2-O-nlogn\" class=\"headerlink\" title=\"2. O(nlogn)\"></a>2. O(nlogn)</h3><p><img src=\"https://tvax3.sinaimg.cn/large/006YzKDNly1gujqcqpdquj60vq0l1wl602.jpg\" alt=\"image-20210917165958632\"></p>\n<ul>\n<li><p>归并排序</p>\n<ul>\n<li>分治思想、递归实现</li>\n<li>稳定排序、非原地排序，空间复杂度高O(n)</li>\n<li>先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</li>\n<li>递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))<br>  终止条件：p &gt;= r 不用再继续分解</li>\n<li>处理过程从下到上个，先处理子问题，再合并</li>\n</ul>\n</li>\n<li><p>快速排序</p>\n<ul>\n<li>分治思想、递归实现</li>\n<li>原地排序，空间复杂度O(1)，不稳定</li>\n<li>选择 p 到 r 之间的任意一个数据作为 pivot（分区点），遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，大于 pivot 的放到右边， pivot 放到中间。根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1</li>\n<li>递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)<br>  终止条件：p &gt;= r</li>\n<li>处理过程从上到下，先分区，再处理子问题</li>\n</ul>\n</li>\n<li><p>堆排序</p>\n</li>\n</ul>\n<h3 id=\"3-O-n\"><a href=\"#3-O-n\" class=\"headerlink\" title=\"3. O(n)\"></a>3. O(n)</h3><ul>\n<li><p>计数排序</p>\n<ul>\n<li>1.算法原理<br>  1）计数其实就是桶排序的一种特殊情况。<br>  2）当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶<br>  3）每个桶内的数据值都是相同的，就省掉了桶内排序的时间。</li>\n<li>2.使用条件<br>  1）只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序；<br>  2）计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数；<br>  3）比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数。</li>\n<li><ol start=\"2\">\n<li>案例分析：<br>   假设只有8个考生分数在0-5分之间，成绩存于数组A[8] = [2，5，3，0，2，3，0，3]。<br>   使用大小为6的数组C[6]表示桶，下标对应分数，即0，1，2，3，4，5。<br>   C[6]存储的是考生人数，只需遍历一边考生分数，就可以得到C[6] = [2，0，2，3，0，1]。<br>   对C[6]数组顺序求和则C[6]=[2，2，4，7，7，8]，c[k]存储的是小于等于分数k的考生个数。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>基数排序</p>\n<ul>\n<li>1.算法原理（以排序10万个手机号为例来说明）<br>  1）比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。<br>  2）借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。<br>  3）经过11次排序后，手机号码就变为有序的了。<br>  4）每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。</li>\n<li>2.使用条件<br>  1）要求数据可以分割独立的“位”来比较；<br>  2）位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了；<br>  3）每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。</li>\n</ul>\n</li>\n<li><p>桶排序</p>\n<ul>\n<li>1.算法原理：<br>  1）将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。<br>  2）桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</li>\n<li>2.使用条件<br>  1）要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。<br>  2）数据在各个桶之间分布是均匀的。</li>\n<li>3.适用场景<br>  1）桶排序比较适合用在外部排序中。<br>  2）外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中。</li>\n<li>4.应用案例<br>  1）需求描述：<br>  有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序<br>  但内存有限，仅几百MB<br>  2）解决思路：<br>  扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。<br>  第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。<br>  每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。<br>  将100个小文件依次放入内存并用快排排序。<br>  所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。<br>  3）注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"四、搜索\"><a href=\"#四、搜索\" class=\"headerlink\" title=\"四、搜索\"></a>四、搜索</h2><h3 id=\"1-深度优先搜索\"><a href=\"#1-深度优先搜索\" class=\"headerlink\" title=\"1. 深度优先搜索\"></a>1. 深度优先搜索</h3><h3 id=\"2-广度优先搜索\"><a href=\"#2-广度优先搜索\" class=\"headerlink\" title=\"2. 广度优先搜索\"></a>2. 广度优先搜索</h3><h3 id=\"3-A-启发式搜索\"><a href=\"#3-A-启发式搜索\" class=\"headerlink\" title=\"3. A*启发式搜索\"></a>3. A*启发式搜索</h3><h2 id=\"五、查找\"><a href=\"#五、查找\" class=\"headerlink\" title=\"五、查找\"></a>五、查找</h2><h3 id=\"1-线性表查找（二分查找）\"><a href=\"#1-线性表查找（二分查找）\" class=\"headerlink\" title=\"1. 线性表查找（二分查找）\"></a>1. 线性表查找（二分查找）</h3><h3 id=\"2-树结构查找\"><a href=\"#2-树结构查找\" class=\"headerlink\" title=\"2. 树结构查找\"></a>2. 树结构查找</h3><h3 id=\"3-散列表查找\"><a href=\"#3-散列表查找\" class=\"headerlink\" title=\"3. 散列表查找\"></a>3. 散列表查找</h3><h2 id=\"六、字符串匹配\"><a href=\"#六、字符串匹配\" class=\"headerlink\" title=\"六、字符串匹配\"></a>六、字符串匹配</h2><h3 id=\"1-朴素\"><a href=\"#1-朴素\" class=\"headerlink\" title=\"1. 朴素\"></a>1. 朴素</h3><h3 id=\"2-KMP\"><a href=\"#2-KMP\" class=\"headerlink\" title=\"2. KMP\"></a>2. KMP</h3><h3 id=\"3-Robin-karp\"><a href=\"#3-Robin-karp\" class=\"headerlink\" title=\"3. Robin-karp\"></a>3. Robin-karp</h3><h3 id=\"4-Boyer-Moore\"><a href=\"#4-Boyer-Moore\" class=\"headerlink\" title=\"4. Boyer-Moore\"></a>4. Boyer-Moore</h3><h3 id=\"5-AC自动机\"><a href=\"#5-AC自动机\" class=\"headerlink\" title=\"5. AC自动机\"></a>5. AC自动机</h3><h3 id=\"6-前缀树（字典树）Trie\"><a href=\"#6-前缀树（字典树）Trie\" class=\"headerlink\" title=\"6. 前缀树（字典树）Trie\"></a>6. 前缀树（字典树）Trie</h3><ul>\n<li><p>用于字典查找：如给定一系列构成字典的字符串（个数为N），在字典中找出所有以“ABC”开头的字符串，其中最长的为M</p>\n<ul>\n<li>暴力搜索：O(M*N)</li>\n<li>前缀树：O(M)</li>\n</ul>\n</li>\n<li><p>经典应用：搜索框自动补全、拼写检查、IP 路由 (最长前缀匹配)、九宫格打字预测</p>\n</li>\n<li><p>特性</p>\n<ul>\n<li><p>1.每个结点至少包含两个基本属性</p>\n<ul>\n<li>1）children：数组或集合，罗列每个分支中包含的所有字符</li>\n<li>2）isEnd：布尔值，表示该结点是否为某个字符串的结尾</li>\n</ul>\n</li>\n<li><p>2.根节点为空</p>\n</li>\n<li><p>3.除根结点外，其他节点都可能是单词的结尾，叶子结点一定是单词的结尾</p>\n</li>\n</ul>\n</li>\n<li><p>基本操作</p>\n<ul>\n<li><p>1.向 Trie 树中插入键</p>\n<p>  <img src=\"https://tvax3.sinaimg.cn/large/006YzKDNly1gujqdl7gvfj60xc0go42z02.jpg\" alt=\"image-20210917170051035\"></p>\n<ul>\n<li><p>算法分析</p>\n<ul>\n<li><p>从根开始搜索它对应于第一个键字符的链接。有两种情况：</p>\n<ul>\n<li>1.链接存在。沿着链接移动到树的下一个子层。算法继续搜索下一个键字符。</li>\n<li>2.链接不存在。创建一个新的节点，并将它与父节点的链接相连，该链接与当前的键字符相匹配<br>  重复以上步骤，直到到达键的最后一个字符，然后将当前节点标记为结束节点，算法完成。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>复杂度分析</p>\n<ul>\n<li>时间复杂度：O(m)，其中 m为键长。在算法的每次迭代中，我们要么检查要么创建一个节点，直到到达键尾。只需要 m次操作。</li>\n<li>空间复杂度：O(m)。最坏的情况下，新插入的键和 Trie 树中已有的键没有公共前缀。此时需要添加 m 个结点，使用 O(m) 空间。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>2.在 Trie 树中查找键</p>\n<p>  <img src=\"https://tva4.sinaimg.cn/large/006YzKDNly1gujqe8598lj60lu0gon0902.jpg\" alt=\"image-20210917170128796\"></p>\n<ul>\n<li><p>算法分析</p>\n<ul>\n<li><p>每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始，。检查当前节点中与键字符对应的链接。有两种情况：</p>\n</li>\n<li><ol>\n<li><p>存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。</p>\n<ul>\n<li><ol start=\"2\">\n<li>不存在链接。若已无键字符，且当前结点标记为 isEnd，则返回 true。否则有两种可能，均返回 false :</li>\n</ol>\n</li>\n<li><p>1）还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。</p>\n<ul>\n<li>2）没有键字符剩余，但当前结点没有标记为 isEnd。也就是说，待查找键只是Trie树中另一个键的前缀。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>复杂度分析</p>\n<ul>\n<li>时间复杂度 : O(m)。算法的每一步均搜索下一个键字符。最坏的情况下需要 m 次操作。</li>\n<li>空间复杂度 : O(1)。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Leetcode </p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/implement-trie-prefix-tree/\" target=\"_blank\" rel=\"noopener\">208. 实现 Trie (前缀树) -中等</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/\" target=\"_blank\" rel=\"noopener\">211. 添加与搜索单词 - 数据结构设计-中等</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/word-search-ii/\" target=\"_blank\" rel=\"noopener\">212. 单词搜索 II-困难</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"7-后缀数组\"><a href=\"#7-后缀数组\" class=\"headerlink\" title=\"7. 后缀数组\"></a>7. 后缀数组</h3><h2 id=\"七、其他\"><a href=\"#七、其他\" class=\"headerlink\" title=\"七、其他\"></a>七、其他</h2><h3 id=\"1-数论\"><a href=\"#1-数论\" class=\"headerlink\" title=\"1. 数论\"></a>1. 数论</h3><h3 id=\"2-计算几何\"><a href=\"#2-计算几何\" class=\"headerlink\" title=\"2. 计算几何\"></a>2. 计算几何</h3><h3 id=\"3-概率分析\"><a href=\"#3-概率分析\" class=\"headerlink\" title=\"3. 概率分析\"></a>3. 概率分析</h3><h3 id=\"4-并查集\"><a href=\"#4-并查集\" class=\"headerlink\" title=\"4. 并查集\"></a>4. 并查集</h3><h3 id=\"5-拓扑网络\"><a href=\"#5-拓扑网络\" class=\"headerlink\" title=\"5. 拓扑网络\"></a>5. 拓扑网络</h3><h3 id=\"6-矩阵计算\"><a href=\"#6-矩阵计算\" class=\"headerlink\" title=\"6. 矩阵计算\"></a>6. 矩阵计算</h3><h3 id=\"7-线性规划\"><a href=\"#7-线性规划\" class=\"headerlink\" title=\"7. 线性规划\"></a>7. 线性规划</h3>"},{"title":"数据结构与算法---堆","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":0,"abbrlink":"73b3","date":"2020-12-21T16:00:00.000Z","subtitle":null,"_content":"### 数据结构与算法---大顶堆\n### 数据结构与算法---小顶堆\n### 数据结构与算法---优先级队列\n### 数据结构与算法---斐波那契堆\n### 数据结构与算法---二项堆\n","source":"_posts/algorithm-heap.md","raw":"---\ntitle: 数据结构与算法---堆\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop: 0\ntags:\n  - algorithm\ncategories:\n  - work\nabbrlink: 73b3\ndate: 2020-12-22 00:00:00\nsubtitle:\n---\n### 数据结构与算法---大顶堆\n### 数据结构与算法---小顶堆\n### 数据结构与算法---优先级队列\n### 数据结构与算法---斐波那契堆\n### 数据结构与算法---二项堆\n","slug":"algorithm-heap","published":1,"updated":"2021-12-10T09:05:27.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1ak0002acbf2ygx0lsd","content":"<h3 id=\"数据结构与算法—大顶堆\"><a href=\"#数据结构与算法—大顶堆\" class=\"headerlink\" title=\"数据结构与算法—大顶堆\"></a>数据结构与算法—大顶堆</h3><h3 id=\"数据结构与算法—小顶堆\"><a href=\"#数据结构与算法—小顶堆\" class=\"headerlink\" title=\"数据结构与算法—小顶堆\"></a>数据结构与算法—小顶堆</h3><h3 id=\"数据结构与算法—优先级队列\"><a href=\"#数据结构与算法—优先级队列\" class=\"headerlink\" title=\"数据结构与算法—优先级队列\"></a>数据结构与算法—优先级队列</h3><h3 id=\"数据结构与算法—斐波那契堆\"><a href=\"#数据结构与算法—斐波那契堆\" class=\"headerlink\" title=\"数据结构与算法—斐波那契堆\"></a>数据结构与算法—斐波那契堆</h3><h3 id=\"数据结构与算法—二项堆\"><a href=\"#数据结构与算法—二项堆\" class=\"headerlink\" title=\"数据结构与算法—二项堆\"></a>数据结构与算法—二项堆</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"数据结构与算法—大顶堆\"><a href=\"#数据结构与算法—大顶堆\" class=\"headerlink\" title=\"数据结构与算法—大顶堆\"></a>数据结构与算法—大顶堆</h3><h3 id=\"数据结构与算法—小顶堆\"><a href=\"#数据结构与算法—小顶堆\" class=\"headerlink\" title=\"数据结构与算法—小顶堆\"></a>数据结构与算法—小顶堆</h3><h3 id=\"数据结构与算法—优先级队列\"><a href=\"#数据结构与算法—优先级队列\" class=\"headerlink\" title=\"数据结构与算法—优先级队列\"></a>数据结构与算法—优先级队列</h3><h3 id=\"数据结构与算法—斐波那契堆\"><a href=\"#数据结构与算法—斐波那契堆\" class=\"headerlink\" title=\"数据结构与算法—斐波那契堆\"></a>数据结构与算法—斐波那契堆</h3><h3 id=\"数据结构与算法—二项堆\"><a href=\"#数据结构与算法—二项堆\" class=\"headerlink\" title=\"数据结构与算法—二项堆\"></a>数据结构与算法—二项堆</h3>"},{"title":"动态规划问题解题思路","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":null,"abbrlink":"f6ae","date":"2021-07-14T16:00:00.000Z","subtitle":null,"_content":"\n### 动态规划问题解题思路\n\n动态规划问题一般形式是求最值，求最值问题核心是穷举，要把所有答案列举出来找最值。但是，动态规划问题存在`重叠子问题`，暴力穷举效率极低，可以使用`备忘录`或`DP table`来优化穷举过程。而且，我们可以通过寻找`最优子结构`，及通过子问题的最值得到原问题的最值。动态规划问题千变万化，只有列出正确的`状态转移方程`，才能正确的穷举，这也是最困难的地方。\n\n综上，动态规划三要素：重叠子问题、最优子结构、状态转移方程。\n\n#### 确定状态转移方程思路：\n\n**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。\n\n```java\n# 初始化 base case\ndp[0][0][...] = base\n# 进行状态转移\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] = 求最值(选择1，选择2...)\n```\n\n","source":"_posts/algorithm-dp-thinking.md","raw":"---\ntitle: 动态规划问题解题思路\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop:\ntags:\n  - algorithm\ncategories:\n  - work\nabbrlink: f6ae\ndate: 2021-07-15 00:00:00\nsubtitle:\n---\n\n### 动态规划问题解题思路\n\n动态规划问题一般形式是求最值，求最值问题核心是穷举，要把所有答案列举出来找最值。但是，动态规划问题存在`重叠子问题`，暴力穷举效率极低，可以使用`备忘录`或`DP table`来优化穷举过程。而且，我们可以通过寻找`最优子结构`，及通过子问题的最值得到原问题的最值。动态规划问题千变万化，只有列出正确的`状态转移方程`，才能正确的穷举，这也是最困难的地方。\n\n综上，动态规划三要素：重叠子问题、最优子结构、状态转移方程。\n\n#### 确定状态转移方程思路：\n\n**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。\n\n```java\n# 初始化 base case\ndp[0][0][...] = base\n# 进行状态转移\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] = 求最值(选择1，选择2...)\n```\n\n","slug":"algorithm-dp-thinking","published":1,"updated":"2021-12-10T09:50:30.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1an0005acbfg61og3ve","content":"<h3 id=\"动态规划问题解题思路\"><a href=\"#动态规划问题解题思路\" class=\"headerlink\" title=\"动态规划问题解题思路\"></a>动态规划问题解题思路</h3><p>动态规划问题一般形式是求最值，求最值问题核心是穷举，要把所有答案列举出来找最值。但是，动态规划问题存在<code>重叠子问题</code>，暴力穷举效率极低，可以使用<code>备忘录</code>或<code>DP table</code>来优化穷举过程。而且，我们可以通过寻找<code>最优子结构</code>，及通过子问题的最值得到原问题的最值。动态规划问题千变万化，只有列出正确的<code>状态转移方程</code>，才能正确的穷举，这也是最困难的地方。</p>\n<p>综上，动态规划三要素：重叠子问题、最优子结构、状态转移方程。</p>\n<h4 id=\"确定状态转移方程思路：\"><a href=\"#确定状态转移方程思路：\" class=\"headerlink\" title=\"确定状态转移方程思路：\"></a>确定状态转移方程思路：</h4><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 初始化 base case</span><br><span class=\"line\">dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][...] = base</span><br><span class=\"line\"># 进行状态转移</span><br><span class=\"line\"><span class=\"keyword\">for</span> 状态<span class=\"number\">1</span> in 状态<span class=\"number\">1</span>的所有取值：</span><br><span class=\"line\">    <span class=\"keyword\">for</span> 状态<span class=\"number\">2</span> in 状态<span class=\"number\">2</span>的所有取值：</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ...</span><br><span class=\"line\">            dp[状态<span class=\"number\">1</span>][状态<span class=\"number\">2</span>][...] = 求最值(选择<span class=\"number\">1</span>，选择<span class=\"number\">2</span>...)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"动态规划问题解题思路\"><a href=\"#动态规划问题解题思路\" class=\"headerlink\" title=\"动态规划问题解题思路\"></a>动态规划问题解题思路</h3><p>动态规划问题一般形式是求最值，求最值问题核心是穷举，要把所有答案列举出来找最值。但是，动态规划问题存在<code>重叠子问题</code>，暴力穷举效率极低，可以使用<code>备忘录</code>或<code>DP table</code>来优化穷举过程。而且，我们可以通过寻找<code>最优子结构</code>，及通过子问题的最值得到原问题的最值。动态规划问题千变万化，只有列出正确的<code>状态转移方程</code>，才能正确的穷举，这也是最困难的地方。</p>\n<p>综上，动态规划三要素：重叠子问题、最优子结构、状态转移方程。</p>\n<h4 id=\"确定状态转移方程思路：\"><a href=\"#确定状态转移方程思路：\" class=\"headerlink\" title=\"确定状态转移方程思路：\"></a>确定状态转移方程思路：</h4><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 初始化 base case</span><br><span class=\"line\">dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][...] = base</span><br><span class=\"line\"># 进行状态转移</span><br><span class=\"line\"><span class=\"keyword\">for</span> 状态<span class=\"number\">1</span> in 状态<span class=\"number\">1</span>的所有取值：</span><br><span class=\"line\">    <span class=\"keyword\">for</span> 状态<span class=\"number\">2</span> in 状态<span class=\"number\">2</span>的所有取值：</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ...</span><br><span class=\"line\">            dp[状态<span class=\"number\">1</span>][状态<span class=\"number\">2</span>][...] = 求最值(选择<span class=\"number\">1</span>，选择<span class=\"number\">2</span>...)</span><br></pre></td></tr></table></figure>\n\n"},{"title":"中国地图","header-img":"/img/header_img/post-bg-desk.jpg","catalog":false,"toc_number":false,"top":0,"abbrlink":"86e5","date":"2021-08-17T16:00:00.000Z","subtitle":null,"_content":"\n<div id=\"chinaMap\" style=\"width: 100%;height:600px;\"></div>\n<script type=\"text/javascript\" src=\"/js/echarts/echarts.min.js\"></script>\n<script type=\"text/javascript\" src=\"/js/echarts/china.js\"></script>\n<script type=\"text/javascript\" src=\"/js/src/chinamap.js\"></script>","source":"_posts/chinamap.md","raw":"---\ntitle: 中国地图\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: false\ntoc_number: false\ntop: 0\ntags:\n  - map\ncategories:\n  - life\nabbrlink: '86e5'\ndate: 2021-08-18 00:00:00\nsubtitle:\n---\n\n<div id=\"chinaMap\" style=\"width: 100%;height:600px;\"></div>\n<script type=\"text/javascript\" src=\"/js/echarts/echarts.min.js\"></script>\n<script type=\"text/javascript\" src=\"/js/echarts/china.js\"></script>\n<script type=\"text/javascript\" src=\"/js/src/chinamap.js\"></script>","slug":"chinamap","published":1,"updated":"2021-12-10T09:48:33.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1ao0006acbfgtbj08oa","content":"<div id=\"chinaMap\" style=\"width: 100%;height:600px;\"></div>\n<script type=\"text/javascript\" src=\"/js/echarts/echarts.min.js\"></script>\n<script type=\"text/javascript\" src=\"/js/echarts/china.js\"></script>\n<script type=\"text/javascript\" src=\"/js/src/chinamap.js\"></script>","site":{"data":{}},"excerpt":"","more":"<div id=\"chinaMap\" style=\"width: 100%;height:600px;\"></div>\n<script type=\"text/javascript\" src=\"/js/echarts/echarts.min.js\"></script>\n<script type=\"text/javascript\" src=\"/js/echarts/china.js\"></script>\n<script type=\"text/javascript\" src=\"/js/src/chinamap.js\"></script>"},{"title":"VirtualBox新建Centos虚机环境配置","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":null,"abbrlink":"130","date":"2020-10-22T16:00:00.000Z","subtitle":null,"_content":"\n### 一、全局代理设置\n\n修改 /etc/profile 文件,添加下面内容:\n\n```\nhttp_proxy=http://name:pwd@ip:port\nhttps_proxy=http://name:pwd@ip:port\nftp_proxy=http://name:pwd@ip:port\nexport http_proxy\nexport https_proxy\nexport ftp_proxy\n```\n\n使全局配置生效\n\n```\n[root@lcoalhost]# source /etc/profile\n```\n\n若只针对某个用户而言,则修改 ~/.bash_profile 文件,添加相同内容;\n\n修改完成后,注销重新登录即可。\n\n### 二、yum代理设置\n\n修改 /etc/yum.conf，添加下面内容:\n\n```\nhttp_proxy=http://name:pwd@ip:port\n```\n\n保存退出后，就可以使用yum轻松的安装软件了。\n\n### 三、wget代理设置\n\n修改/etc/wgetrc，添加下面内容:\n\n```\nhttp_proxy = http://name:pwd@ip:port\nftp_proxy = http://name:pwd@ip:port\n```\n\n### 四、网络配置\n\nVirtualBox主机网络管理器中需要创建一张Host-Only网卡，并手动配置网卡地址及DHCP服务器。虚机启动时会根据dhcp服务器配置自动分配地址。\n\n虚机设置中启用两张网卡，网卡一连接方式为桥接网卡，网卡二连接方式为仅主机（Host-Only）网络。\n\n虚机中，安装net-tools依赖包：\n\n```\n[root@lcoalhost]# yum -y install net-tools\n```\n\n查看网卡是否启用（是否分配ip，是否能ping通主机）：\n\n```\n[root@lcoalhost]# ifconfig\nenp0s3: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 10.112.118.81  netmask 255.255.254.0  broadcast 10.112.119.255 \n        inet6 fe80::f41f:d:f042:d8ae  prefixlen 64  scopeid 0x20<link> \n        ether 08:00:27:fb:62:61  txqueuelen 1000  (Ethernet) //ether对应第一张网卡的mac\n        RX packets 220530  bytes 251839085 (240.1 MiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 42719  bytes 2891040 (2.7 MiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\nenp0s8: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.56.103  netmask 255.255.255.0  broadcast 192.168.56.255 // inet对应dhcp地址池中的地址\n        inet6 fe80::5ff8:c6c:90:9239  prefixlen 64  scopeid 0x20<link>\n        ether 08:00:27:96:49:8d  txqueuelen 1000  (Ethernet) //ether对应第二张网卡的mac\n        RX packets 62911  bytes 3926194 (3.7 MiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 117073  bytes 10861798 (10.3 MiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n```\n\n### 五、git代理设置\n\n```\n[root@lcoalhost]# yun -y install git\n[root@lcoalhost]# git config --global https.proxy http://name:pwd@ip:port\n[root@lcoalhost]# git config --global http.proxy http://name:pwd@ip:port\n```\n\n### 六、docker 安装\n\n1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。\n\n通过 uname -r 命令查看你当前的内核版本\n\n```\n [root@lcoalhost]# uname -r\n```\n\n2、使用 root 权限登录 Centos。确保 yum 包更新到最新。\n\n```\n[root@lcoalhost]# sudo yum update\n```\n\n\n3、卸载旧版本(如果安装过旧版本的话)\n\n```\n[root@lcoalhost]#sudo yum remove docker  docker-common docker-selinux docker-engine\n```\n\n4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的\n\n```\n[root@lcoalhost]# sudo yum install -y yum-utils device-mapper-persistent-data lvm2\n```\n\n5、设置yum源\n\n```\n[root@lcoalhost]# sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n 重新设置阿里镜像网站（有时候也很慢）\n\n```\n[root@lcoalhost]# yum-config-manager --add-repo http://mirrors.aliyun.com/dockerce/linux/centos/docker-ce.repo\n```\n\n6、可以查看所有仓库中所有docker版本，并选择特定版本安装\n\n```\n[root@lcoalhost]# yum list docker-ce --showduplicates | sort -r\n```\n\n7、安装docker\n\n```\n[root@lcoalhost]# sudo yum install docker-ce  #由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0\n[root@lcoalhost]# sudo yum install <FQPN>  # 例如：sudo yum install docker-ce-17.12.0.ce\n```\n\n8、启动并加入开机启动\n\n```\n[root@lcoalhost]# sudo systemctl start docker\n[root@lcoalhost]# sudo systemctl enable docker\n```\n\n\n9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)\n\n```\n[root@lcoalhost]# docker version\n```\n\n### 七、设置docker 代理\n\n```\n[root@lcoalhost]# mkdir -p /etc/systemd/system/docker.service.d\n[root@lcoalhost]# cat > /etc/systemd/system/docker.service.d/https-proxy.conf << EOF\n[Service]\nEnvironment=\"http://name:pwd@ip:port\" \"HTTPS_PROXY=http://name:pwd@ip:port\" \nEOF\n[root@lcoalhost]# systemctl daemon-reload\n[root@lcoalhost]# systemctl restart docker\n[root@lcoalhost]# systemctl show --property=Environment docker\n```\n\ndocker 镜像加速，docker客户端版本大于 1.10.0 ,可修改daemon配置文件/etc/docker/daemon.json来使用加速器\n\n```\n[root@lcoalhost]#sudo mkdir -p /etc/docker\n[root@lcoalhost]#sudo tee /etc/docker/daemon.json <<-'EOF'\n{\n\"registry-mirrors\": [\"https://4ld4cyzt.mirror.aliyuncs.com\"]\n}\nEOF\n[root@lcoalhost]#sudo systemctl daemon-reload\n[root@lcoalhost]#sudo systemctl restart docker\n```\n\n\n\n### 八、docker中安装Mysql\n\n拉取mysql镜像\n\n```\n[root@lcoalhost]# docker pull mysql:5.7\n5.7: Pulling from library/mysql\n123275d6e508: Already exists \n27cddf5c7140: Pull complete \nc17d442e14c9: Pull complete \n2eb72ffed068: Pull complete \nd4aa125eb616: Pull complete \n52560afb169c: Pull complete \n68190f37a1d2: Pull complete \n3fd1dc6e2990: Pull complete \n85a79b83df29: Pull complete \n35e0b437fe88: Pull complete \n992f6a10268c: Pull complete \nDigest: sha256:82b72085b2fcff073a6616b84c7c3bcbb36e2d13af838cec11a9ed1d0b183f5e\nStatus: Downloaded newer image for mysql:5.7\ndocker.io/library/mysql:5.7\n```\n\n查看镜像\n\n```\n[root@lcoalhost]# docker images\nREPOSITORY  TAG    IMAGE ID     CREATED       SIZE\nmysql       5.7    f5829c0eee9e 2 hours ago   455MB\n[root@lcoalhost]# \n```\n\n启动mysql\n\n```shell\nsudo docker run -p 3306:3306 --name mysql \\\n-v /mydata/mysql/log:/var/log/mysql \\\n-v /mydata/mysql/data:/var/lib/mysql \\\n-v /mydata/mysql/conf:/etc/mysql \\\n-e MYSQL_ROOT_PASSWORD=root \\\n-d mysql:5.7\n```\n\n修改配置\n\n```\n[root@lcoalhost]# cd /mydata/mysql/conf\n// 配置如下：\n[root@lcoalhost conf]# cat my.cnf\n[client]\ndefault-character-set=utf8\n[mysql]\ndefault-character-set=utf8\n[mysqld]\ninit_connect='SET collation_connection = utf8_unicode_ci'\ninit_connect='SET NAMES utf8'\ncharacter-set-server=utf8\ncollation-server=utf8_unicode_ci\nskip-character-set-client-handshake\nskip-name-resolve\n\n[root@lcoalhost conf]# docker restart mysql\nmysql\n[root@lcoalhost conf]# \n```\n\n进入容器查看配置是否生效：\n\n```shell\n[root@lcoalhost conf]# docker exec -it mysql /bin/bash\nroot@b3a74e031bd7:/# whereis mysql\nmysql: /usr/bin/mysql /usr/lib/mysql /etc/mysql /usr/share/mysql\n\nroot@b3a74e031bd7:/# ls /etc/mysql \nmy.cnf\nroot@b3a74e031bd7:/# cat /etc/mysql/my.cnf \n[client]\ndefault-character-set=utf8\n[mysql]\ndefault-character-set=utf8\n[mysqld]\ninit_connect='SET collation_connection = utf8_unicode_ci'\ninit_connect='SET NAMES utf8'\ncharacter-set-server=utf8\ncollation-server=utf8_unicode_ci\nskip-character-set-client-handshake\nskip-name-resolve\nroot@b3a74e031bd7:/# \n```\n\n设置mysql随docker启动\n\n```\n[root@lcoalhost ~]# docker update mysql --restart=always\nmysql\n```\n\n### 九、docker中安装Redis\n\n拉取redis镜像\n\n```shell\n[root@lcoalhost ~]# docker pull redis\nUsing default tag: latest\nlatest: Pulling from library/redis\n123275d6e508: Already exists \nf2edbd6a658e: Pull complete \n66960bede47c: Pull complete \n79dc0b596c90: Pull complete \nde36df38e0b6: Pull complete \n602cd484ff92: Pull complete \nDigest: sha256:1d0b903e3770c2c3c79961b73a53e963f4fd4b2674c2c4911472e8a054cb5728\nStatus: Downloaded newer image for redis:latest\ndocker.io/library/redis:latest\n```\n\n启动\n\n```shell\n[root@lcoalhost ~]# mkdir -p /mydata/redis/conf\n[root@lcoalhost ~]# touch /mydata/redis/conf/redis.conf\n[root@lcoalhost ~]# echo \"appendonly yes\"  >> /mydata/redis/conf/redis.conf // 开启数据持久化\n[root@lcoalhost ~]# docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \\\n -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\\n -d redis redis-server /etc/redis/redis.conf\nce7ae709711986e3f90c9278b284fe6f51f1c1102ba05f3692f0e934ceca1565\n```\n\n 连接docker中的redis\n\n```shell\n[root@lcoalhost ~]# docker exec -it redis redis-cli\n127.0.0.1:6379> set key1 v1\nOK\n127.0.0.1:6379> get key1\n\"v1\"\n```\n\n设置redis随docker启动\n\n```shell\n[root@lcoalhost ~]# docker update redis --restart=always\nredis\n```\n\n\n\n","source":"_posts/centos-config.md","raw":"---\ntitle: VirtualBox新建Centos虚机环境配置\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop:\ntags:\n  - tools\ncategories:\n  - work\nabbrlink: '130'\ndate: 2020-10-23 00:00:00\nsubtitle:\n---\n\n### 一、全局代理设置\n\n修改 /etc/profile 文件,添加下面内容:\n\n```\nhttp_proxy=http://name:pwd@ip:port\nhttps_proxy=http://name:pwd@ip:port\nftp_proxy=http://name:pwd@ip:port\nexport http_proxy\nexport https_proxy\nexport ftp_proxy\n```\n\n使全局配置生效\n\n```\n[root@lcoalhost]# source /etc/profile\n```\n\n若只针对某个用户而言,则修改 ~/.bash_profile 文件,添加相同内容;\n\n修改完成后,注销重新登录即可。\n\n### 二、yum代理设置\n\n修改 /etc/yum.conf，添加下面内容:\n\n```\nhttp_proxy=http://name:pwd@ip:port\n```\n\n保存退出后，就可以使用yum轻松的安装软件了。\n\n### 三、wget代理设置\n\n修改/etc/wgetrc，添加下面内容:\n\n```\nhttp_proxy = http://name:pwd@ip:port\nftp_proxy = http://name:pwd@ip:port\n```\n\n### 四、网络配置\n\nVirtualBox主机网络管理器中需要创建一张Host-Only网卡，并手动配置网卡地址及DHCP服务器。虚机启动时会根据dhcp服务器配置自动分配地址。\n\n虚机设置中启用两张网卡，网卡一连接方式为桥接网卡，网卡二连接方式为仅主机（Host-Only）网络。\n\n虚机中，安装net-tools依赖包：\n\n```\n[root@lcoalhost]# yum -y install net-tools\n```\n\n查看网卡是否启用（是否分配ip，是否能ping通主机）：\n\n```\n[root@lcoalhost]# ifconfig\nenp0s3: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 10.112.118.81  netmask 255.255.254.0  broadcast 10.112.119.255 \n        inet6 fe80::f41f:d:f042:d8ae  prefixlen 64  scopeid 0x20<link> \n        ether 08:00:27:fb:62:61  txqueuelen 1000  (Ethernet) //ether对应第一张网卡的mac\n        RX packets 220530  bytes 251839085 (240.1 MiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 42719  bytes 2891040 (2.7 MiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\nenp0s8: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.56.103  netmask 255.255.255.0  broadcast 192.168.56.255 // inet对应dhcp地址池中的地址\n        inet6 fe80::5ff8:c6c:90:9239  prefixlen 64  scopeid 0x20<link>\n        ether 08:00:27:96:49:8d  txqueuelen 1000  (Ethernet) //ether对应第二张网卡的mac\n        RX packets 62911  bytes 3926194 (3.7 MiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 117073  bytes 10861798 (10.3 MiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n```\n\n### 五、git代理设置\n\n```\n[root@lcoalhost]# yun -y install git\n[root@lcoalhost]# git config --global https.proxy http://name:pwd@ip:port\n[root@lcoalhost]# git config --global http.proxy http://name:pwd@ip:port\n```\n\n### 六、docker 安装\n\n1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。\n\n通过 uname -r 命令查看你当前的内核版本\n\n```\n [root@lcoalhost]# uname -r\n```\n\n2、使用 root 权限登录 Centos。确保 yum 包更新到最新。\n\n```\n[root@lcoalhost]# sudo yum update\n```\n\n\n3、卸载旧版本(如果安装过旧版本的话)\n\n```\n[root@lcoalhost]#sudo yum remove docker  docker-common docker-selinux docker-engine\n```\n\n4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的\n\n```\n[root@lcoalhost]# sudo yum install -y yum-utils device-mapper-persistent-data lvm2\n```\n\n5、设置yum源\n\n```\n[root@lcoalhost]# sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n 重新设置阿里镜像网站（有时候也很慢）\n\n```\n[root@lcoalhost]# yum-config-manager --add-repo http://mirrors.aliyun.com/dockerce/linux/centos/docker-ce.repo\n```\n\n6、可以查看所有仓库中所有docker版本，并选择特定版本安装\n\n```\n[root@lcoalhost]# yum list docker-ce --showduplicates | sort -r\n```\n\n7、安装docker\n\n```\n[root@lcoalhost]# sudo yum install docker-ce  #由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0\n[root@lcoalhost]# sudo yum install <FQPN>  # 例如：sudo yum install docker-ce-17.12.0.ce\n```\n\n8、启动并加入开机启动\n\n```\n[root@lcoalhost]# sudo systemctl start docker\n[root@lcoalhost]# sudo systemctl enable docker\n```\n\n\n9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)\n\n```\n[root@lcoalhost]# docker version\n```\n\n### 七、设置docker 代理\n\n```\n[root@lcoalhost]# mkdir -p /etc/systemd/system/docker.service.d\n[root@lcoalhost]# cat > /etc/systemd/system/docker.service.d/https-proxy.conf << EOF\n[Service]\nEnvironment=\"http://name:pwd@ip:port\" \"HTTPS_PROXY=http://name:pwd@ip:port\" \nEOF\n[root@lcoalhost]# systemctl daemon-reload\n[root@lcoalhost]# systemctl restart docker\n[root@lcoalhost]# systemctl show --property=Environment docker\n```\n\ndocker 镜像加速，docker客户端版本大于 1.10.0 ,可修改daemon配置文件/etc/docker/daemon.json来使用加速器\n\n```\n[root@lcoalhost]#sudo mkdir -p /etc/docker\n[root@lcoalhost]#sudo tee /etc/docker/daemon.json <<-'EOF'\n{\n\"registry-mirrors\": [\"https://4ld4cyzt.mirror.aliyuncs.com\"]\n}\nEOF\n[root@lcoalhost]#sudo systemctl daemon-reload\n[root@lcoalhost]#sudo systemctl restart docker\n```\n\n\n\n### 八、docker中安装Mysql\n\n拉取mysql镜像\n\n```\n[root@lcoalhost]# docker pull mysql:5.7\n5.7: Pulling from library/mysql\n123275d6e508: Already exists \n27cddf5c7140: Pull complete \nc17d442e14c9: Pull complete \n2eb72ffed068: Pull complete \nd4aa125eb616: Pull complete \n52560afb169c: Pull complete \n68190f37a1d2: Pull complete \n3fd1dc6e2990: Pull complete \n85a79b83df29: Pull complete \n35e0b437fe88: Pull complete \n992f6a10268c: Pull complete \nDigest: sha256:82b72085b2fcff073a6616b84c7c3bcbb36e2d13af838cec11a9ed1d0b183f5e\nStatus: Downloaded newer image for mysql:5.7\ndocker.io/library/mysql:5.7\n```\n\n查看镜像\n\n```\n[root@lcoalhost]# docker images\nREPOSITORY  TAG    IMAGE ID     CREATED       SIZE\nmysql       5.7    f5829c0eee9e 2 hours ago   455MB\n[root@lcoalhost]# \n```\n\n启动mysql\n\n```shell\nsudo docker run -p 3306:3306 --name mysql \\\n-v /mydata/mysql/log:/var/log/mysql \\\n-v /mydata/mysql/data:/var/lib/mysql \\\n-v /mydata/mysql/conf:/etc/mysql \\\n-e MYSQL_ROOT_PASSWORD=root \\\n-d mysql:5.7\n```\n\n修改配置\n\n```\n[root@lcoalhost]# cd /mydata/mysql/conf\n// 配置如下：\n[root@lcoalhost conf]# cat my.cnf\n[client]\ndefault-character-set=utf8\n[mysql]\ndefault-character-set=utf8\n[mysqld]\ninit_connect='SET collation_connection = utf8_unicode_ci'\ninit_connect='SET NAMES utf8'\ncharacter-set-server=utf8\ncollation-server=utf8_unicode_ci\nskip-character-set-client-handshake\nskip-name-resolve\n\n[root@lcoalhost conf]# docker restart mysql\nmysql\n[root@lcoalhost conf]# \n```\n\n进入容器查看配置是否生效：\n\n```shell\n[root@lcoalhost conf]# docker exec -it mysql /bin/bash\nroot@b3a74e031bd7:/# whereis mysql\nmysql: /usr/bin/mysql /usr/lib/mysql /etc/mysql /usr/share/mysql\n\nroot@b3a74e031bd7:/# ls /etc/mysql \nmy.cnf\nroot@b3a74e031bd7:/# cat /etc/mysql/my.cnf \n[client]\ndefault-character-set=utf8\n[mysql]\ndefault-character-set=utf8\n[mysqld]\ninit_connect='SET collation_connection = utf8_unicode_ci'\ninit_connect='SET NAMES utf8'\ncharacter-set-server=utf8\ncollation-server=utf8_unicode_ci\nskip-character-set-client-handshake\nskip-name-resolve\nroot@b3a74e031bd7:/# \n```\n\n设置mysql随docker启动\n\n```\n[root@lcoalhost ~]# docker update mysql --restart=always\nmysql\n```\n\n### 九、docker中安装Redis\n\n拉取redis镜像\n\n```shell\n[root@lcoalhost ~]# docker pull redis\nUsing default tag: latest\nlatest: Pulling from library/redis\n123275d6e508: Already exists \nf2edbd6a658e: Pull complete \n66960bede47c: Pull complete \n79dc0b596c90: Pull complete \nde36df38e0b6: Pull complete \n602cd484ff92: Pull complete \nDigest: sha256:1d0b903e3770c2c3c79961b73a53e963f4fd4b2674c2c4911472e8a054cb5728\nStatus: Downloaded newer image for redis:latest\ndocker.io/library/redis:latest\n```\n\n启动\n\n```shell\n[root@lcoalhost ~]# mkdir -p /mydata/redis/conf\n[root@lcoalhost ~]# touch /mydata/redis/conf/redis.conf\n[root@lcoalhost ~]# echo \"appendonly yes\"  >> /mydata/redis/conf/redis.conf // 开启数据持久化\n[root@lcoalhost ~]# docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \\\n -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\\n -d redis redis-server /etc/redis/redis.conf\nce7ae709711986e3f90c9278b284fe6f51f1c1102ba05f3692f0e934ceca1565\n```\n\n 连接docker中的redis\n\n```shell\n[root@lcoalhost ~]# docker exec -it redis redis-cli\n127.0.0.1:6379> set key1 v1\nOK\n127.0.0.1:6379> get key1\n\"v1\"\n```\n\n设置redis随docker启动\n\n```shell\n[root@lcoalhost ~]# docker update redis --restart=always\nredis\n```\n\n\n\n","slug":"centos-config","published":1,"updated":"2021-12-10T09:54:17.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1ap0007acbf3j2w7yu8","content":"<h3 id=\"一、全局代理设置\"><a href=\"#一、全局代理设置\" class=\"headerlink\" title=\"一、全局代理设置\"></a>一、全局代理设置</h3><p>修改 /etc/profile 文件,添加下面内容:</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">http_proxy</span>=http://name:pwd@ip:port</span><br><span class=\"line\"><span class=\"attribute\">https_proxy</span>=http://name:pwd@ip:port</span><br><span class=\"line\"><span class=\"attribute\">ftp_proxy</span>=http://name:pwd@ip:port</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> http_proxy</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> https_proxy</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> ftp_proxy</span><br></pre></td></tr></table></figure>\n\n<p>使全局配置生效</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># source /etc/profile</span></span><br></pre></td></tr></table></figure>\n\n<p>若只针对某个用户而言,则修改 ~/.bash_profile 文件,添加相同内容;</p>\n<p>修改完成后,注销重新登录即可。</p>\n<h3 id=\"二、yum代理设置\"><a href=\"#二、yum代理设置\" class=\"headerlink\" title=\"二、yum代理设置\"></a>二、yum代理设置</h3><p>修改 /etc/yum.conf，添加下面内容:</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http_proxy=<span class=\"string\">http:</span><span class=\"comment\">//name:pwd@ip:port</span></span><br></pre></td></tr></table></figure>\n\n<p>保存退出后，就可以使用yum轻松的安装软件了。</p>\n<h3 id=\"三、wget代理设置\"><a href=\"#三、wget代理设置\" class=\"headerlink\" title=\"三、wget代理设置\"></a>三、wget代理设置</h3><p>修改/etc/wgetrc，添加下面内容:</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http_proxy = <span class=\"string\">http:</span><span class=\"comment\">//name:pwd@ip:port</span></span><br><span class=\"line\">ftp_proxy = <span class=\"string\">http:</span><span class=\"comment\">//name:pwd@ip:port</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、网络配置\"><a href=\"#四、网络配置\" class=\"headerlink\" title=\"四、网络配置\"></a>四、网络配置</h3><p>VirtualBox主机网络管理器中需要创建一张Host-Only网卡，并手动配置网卡地址及DHCP服务器。虚机启动时会根据dhcp服务器配置自动分配地址。</p>\n<p>虚机设置中启用两张网卡，网卡一连接方式为桥接网卡，网卡二连接方式为仅主机（Host-Only）网络。</p>\n<p>虚机中，安装net-tools依赖包：</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># yum -y install net-tools</span></span><br></pre></td></tr></table></figure>\n\n<p>查看网卡是否启用（是否分配ip，是否能ping通主机）：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"symbol\">root@</span>lcoalhost]# ifconfig</span><br><span class=\"line\">enp0s3: flags=<span class=\"number\">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class=\"number\">1500</span></span><br><span class=\"line\">        inet <span class=\"number\">10.112</span><span class=\"number\">.118</span><span class=\"number\">.81</span>  netmask <span class=\"number\">255.255</span><span class=\"number\">.254</span><span class=\"number\">.0</span>  broadcast <span class=\"number\">10.112</span><span class=\"number\">.119</span><span class=\"number\">.255</span> </span><br><span class=\"line\">        inet6 fe80::f41f:d:f042:d8ae  prefixlen <span class=\"number\">64</span>  scopeid <span class=\"number\">0x20</span>&lt;link&gt; </span><br><span class=\"line\">        ether <span class=\"number\">08</span>:<span class=\"number\">00</span>:<span class=\"number\">27</span>:fb:<span class=\"number\">62</span>:<span class=\"number\">61</span>  txqueuelen <span class=\"number\">1000</span>  (Ethernet) <span class=\"comment\">//ether对应第一张网卡的mac</span></span><br><span class=\"line\">        RX packets <span class=\"number\">220530</span>  bytes <span class=\"number\">251839085</span> (<span class=\"number\">240.1</span> MiB)</span><br><span class=\"line\">        RX errors <span class=\"number\">0</span>  dropped <span class=\"number\">0</span>  overruns <span class=\"number\">0</span>  frame <span class=\"number\">0</span></span><br><span class=\"line\">        TX packets <span class=\"number\">42719</span>  bytes <span class=\"number\">2891040</span> (<span class=\"number\">2.7</span> MiB)</span><br><span class=\"line\">        TX errors <span class=\"number\">0</span>  dropped <span class=\"number\">0</span> overruns <span class=\"number\">0</span>  carrier <span class=\"number\">0</span>  collisions <span class=\"number\">0</span></span><br><span class=\"line\">enp0s8: flags=<span class=\"number\">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class=\"number\">1500</span></span><br><span class=\"line\">        inet <span class=\"number\">192.168</span><span class=\"number\">.56</span><span class=\"number\">.103</span>  netmask <span class=\"number\">255.255</span><span class=\"number\">.255</span><span class=\"number\">.0</span>  broadcast <span class=\"number\">192.168</span><span class=\"number\">.56</span><span class=\"number\">.255</span> <span class=\"comment\">// inet对应dhcp地址池中的地址</span></span><br><span class=\"line\">        inet6 fe80::<span class=\"number\">5f</span>f8:c6c:<span class=\"number\">90</span>:<span class=\"number\">9239</span>  prefixlen <span class=\"number\">64</span>  scopeid <span class=\"number\">0x20</span>&lt;link&gt;</span><br><span class=\"line\">        ether <span class=\"number\">08</span>:<span class=\"number\">00</span>:<span class=\"number\">27</span>:<span class=\"number\">96</span>:<span class=\"number\">49</span>:<span class=\"number\">8</span>d  txqueuelen <span class=\"number\">1000</span>  (Ethernet) <span class=\"comment\">//ether对应第二张网卡的mac</span></span><br><span class=\"line\">        RX packets <span class=\"number\">62911</span>  bytes <span class=\"number\">3926194</span> (<span class=\"number\">3.7</span> MiB)</span><br><span class=\"line\">        RX errors <span class=\"number\">0</span>  dropped <span class=\"number\">0</span>  overruns <span class=\"number\">0</span>  frame <span class=\"number\">0</span></span><br><span class=\"line\">        TX packets <span class=\"number\">117073</span>  bytes <span class=\"number\">10861798</span> (<span class=\"number\">10.3</span> MiB)</span><br><span class=\"line\">        TX errors <span class=\"number\">0</span>  dropped <span class=\"number\">0</span> overruns <span class=\"number\">0</span>  carrier <span class=\"number\">0</span>  collisions <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"五、git代理设置\"><a href=\"#五、git代理设置\" class=\"headerlink\" title=\"五、git代理设置\"></a>五、git代理设置</h3><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># yun -y install git</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># git config --global https.proxy http://name:pwd<span class=\"doctag\">@ip</span>:port</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># git config --global http.proxy http://name:pwd<span class=\"doctag\">@ip</span>:port</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"六、docker-安装\"><a href=\"#六、docker-安装\" class=\"headerlink\" title=\"六、docker 安装\"></a>六、docker 安装</h3><p>1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。</p>\n<p>通过 uname -r 命令查看你当前的内核版本</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># uname -r</span></span><br></pre></td></tr></table></figure>\n\n<p>2、使用 root 权限登录 Centos。确保 yum 包更新到最新。</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># sudo yum update</span></span><br></pre></td></tr></table></figure>\n\n\n<p>3、卸载旧版本(如果安装过旧版本的话)</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo yum remove docker  docker-common docker-selinux docker-engine</span></span><br></pre></td></tr></table></figure>\n\n<p>4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span></span><br></pre></td></tr></table></figure>\n\n<p>5、设置yum源</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]# sudo yum-config-manager --<span class=\"built_in\">add</span>-repo http<span class=\"variable\">s:</span>//download.docker.<span class=\"keyword\">com</span>/linux/centos/docker-<span class=\"keyword\">ce</span>.repo</span><br></pre></td></tr></table></figure>\n\n<p> 重新设置阿里镜像网站（有时候也很慢）</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]# yum-config-manager --<span class=\"built_in\">add</span>-repo http://mirrors.aliyun.<span class=\"keyword\">com</span>/dockerce/linux/centos/docker-<span class=\"keyword\">ce</span>.repo</span><br></pre></td></tr></table></figure>\n\n<p>6、可以查看所有仓库中所有docker版本，并选择特定版本安装</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]# yum <span class=\"keyword\">list</span> docker-<span class=\"keyword\">ce</span> --showduplicates | <span class=\"keyword\">sort</span> -r</span><br></pre></td></tr></table></figure>\n\n<p>7、安装docker</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[root@lcoalhost]</span># <span class=\"selector-tag\">sudo</span> <span class=\"selector-tag\">yum</span> <span class=\"selector-tag\">install</span> <span class=\"selector-tag\">docker-ce</span>  #由于<span class=\"selector-tag\">repo</span>中默认只开启<span class=\"selector-tag\">stable</span>仓库，故这里安装的是最新稳定版17<span class=\"selector-class\">.12</span><span class=\"selector-class\">.0</span></span><br><span class=\"line\"><span class=\"selector-attr\">[root@lcoalhost]</span># <span class=\"selector-tag\">sudo</span> <span class=\"selector-tag\">yum</span> <span class=\"selector-tag\">install</span> &lt;<span class=\"selector-tag\">FQPN</span>&gt;  # 例如：<span class=\"selector-tag\">sudo</span> <span class=\"selector-tag\">yum</span> <span class=\"selector-tag\">install</span> <span class=\"selector-tag\">docker-ce-17</span><span class=\"selector-class\">.12</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.ce</span></span><br></pre></td></tr></table></figure>\n\n<p>8、启动并加入开机启动</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># sudo systemctl start docker</span></span><br><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># sudo systemctl enable docker</span></span><br></pre></td></tr></table></figure>\n\n\n<p>9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># docker version</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"七、设置docker-代理\"><a href=\"#七、设置docker-代理\" class=\"headerlink\" title=\"七、设置docker 代理\"></a>七、设置docker 代理</h3><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># mkdir -p /etc/systemd/system/docker.service.d</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># cat &gt; /etc/systemd/system/docker.service.d/https-proxy.conf &lt;&lt; EOF</span></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Environment=<span class=\"string\">\"http://name:pwd@ip:port\"</span> <span class=\"string\">\"HTTPS_PROXY=http://name:pwd@ip:port\"</span> </span><br><span class=\"line\">EOF</span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># systemctl daemon-reload</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># systemctl restart docker</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># systemctl show --property=Environment docker</span></span><br></pre></td></tr></table></figure>\n\n<p>docker 镜像加速，docker客户端版本大于 1.10.0 ,可修改daemon配置文件/etc/docker/daemon.json来使用加速器</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo mkdir -p /etc/docker</span></span><br><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo tee /etc/docker/daemon.json &lt;&lt;-<span class=\"string\">'EOF'</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"string\">\"registry-mirrors\"</span>: [<span class=\"string\">\"https://4ld4cyzt.mirror.aliyuncs.com\"</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo systemctl daemon-reload</span></span><br><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo systemctl restart docker</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"八、docker中安装Mysql\"><a href=\"#八、docker中安装Mysql\" class=\"headerlink\" title=\"八、docker中安装Mysql\"></a>八、docker中安装Mysql</h3><p>拉取mysql镜像</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]# docker pull mysq<span class=\"variable\">l:5</span>.<span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">5.7</span>: Pulling from library/mysql</span><br><span class=\"line\"><span class=\"number\">123275</span>d6e508: Already <span class=\"built_in\">exists</span> </span><br><span class=\"line\"><span class=\"number\">27</span>cddf5c7140: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\">c17d442e14c9: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">2</span>eb72ffed068: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\">d4aa125eb616: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">52560</span>afb169c: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">68190</span>f37a1d2: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">3</span>fd1dc6e2990: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">85</span>a79b83df29: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">35</span>e0b437fe88: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">992</span>f6a10268c: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\">Diges<span class=\"variable\">t:</span> <span class=\"built_in\">sha256</span>:<span class=\"number\">82</span>b72085b2fcff073a6616b84c7c3bcbb36e2d13af838cec11a9ed1d0b183f5e</span><br><span class=\"line\">Statu<span class=\"variable\">s:</span> Downloaded newer image <span class=\"keyword\">for</span> mysq<span class=\"variable\">l:5</span>.<span class=\"number\">7</span></span><br><span class=\"line\">docker.io/library/mysq<span class=\"variable\">l:5</span>.<span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>查看镜像</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"symbol\">root@</span>lcoalhost]# docker images</span><br><span class=\"line\">REPOSITORY  TAG    IMAGE ID     CREATED       SIZE</span><br><span class=\"line\">mysql       <span class=\"number\">5.7</span>    f5829c0eee9e <span class=\"number\">2</span> hours ago   <span class=\"number\">455</span>MB</span><br><span class=\"line\">[<span class=\"symbol\">root@</span>lcoalhost]#</span><br></pre></td></tr></table></figure>\n\n<p>启动mysql</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -p 3306:3306 --name mysql \\</span><br><span class=\"line\">-v /mydata/mysql/log:/var/log/mysql \\</span><br><span class=\"line\">-v /mydata/mysql/data:/var/lib/mysql \\</span><br><span class=\"line\">-v /mydata/mysql/conf:/etc/mysql \\</span><br><span class=\"line\">-e MYSQL_ROOT_PASSWORD=root \\</span><br><span class=\"line\">-d mysql:5.7</span><br></pre></td></tr></table></figure>\n\n<p>修改配置</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># cd /mydata/mysql/conf</span></span><br><span class=\"line\">// 配置如下：</span><br><span class=\"line\">[root@lcoalhost conf]<span class=\"comment\"># cat my.cnf</span></span><br><span class=\"line\">[client]</span><br><span class=\"line\">default-character-<span class=\"keyword\">set</span>=utf8</span><br><span class=\"line\">[mysql]</span><br><span class=\"line\"><span class=\"keyword\">default</span>-<span class=\"built_in\">character</span>-<span class=\"keyword\">set</span>=utf8</span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\">init_connect=<span class=\"string\">'SET collation_connection = utf8_unicode_ci'</span></span><br><span class=\"line\">init_connect=<span class=\"string\">'SET NAMES utf8'</span></span><br><span class=\"line\"><span class=\"built_in\">character</span>-<span class=\"keyword\">set</span>-<span class=\"keyword\">server</span>=utf8</span><br><span class=\"line\"><span class=\"keyword\">collation</span>-<span class=\"keyword\">server</span>=utf8_unicode_ci</span><br><span class=\"line\"><span class=\"keyword\">skip</span>-<span class=\"built_in\">character</span>-<span class=\"keyword\">set</span>-<span class=\"keyword\">client</span>-handshake</span><br><span class=\"line\"><span class=\"keyword\">skip</span>-<span class=\"keyword\">name</span>-resolve</span><br><span class=\"line\"></span><br><span class=\"line\">[root@lcoalhost conf]<span class=\"comment\"># docker restart mysql</span></span><br><span class=\"line\">mysql</span><br><span class=\"line\">[root@lcoalhost conf]<span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n\n<p>进入容器查看配置是否生效：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost conf]# docker exec -it mysql /bin/bash</span><br><span class=\"line\">root@b3a74e031bd7:/# whereis mysql</span><br><span class=\"line\">mysql: /usr/bin/mysql /usr/lib/mysql /etc/mysql /usr/share/mysql</span><br><span class=\"line\"></span><br><span class=\"line\">root@b3a74e031bd7:/# ls /etc/mysql </span><br><span class=\"line\">my.cnf</span><br><span class=\"line\">root@b3a74e031bd7:/# cat /etc/mysql/my.cnf </span><br><span class=\"line\">[client]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysql]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\">init_connect='SET collation_connection = utf8_unicode_ci'</span><br><span class=\"line\">init_connect='SET NAMES utf8'</span><br><span class=\"line\">character-set-server=utf8</span><br><span class=\"line\">collation-server=utf8_unicode_ci</span><br><span class=\"line\">skip-character-set-client-handshake</span><br><span class=\"line\">skip-name-resolve</span><br><span class=\"line\">root@b3a74e031bd7:/#</span><br></pre></td></tr></table></figure>\n\n<p>设置mysql随docker启动</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost</span> ~]<span class=\"meta\"># docker update mysql --restart=always</span></span><br><span class=\"line\">mysql</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"九、docker中安装Redis\"><a href=\"#九、docker中安装Redis\" class=\"headerlink\" title=\"九、docker中安装Redis\"></a>九、docker中安装Redis</h3><p>拉取redis镜像</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost ~]# docker pull redis</span><br><span class=\"line\">Using default tag: latest</span><br><span class=\"line\">latest: Pulling from library/redis</span><br><span class=\"line\">123275d6e508: Already exists </span><br><span class=\"line\">f2edbd6a658e: Pull complete </span><br><span class=\"line\">66960bede47c: Pull complete </span><br><span class=\"line\">79dc0b596c90: Pull complete </span><br><span class=\"line\">de36df38e0b6: Pull complete </span><br><span class=\"line\">602cd484ff92: Pull complete </span><br><span class=\"line\">Digest: sha256:1d0b903e3770c2c3c79961b73a53e963f4fd4b2674c2c4911472e8a054cb5728</span><br><span class=\"line\">Status: Downloaded newer image for redis:latest</span><br><span class=\"line\">docker.io/library/redis:latest</span><br></pre></td></tr></table></figure>\n\n<p>启动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost ~]# mkdir -p /mydata/redis/conf</span><br><span class=\"line\">[root@lcoalhost ~]# touch /mydata/redis/conf/redis.conf</span><br><span class=\"line\">[root@lcoalhost ~]# echo \"appendonly yes\"  &gt;&gt; /mydata/redis/conf/redis.conf // 开启数据持久化</span><br><span class=\"line\">[root@lcoalhost ~]# docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \\</span><br><span class=\"line\"> -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\</span><br><span class=\"line\"> -d redis redis-server /etc/redis/redis.conf</span><br><span class=\"line\">ce7ae709711986e3f90c9278b284fe6f51f1c1102ba05f3692f0e934ceca1565</span><br></pre></td></tr></table></figure>\n\n<p> 连接docker中的redis</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost ~]# docker exec -it redis redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; set key1 v1</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get key1</span><br><span class=\"line\">\"v1\"</span><br></pre></td></tr></table></figure>\n\n<p>设置redis随docker启动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost ~]# docker update redis --restart=always</span><br><span class=\"line\">redis</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、全局代理设置\"><a href=\"#一、全局代理设置\" class=\"headerlink\" title=\"一、全局代理设置\"></a>一、全局代理设置</h3><p>修改 /etc/profile 文件,添加下面内容:</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">http_proxy</span>=http://name:pwd@ip:port</span><br><span class=\"line\"><span class=\"attribute\">https_proxy</span>=http://name:pwd@ip:port</span><br><span class=\"line\"><span class=\"attribute\">ftp_proxy</span>=http://name:pwd@ip:port</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> http_proxy</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> https_proxy</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> ftp_proxy</span><br></pre></td></tr></table></figure>\n\n<p>使全局配置生效</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># source /etc/profile</span></span><br></pre></td></tr></table></figure>\n\n<p>若只针对某个用户而言,则修改 ~/.bash_profile 文件,添加相同内容;</p>\n<p>修改完成后,注销重新登录即可。</p>\n<h3 id=\"二、yum代理设置\"><a href=\"#二、yum代理设置\" class=\"headerlink\" title=\"二、yum代理设置\"></a>二、yum代理设置</h3><p>修改 /etc/yum.conf，添加下面内容:</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http_proxy=<span class=\"string\">http:</span><span class=\"comment\">//name:pwd@ip:port</span></span><br></pre></td></tr></table></figure>\n\n<p>保存退出后，就可以使用yum轻松的安装软件了。</p>\n<h3 id=\"三、wget代理设置\"><a href=\"#三、wget代理设置\" class=\"headerlink\" title=\"三、wget代理设置\"></a>三、wget代理设置</h3><p>修改/etc/wgetrc，添加下面内容:</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http_proxy = <span class=\"string\">http:</span><span class=\"comment\">//name:pwd@ip:port</span></span><br><span class=\"line\">ftp_proxy = <span class=\"string\">http:</span><span class=\"comment\">//name:pwd@ip:port</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、网络配置\"><a href=\"#四、网络配置\" class=\"headerlink\" title=\"四、网络配置\"></a>四、网络配置</h3><p>VirtualBox主机网络管理器中需要创建一张Host-Only网卡，并手动配置网卡地址及DHCP服务器。虚机启动时会根据dhcp服务器配置自动分配地址。</p>\n<p>虚机设置中启用两张网卡，网卡一连接方式为桥接网卡，网卡二连接方式为仅主机（Host-Only）网络。</p>\n<p>虚机中，安装net-tools依赖包：</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># yum -y install net-tools</span></span><br></pre></td></tr></table></figure>\n\n<p>查看网卡是否启用（是否分配ip，是否能ping通主机）：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"symbol\">root@</span>lcoalhost]# ifconfig</span><br><span class=\"line\">enp0s3: flags=<span class=\"number\">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class=\"number\">1500</span></span><br><span class=\"line\">        inet <span class=\"number\">10.112</span><span class=\"number\">.118</span><span class=\"number\">.81</span>  netmask <span class=\"number\">255.255</span><span class=\"number\">.254</span><span class=\"number\">.0</span>  broadcast <span class=\"number\">10.112</span><span class=\"number\">.119</span><span class=\"number\">.255</span> </span><br><span class=\"line\">        inet6 fe80::f41f:d:f042:d8ae  prefixlen <span class=\"number\">64</span>  scopeid <span class=\"number\">0x20</span>&lt;link&gt; </span><br><span class=\"line\">        ether <span class=\"number\">08</span>:<span class=\"number\">00</span>:<span class=\"number\">27</span>:fb:<span class=\"number\">62</span>:<span class=\"number\">61</span>  txqueuelen <span class=\"number\">1000</span>  (Ethernet) <span class=\"comment\">//ether对应第一张网卡的mac</span></span><br><span class=\"line\">        RX packets <span class=\"number\">220530</span>  bytes <span class=\"number\">251839085</span> (<span class=\"number\">240.1</span> MiB)</span><br><span class=\"line\">        RX errors <span class=\"number\">0</span>  dropped <span class=\"number\">0</span>  overruns <span class=\"number\">0</span>  frame <span class=\"number\">0</span></span><br><span class=\"line\">        TX packets <span class=\"number\">42719</span>  bytes <span class=\"number\">2891040</span> (<span class=\"number\">2.7</span> MiB)</span><br><span class=\"line\">        TX errors <span class=\"number\">0</span>  dropped <span class=\"number\">0</span> overruns <span class=\"number\">0</span>  carrier <span class=\"number\">0</span>  collisions <span class=\"number\">0</span></span><br><span class=\"line\">enp0s8: flags=<span class=\"number\">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class=\"number\">1500</span></span><br><span class=\"line\">        inet <span class=\"number\">192.168</span><span class=\"number\">.56</span><span class=\"number\">.103</span>  netmask <span class=\"number\">255.255</span><span class=\"number\">.255</span><span class=\"number\">.0</span>  broadcast <span class=\"number\">192.168</span><span class=\"number\">.56</span><span class=\"number\">.255</span> <span class=\"comment\">// inet对应dhcp地址池中的地址</span></span><br><span class=\"line\">        inet6 fe80::<span class=\"number\">5f</span>f8:c6c:<span class=\"number\">90</span>:<span class=\"number\">9239</span>  prefixlen <span class=\"number\">64</span>  scopeid <span class=\"number\">0x20</span>&lt;link&gt;</span><br><span class=\"line\">        ether <span class=\"number\">08</span>:<span class=\"number\">00</span>:<span class=\"number\">27</span>:<span class=\"number\">96</span>:<span class=\"number\">49</span>:<span class=\"number\">8</span>d  txqueuelen <span class=\"number\">1000</span>  (Ethernet) <span class=\"comment\">//ether对应第二张网卡的mac</span></span><br><span class=\"line\">        RX packets <span class=\"number\">62911</span>  bytes <span class=\"number\">3926194</span> (<span class=\"number\">3.7</span> MiB)</span><br><span class=\"line\">        RX errors <span class=\"number\">0</span>  dropped <span class=\"number\">0</span>  overruns <span class=\"number\">0</span>  frame <span class=\"number\">0</span></span><br><span class=\"line\">        TX packets <span class=\"number\">117073</span>  bytes <span class=\"number\">10861798</span> (<span class=\"number\">10.3</span> MiB)</span><br><span class=\"line\">        TX errors <span class=\"number\">0</span>  dropped <span class=\"number\">0</span> overruns <span class=\"number\">0</span>  carrier <span class=\"number\">0</span>  collisions <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"五、git代理设置\"><a href=\"#五、git代理设置\" class=\"headerlink\" title=\"五、git代理设置\"></a>五、git代理设置</h3><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># yun -y install git</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># git config --global https.proxy http://name:pwd<span class=\"doctag\">@ip</span>:port</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># git config --global http.proxy http://name:pwd<span class=\"doctag\">@ip</span>:port</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"六、docker-安装\"><a href=\"#六、docker-安装\" class=\"headerlink\" title=\"六、docker 安装\"></a>六、docker 安装</h3><p>1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。</p>\n<p>通过 uname -r 命令查看你当前的内核版本</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># uname -r</span></span><br></pre></td></tr></table></figure>\n\n<p>2、使用 root 权限登录 Centos。确保 yum 包更新到最新。</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># sudo yum update</span></span><br></pre></td></tr></table></figure>\n\n\n<p>3、卸载旧版本(如果安装过旧版本的话)</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo yum remove docker  docker-common docker-selinux docker-engine</span></span><br></pre></td></tr></table></figure>\n\n<p>4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span></span><br></pre></td></tr></table></figure>\n\n<p>5、设置yum源</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]# sudo yum-config-manager --<span class=\"built_in\">add</span>-repo http<span class=\"variable\">s:</span>//download.docker.<span class=\"keyword\">com</span>/linux/centos/docker-<span class=\"keyword\">ce</span>.repo</span><br></pre></td></tr></table></figure>\n\n<p> 重新设置阿里镜像网站（有时候也很慢）</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]# yum-config-manager --<span class=\"built_in\">add</span>-repo http://mirrors.aliyun.<span class=\"keyword\">com</span>/dockerce/linux/centos/docker-<span class=\"keyword\">ce</span>.repo</span><br></pre></td></tr></table></figure>\n\n<p>6、可以查看所有仓库中所有docker版本，并选择特定版本安装</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]# yum <span class=\"keyword\">list</span> docker-<span class=\"keyword\">ce</span> --showduplicates | <span class=\"keyword\">sort</span> -r</span><br></pre></td></tr></table></figure>\n\n<p>7、安装docker</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[root@lcoalhost]</span># <span class=\"selector-tag\">sudo</span> <span class=\"selector-tag\">yum</span> <span class=\"selector-tag\">install</span> <span class=\"selector-tag\">docker-ce</span>  #由于<span class=\"selector-tag\">repo</span>中默认只开启<span class=\"selector-tag\">stable</span>仓库，故这里安装的是最新稳定版17<span class=\"selector-class\">.12</span><span class=\"selector-class\">.0</span></span><br><span class=\"line\"><span class=\"selector-attr\">[root@lcoalhost]</span># <span class=\"selector-tag\">sudo</span> <span class=\"selector-tag\">yum</span> <span class=\"selector-tag\">install</span> &lt;<span class=\"selector-tag\">FQPN</span>&gt;  # 例如：<span class=\"selector-tag\">sudo</span> <span class=\"selector-tag\">yum</span> <span class=\"selector-tag\">install</span> <span class=\"selector-tag\">docker-ce-17</span><span class=\"selector-class\">.12</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.ce</span></span><br></pre></td></tr></table></figure>\n\n<p>8、启动并加入开机启动</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># sudo systemctl start docker</span></span><br><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># sudo systemctl enable docker</span></span><br></pre></td></tr></table></figure>\n\n\n<p>9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\"># docker version</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"七、设置docker-代理\"><a href=\"#七、设置docker-代理\" class=\"headerlink\" title=\"七、设置docker 代理\"></a>七、设置docker 代理</h3><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># mkdir -p /etc/systemd/system/docker.service.d</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># cat &gt; /etc/systemd/system/docker.service.d/https-proxy.conf &lt;&lt; EOF</span></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Environment=<span class=\"string\">\"http://name:pwd@ip:port\"</span> <span class=\"string\">\"HTTPS_PROXY=http://name:pwd@ip:port\"</span> </span><br><span class=\"line\">EOF</span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># systemctl daemon-reload</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># systemctl restart docker</span></span><br><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># systemctl show --property=Environment docker</span></span><br></pre></td></tr></table></figure>\n\n<p>docker 镜像加速，docker客户端版本大于 1.10.0 ,可修改daemon配置文件/etc/docker/daemon.json来使用加速器</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo mkdir -p /etc/docker</span></span><br><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo tee /etc/docker/daemon.json &lt;&lt;-<span class=\"string\">'EOF'</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"string\">\"registry-mirrors\"</span>: [<span class=\"string\">\"https://4ld4cyzt.mirror.aliyuncs.com\"</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo systemctl daemon-reload</span></span><br><span class=\"line\">[root<span class=\"symbol\">@lcoalhost]</span><span class=\"meta\">#sudo systemctl restart docker</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"八、docker中安装Mysql\"><a href=\"#八、docker中安装Mysql\" class=\"headerlink\" title=\"八、docker中安装Mysql\"></a>八、docker中安装Mysql</h3><p>拉取mysql镜像</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]# docker pull mysq<span class=\"variable\">l:5</span>.<span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">5.7</span>: Pulling from library/mysql</span><br><span class=\"line\"><span class=\"number\">123275</span>d6e508: Already <span class=\"built_in\">exists</span> </span><br><span class=\"line\"><span class=\"number\">27</span>cddf5c7140: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\">c17d442e14c9: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">2</span>eb72ffed068: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\">d4aa125eb616: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">52560</span>afb169c: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">68190</span>f37a1d2: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">3</span>fd1dc6e2990: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">85</span>a79b83df29: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">35</span>e0b437fe88: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\"><span class=\"number\">992</span>f6a10268c: Pull <span class=\"built_in\">complete</span> </span><br><span class=\"line\">Diges<span class=\"variable\">t:</span> <span class=\"built_in\">sha256</span>:<span class=\"number\">82</span>b72085b2fcff073a6616b84c7c3bcbb36e2d13af838cec11a9ed1d0b183f5e</span><br><span class=\"line\">Statu<span class=\"variable\">s:</span> Downloaded newer image <span class=\"keyword\">for</span> mysq<span class=\"variable\">l:5</span>.<span class=\"number\">7</span></span><br><span class=\"line\">docker.io/library/mysq<span class=\"variable\">l:5</span>.<span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>查看镜像</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"symbol\">root@</span>lcoalhost]# docker images</span><br><span class=\"line\">REPOSITORY  TAG    IMAGE ID     CREATED       SIZE</span><br><span class=\"line\">mysql       <span class=\"number\">5.7</span>    f5829c0eee9e <span class=\"number\">2</span> hours ago   <span class=\"number\">455</span>MB</span><br><span class=\"line\">[<span class=\"symbol\">root@</span>lcoalhost]#</span><br></pre></td></tr></table></figure>\n\n<p>启动mysql</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -p 3306:3306 --name mysql \\</span><br><span class=\"line\">-v /mydata/mysql/log:/var/log/mysql \\</span><br><span class=\"line\">-v /mydata/mysql/data:/var/lib/mysql \\</span><br><span class=\"line\">-v /mydata/mysql/conf:/etc/mysql \\</span><br><span class=\"line\">-e MYSQL_ROOT_PASSWORD=root \\</span><br><span class=\"line\">-d mysql:5.7</span><br></pre></td></tr></table></figure>\n\n<p>修改配置</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost]<span class=\"comment\"># cd /mydata/mysql/conf</span></span><br><span class=\"line\">// 配置如下：</span><br><span class=\"line\">[root@lcoalhost conf]<span class=\"comment\"># cat my.cnf</span></span><br><span class=\"line\">[client]</span><br><span class=\"line\">default-character-<span class=\"keyword\">set</span>=utf8</span><br><span class=\"line\">[mysql]</span><br><span class=\"line\"><span class=\"keyword\">default</span>-<span class=\"built_in\">character</span>-<span class=\"keyword\">set</span>=utf8</span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\">init_connect=<span class=\"string\">'SET collation_connection = utf8_unicode_ci'</span></span><br><span class=\"line\">init_connect=<span class=\"string\">'SET NAMES utf8'</span></span><br><span class=\"line\"><span class=\"built_in\">character</span>-<span class=\"keyword\">set</span>-<span class=\"keyword\">server</span>=utf8</span><br><span class=\"line\"><span class=\"keyword\">collation</span>-<span class=\"keyword\">server</span>=utf8_unicode_ci</span><br><span class=\"line\"><span class=\"keyword\">skip</span>-<span class=\"built_in\">character</span>-<span class=\"keyword\">set</span>-<span class=\"keyword\">client</span>-handshake</span><br><span class=\"line\"><span class=\"keyword\">skip</span>-<span class=\"keyword\">name</span>-resolve</span><br><span class=\"line\"></span><br><span class=\"line\">[root@lcoalhost conf]<span class=\"comment\"># docker restart mysql</span></span><br><span class=\"line\">mysql</span><br><span class=\"line\">[root@lcoalhost conf]<span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n\n<p>进入容器查看配置是否生效：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost conf]# docker exec -it mysql /bin/bash</span><br><span class=\"line\">root@b3a74e031bd7:/# whereis mysql</span><br><span class=\"line\">mysql: /usr/bin/mysql /usr/lib/mysql /etc/mysql /usr/share/mysql</span><br><span class=\"line\"></span><br><span class=\"line\">root@b3a74e031bd7:/# ls /etc/mysql </span><br><span class=\"line\">my.cnf</span><br><span class=\"line\">root@b3a74e031bd7:/# cat /etc/mysql/my.cnf </span><br><span class=\"line\">[client]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysql]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\">init_connect='SET collation_connection = utf8_unicode_ci'</span><br><span class=\"line\">init_connect='SET NAMES utf8'</span><br><span class=\"line\">character-set-server=utf8</span><br><span class=\"line\">collation-server=utf8_unicode_ci</span><br><span class=\"line\">skip-character-set-client-handshake</span><br><span class=\"line\">skip-name-resolve</span><br><span class=\"line\">root@b3a74e031bd7:/#</span><br></pre></td></tr></table></figure>\n\n<p>设置mysql随docker启动</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root<span class=\"symbol\">@lcoalhost</span> ~]<span class=\"meta\"># docker update mysql --restart=always</span></span><br><span class=\"line\">mysql</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"九、docker中安装Redis\"><a href=\"#九、docker中安装Redis\" class=\"headerlink\" title=\"九、docker中安装Redis\"></a>九、docker中安装Redis</h3><p>拉取redis镜像</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost ~]# docker pull redis</span><br><span class=\"line\">Using default tag: latest</span><br><span class=\"line\">latest: Pulling from library/redis</span><br><span class=\"line\">123275d6e508: Already exists </span><br><span class=\"line\">f2edbd6a658e: Pull complete </span><br><span class=\"line\">66960bede47c: Pull complete </span><br><span class=\"line\">79dc0b596c90: Pull complete </span><br><span class=\"line\">de36df38e0b6: Pull complete </span><br><span class=\"line\">602cd484ff92: Pull complete </span><br><span class=\"line\">Digest: sha256:1d0b903e3770c2c3c79961b73a53e963f4fd4b2674c2c4911472e8a054cb5728</span><br><span class=\"line\">Status: Downloaded newer image for redis:latest</span><br><span class=\"line\">docker.io/library/redis:latest</span><br></pre></td></tr></table></figure>\n\n<p>启动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost ~]# mkdir -p /mydata/redis/conf</span><br><span class=\"line\">[root@lcoalhost ~]# touch /mydata/redis/conf/redis.conf</span><br><span class=\"line\">[root@lcoalhost ~]# echo \"appendonly yes\"  &gt;&gt; /mydata/redis/conf/redis.conf // 开启数据持久化</span><br><span class=\"line\">[root@lcoalhost ~]# docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \\</span><br><span class=\"line\"> -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\</span><br><span class=\"line\"> -d redis redis-server /etc/redis/redis.conf</span><br><span class=\"line\">ce7ae709711986e3f90c9278b284fe6f51f1c1102ba05f3692f0e934ceca1565</span><br></pre></td></tr></table></figure>\n\n<p> 连接docker中的redis</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost ~]# docker exec -it redis redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; set key1 v1</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get key1</span><br><span class=\"line\">\"v1\"</span><br></pre></td></tr></table></figure>\n\n<p>设置redis随docker启动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@lcoalhost ~]# docker update redis --restart=always</span><br><span class=\"line\">redis</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"Git同时push到Github和Gitee","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":null,"abbrlink":"1af5","date":"2020-12-17T16:00:00.000Z","subtitle":null,"_content":"\n### 目的\n\nGithub有时访问会很慢，想用Gitee做个备份，如何将已有的Github项目同步到Gitee，并将修改同时push到自己的Github和Gitee上呢？\n\n### 1. 在Gitee上新建仓库，并关联Github仓库\n\n新建gitee仓库\n![create_gitee_repo](/img/1-work/tools/create_gitee_repo.png)\n\n复制github仓库的https地址并粘贴\n![import-github-repo](/img/1-work/tools/import-github-repo.png)\n\n创建，等待同步。\n\n### 2. 拉取Gitee项目，修改.git配置文件\n\n克隆创建好的Gitee项目：\n`git clone $项目地址`\n\ngit默认远程仓库为origin，可用git remote查看。\n添加gitee地址到origin：\n`git remote set-url --add origin $项目gitee地址`\n\n添加github地址到origin：\n`git remote set-url --add origin $项目github地址`\n\n也可直接打开配置文件修改，文件位于.git/config\n```\n[remote \"origin\"]\n \turl = https://gitee.com/$项目gitee地址\n \tfetch = +refs/heads/*:refs/remotes/origin/*\n \turl = https://github.com/$项目github地址\n```\n\n### 3. 修改完成，push一下看看吧\n\n若push不成功，可以检查一下自己是否有仓库权限，配置地址是否正确\n\n#### push时记住用户名密码的方法\n\n配置文件中使能保存密码功能：\n`git config credential.helper store`\n\n提交时输入用户名密码，再次提交就记住啦。","source":"_posts/git-push-two-repo.md","raw":"---\ntitle: Git同时push到Github和Gitee\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop:\ntags:\n  - git\ncategories:\n  - work\nabbrlink: 1af5\ndate: 2020-12-18 00:00:00\nsubtitle:\n---\n\n### 目的\n\nGithub有时访问会很慢，想用Gitee做个备份，如何将已有的Github项目同步到Gitee，并将修改同时push到自己的Github和Gitee上呢？\n\n### 1. 在Gitee上新建仓库，并关联Github仓库\n\n新建gitee仓库\n![create_gitee_repo](/img/1-work/tools/create_gitee_repo.png)\n\n复制github仓库的https地址并粘贴\n![import-github-repo](/img/1-work/tools/import-github-repo.png)\n\n创建，等待同步。\n\n### 2. 拉取Gitee项目，修改.git配置文件\n\n克隆创建好的Gitee项目：\n`git clone $项目地址`\n\ngit默认远程仓库为origin，可用git remote查看。\n添加gitee地址到origin：\n`git remote set-url --add origin $项目gitee地址`\n\n添加github地址到origin：\n`git remote set-url --add origin $项目github地址`\n\n也可直接打开配置文件修改，文件位于.git/config\n```\n[remote \"origin\"]\n \turl = https://gitee.com/$项目gitee地址\n \tfetch = +refs/heads/*:refs/remotes/origin/*\n \turl = https://github.com/$项目github地址\n```\n\n### 3. 修改完成，push一下看看吧\n\n若push不成功，可以检查一下自己是否有仓库权限，配置地址是否正确\n\n#### push时记住用户名密码的方法\n\n配置文件中使能保存密码功能：\n`git config credential.helper store`\n\n提交时输入用户名密码，再次提交就记住啦。","slug":"git-push-two-repo","published":1,"updated":"2021-12-10T09:05:27.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1ar000aacbfevk46d3k","content":"<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>Github有时访问会很慢，想用Gitee做个备份，如何将已有的Github项目同步到Gitee，并将修改同时push到自己的Github和Gitee上呢？</p>\n<h3 id=\"1-在Gitee上新建仓库，并关联Github仓库\"><a href=\"#1-在Gitee上新建仓库，并关联Github仓库\" class=\"headerlink\" title=\"1. 在Gitee上新建仓库，并关联Github仓库\"></a>1. 在Gitee上新建仓库，并关联Github仓库</h3><p>新建gitee仓库<br><img src=\"/img/1-work/tools/create_gitee_repo.png\" alt=\"create_gitee_repo\"></p>\n<p>复制github仓库的https地址并粘贴<br><img src=\"/img/1-work/tools/import-github-repo.png\" alt=\"import-github-repo\"></p>\n<p>创建，等待同步。</p>\n<h3 id=\"2-拉取Gitee项目，修改-git配置文件\"><a href=\"#2-拉取Gitee项目，修改-git配置文件\" class=\"headerlink\" title=\"2. 拉取Gitee项目，修改.git配置文件\"></a>2. 拉取Gitee项目，修改.git配置文件</h3><p>克隆创建好的Gitee项目：<br><code>git clone $项目地址</code></p>\n<p>git默认远程仓库为origin，可用git remote查看。<br>添加gitee地址到origin：<br><code>git remote set-url --add origin $项目gitee地址</code></p>\n<p>添加github地址到origin：<br><code>git remote set-url --add origin $项目github地址</code></p>\n<p>也可直接打开配置文件修改，文件位于.git/config</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[remote <span class=\"string\">\"origin\"</span>]</span><br><span class=\"line\"> \turl = <span class=\"symbol\">https:</span>/<span class=\"regexp\">/gitee.com/</span><span class=\"variable\">$项</span>目gitee地址</span><br><span class=\"line\"> \tfetch = +refs/heads/*<span class=\"symbol\">:refs/remotes/origin/*</span></span><br><span class=\"line\"> \turl = <span class=\"symbol\">https:</span>/<span class=\"regexp\">/github.com/</span><span class=\"variable\">$项</span>目github地址</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-修改完成，push一下看看吧\"><a href=\"#3-修改完成，push一下看看吧\" class=\"headerlink\" title=\"3. 修改完成，push一下看看吧\"></a>3. 修改完成，push一下看看吧</h3><p>若push不成功，可以检查一下自己是否有仓库权限，配置地址是否正确</p>\n<h4 id=\"push时记住用户名密码的方法\"><a href=\"#push时记住用户名密码的方法\" class=\"headerlink\" title=\"push时记住用户名密码的方法\"></a>push时记住用户名密码的方法</h4><p>配置文件中使能保存密码功能：<br><code>git config credential.helper store</code></p>\n<p>提交时输入用户名密码，再次提交就记住啦。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>Github有时访问会很慢，想用Gitee做个备份，如何将已有的Github项目同步到Gitee，并将修改同时push到自己的Github和Gitee上呢？</p>\n<h3 id=\"1-在Gitee上新建仓库，并关联Github仓库\"><a href=\"#1-在Gitee上新建仓库，并关联Github仓库\" class=\"headerlink\" title=\"1. 在Gitee上新建仓库，并关联Github仓库\"></a>1. 在Gitee上新建仓库，并关联Github仓库</h3><p>新建gitee仓库<br><img src=\"/img/1-work/tools/create_gitee_repo.png\" alt=\"create_gitee_repo\"></p>\n<p>复制github仓库的https地址并粘贴<br><img src=\"/img/1-work/tools/import-github-repo.png\" alt=\"import-github-repo\"></p>\n<p>创建，等待同步。</p>\n<h3 id=\"2-拉取Gitee项目，修改-git配置文件\"><a href=\"#2-拉取Gitee项目，修改-git配置文件\" class=\"headerlink\" title=\"2. 拉取Gitee项目，修改.git配置文件\"></a>2. 拉取Gitee项目，修改.git配置文件</h3><p>克隆创建好的Gitee项目：<br><code>git clone $项目地址</code></p>\n<p>git默认远程仓库为origin，可用git remote查看。<br>添加gitee地址到origin：<br><code>git remote set-url --add origin $项目gitee地址</code></p>\n<p>添加github地址到origin：<br><code>git remote set-url --add origin $项目github地址</code></p>\n<p>也可直接打开配置文件修改，文件位于.git/config</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[remote <span class=\"string\">\"origin\"</span>]</span><br><span class=\"line\"> \turl = <span class=\"symbol\">https:</span>/<span class=\"regexp\">/gitee.com/</span><span class=\"variable\">$项</span>目gitee地址</span><br><span class=\"line\"> \tfetch = +refs/heads/*<span class=\"symbol\">:refs/remotes/origin/*</span></span><br><span class=\"line\"> \turl = <span class=\"symbol\">https:</span>/<span class=\"regexp\">/github.com/</span><span class=\"variable\">$项</span>目github地址</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-修改完成，push一下看看吧\"><a href=\"#3-修改完成，push一下看看吧\" class=\"headerlink\" title=\"3. 修改完成，push一下看看吧\"></a>3. 修改完成，push一下看看吧</h3><p>若push不成功，可以检查一下自己是否有仓库权限，配置地址是否正确</p>\n<h4 id=\"push时记住用户名密码的方法\"><a href=\"#push时记住用户名密码的方法\" class=\"headerlink\" title=\"push时记住用户名密码的方法\"></a>push时记住用户名密码的方法</h4><p>配置文件中使能保存密码功能：<br><code>git config credential.helper store</code></p>\n<p>提交时输入用户名密码，再次提交就记住啦。</p>\n"},{"title":"数据结构与算法---排序","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":0,"abbrlink":"211a","date":"2020-12-20T16:00:00.000Z","subtitle":null,"_content":"### 数据结构与算法---O(n^2)排序\n#### 冒泡排序\n#### 插入排序\n#### 选择排序\n#### 希尔排序\n### 数据结构与算法---O(nlogn)排序\n#### 归并排序\n#### 快速排序\n#### 堆排序\n### 数据结构与算法---O(n)排序\n#### 计数排序\n#### 基数排序\n#### 桶排序","source":"_posts/algorithm-sort.md","raw":"---\ntitle: 数据结构与算法---排序\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop: 0\ntags:\n  - algorithm\ncategories:\n  - work\nabbrlink: 211a\ndate: 2020-12-21 00:00:00\nsubtitle:\n---\n### 数据结构与算法---O(n^2)排序\n#### 冒泡排序\n#### 插入排序\n#### 选择排序\n#### 希尔排序\n### 数据结构与算法---O(nlogn)排序\n#### 归并排序\n#### 快速排序\n#### 堆排序\n### 数据结构与算法---O(n)排序\n#### 计数排序\n#### 基数排序\n#### 桶排序","slug":"algorithm-sort","published":1,"updated":"2021-12-10T09:05:27.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1as000bacbf7l65628y","content":"<h3 id=\"数据结构与算法—O-n-2-排序\"><a href=\"#数据结构与算法—O-n-2-排序\" class=\"headerlink\" title=\"数据结构与算法—O(n^2)排序\"></a>数据结构与算法—O(n^2)排序</h3><h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><h4 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h4><h3 id=\"数据结构与算法—O-nlogn-排序\"><a href=\"#数据结构与算法—O-nlogn-排序\" class=\"headerlink\" title=\"数据结构与算法—O(nlogn)排序\"></a>数据结构与算法—O(nlogn)排序</h3><h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><h4 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h4><h3 id=\"数据结构与算法—O-n-排序\"><a href=\"#数据结构与算法—O-n-排序\" class=\"headerlink\" title=\"数据结构与算法—O(n)排序\"></a>数据结构与算法—O(n)排序</h3><h4 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h4><h4 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h4><h4 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"数据结构与算法—O-n-2-排序\"><a href=\"#数据结构与算法—O-n-2-排序\" class=\"headerlink\" title=\"数据结构与算法—O(n^2)排序\"></a>数据结构与算法—O(n^2)排序</h3><h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><h4 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h4><h3 id=\"数据结构与算法—O-nlogn-排序\"><a href=\"#数据结构与算法—O-nlogn-排序\" class=\"headerlink\" title=\"数据结构与算法—O(nlogn)排序\"></a>数据结构与算法—O(nlogn)排序</h3><h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><h4 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h4><h3 id=\"数据结构与算法—O-n-排序\"><a href=\"#数据结构与算法—O-n-排序\" class=\"headerlink\" title=\"数据结构与算法—O(n)排序\"></a>数据结构与算法—O(n)排序</h3><h4 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h4><h4 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h4><h4 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h4>"},{"title":"git 回滚指定版本并推送到远程分支","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":null,"abbrlink":"6186","date":"2020-11-25T16:00:00.000Z","_content":"\n1. ###### 回退\n\n    ```\n    git log //查看提交的历史\n    git reset --hard $要回退的commit号\n    ```\n\n2. ###### 切换到临时分支推送并删除原分支\n\n    ```\n    git checkout -b temp            // 新建临时分支并切换\n    git push origin temp:temp       // 将代码push到temp分支\n    git push origin --delete main   // 删除远端分支main，此处注意如果要删除的远端分支为默认分支则不可删除，需将默认分支切换到其他分支\n    git branch -d main              // 删除本地分支main\n    ```\n\n3. ###### 新建并切换回原分支并删除临时分支\n\n    ```\n    git checkout -b main            // 新建本地分支main并切换\n    git push origin main            // 提交分支main到远端\n    git branch -d temp\t\t\t\t// 删除本地临时分支\n    git push origin --delete temp\t// 删除远端临时分支，此处注意如果要删除的远端分支为默认分支则不可删除，需将默认分支切换到其他分支\n    ```\n\n    > ###### github切换默认分支：\n    >\n    > \t进入对应repo → Settings → Branches → Switch to another branch","source":"_posts/git-reset.md","raw":"---\ntitle: git 回滚指定版本并推送到远程分支\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop:\ntags:\n  - git\ncategories:\n  - work\nabbrlink: '6186'\ndate: 2020-11-26 00:00:00\n---\n\n1. ###### 回退\n\n    ```\n    git log //查看提交的历史\n    git reset --hard $要回退的commit号\n    ```\n\n2. ###### 切换到临时分支推送并删除原分支\n\n    ```\n    git checkout -b temp            // 新建临时分支并切换\n    git push origin temp:temp       // 将代码push到temp分支\n    git push origin --delete main   // 删除远端分支main，此处注意如果要删除的远端分支为默认分支则不可删除，需将默认分支切换到其他分支\n    git branch -d main              // 删除本地分支main\n    ```\n\n3. ###### 新建并切换回原分支并删除临时分支\n\n    ```\n    git checkout -b main            // 新建本地分支main并切换\n    git push origin main            // 提交分支main到远端\n    git branch -d temp\t\t\t\t// 删除本地临时分支\n    git push origin --delete temp\t// 删除远端临时分支，此处注意如果要删除的远端分支为默认分支则不可删除，需将默认分支切换到其他分支\n    ```\n\n    > ###### github切换默认分支：\n    >\n    > \t进入对应repo → Settings → Branches → Switch to another branch","slug":"git-reset","published":1,"updated":"2021-12-10T09:48:33.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1au000facbf9v2y2x5y","content":"<ol>\n<li><h6 id=\"回退\"><a href=\"#回退\" class=\"headerlink\" title=\"回退\"></a>回退</h6> <figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built-in\">log</span> <span class=\"comment\">//查看提交的历史</span></span><br><span class=\"line\">git reset --hard <span class=\"symbol\">$</span>要回退的commit号</span><br></pre></td></tr></table></figure>\n</li>\n<li><h6 id=\"切换到临时分支推送并删除原分支\"><a href=\"#切换到临时分支推送并删除原分支\" class=\"headerlink\" title=\"切换到临时分支推送并删除原分支\"></a>切换到临时分支推送并删除原分支</h6> <figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b temp            <span class=\"comment\">// 新建临时分支并切换</span></span><br><span class=\"line\">git <span class=\"keyword\">push</span> origin temp:temp       <span class=\"comment\">// 将代码push到temp分支</span></span><br><span class=\"line\">git <span class=\"keyword\">push</span> origin --<span class=\"keyword\">delete</span> main   <span class=\"comment\">// 删除远端分支main，此处注意如果要删除的远端分支为默认分支则不可删除，需将默认分支切换到其他分支</span></span><br><span class=\"line\">git branch -d main              <span class=\"comment\">// 删除本地分支main</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><h6 id=\"新建并切换回原分支并删除临时分支\"><a href=\"#新建并切换回原分支并删除临时分支\" class=\"headerlink\" title=\"新建并切换回原分支并删除临时分支\"></a>新建并切换回原分支并删除临时分支</h6> <figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b main            <span class=\"comment\">// 新建本地分支main并切换</span></span><br><span class=\"line\">git <span class=\"keyword\">push</span> origin main            <span class=\"comment\">// 提交分支main到远端</span></span><br><span class=\"line\">git branch -d temp\t\t\t\t<span class=\"comment\">// 删除本地临时分支</span></span><br><span class=\"line\">git <span class=\"keyword\">push</span> origin --<span class=\"keyword\">delete</span> temp\t<span class=\"comment\">// 删除远端临时分支，此处注意如果要删除的远端分支为默认分支则不可删除，需将默认分支切换到其他分支</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<h6 id=\"github切换默认分支：\"><a href=\"#github切换默认分支：\" class=\"headerlink\" title=\"github切换默认分支：\"></a>github切换默认分支：</h6><pre><code>进入对应repo → Settings → Branches → Switch to another branch</code></pre></blockquote>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><h6 id=\"回退\"><a href=\"#回退\" class=\"headerlink\" title=\"回退\"></a>回退</h6> <figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built-in\">log</span> <span class=\"comment\">//查看提交的历史</span></span><br><span class=\"line\">git reset --hard <span class=\"symbol\">$</span>要回退的commit号</span><br></pre></td></tr></table></figure>\n</li>\n<li><h6 id=\"切换到临时分支推送并删除原分支\"><a href=\"#切换到临时分支推送并删除原分支\" class=\"headerlink\" title=\"切换到临时分支推送并删除原分支\"></a>切换到临时分支推送并删除原分支</h6> <figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b temp            <span class=\"comment\">// 新建临时分支并切换</span></span><br><span class=\"line\">git <span class=\"keyword\">push</span> origin temp:temp       <span class=\"comment\">// 将代码push到temp分支</span></span><br><span class=\"line\">git <span class=\"keyword\">push</span> origin --<span class=\"keyword\">delete</span> main   <span class=\"comment\">// 删除远端分支main，此处注意如果要删除的远端分支为默认分支则不可删除，需将默认分支切换到其他分支</span></span><br><span class=\"line\">git branch -d main              <span class=\"comment\">// 删除本地分支main</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><h6 id=\"新建并切换回原分支并删除临时分支\"><a href=\"#新建并切换回原分支并删除临时分支\" class=\"headerlink\" title=\"新建并切换回原分支并删除临时分支\"></a>新建并切换回原分支并删除临时分支</h6> <figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b main            <span class=\"comment\">// 新建本地分支main并切换</span></span><br><span class=\"line\">git <span class=\"keyword\">push</span> origin main            <span class=\"comment\">// 提交分支main到远端</span></span><br><span class=\"line\">git branch -d temp\t\t\t\t<span class=\"comment\">// 删除本地临时分支</span></span><br><span class=\"line\">git <span class=\"keyword\">push</span> origin --<span class=\"keyword\">delete</span> temp\t<span class=\"comment\">// 删除远端临时分支，此处注意如果要删除的远端分支为默认分支则不可删除，需将默认分支切换到其他分支</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<h6 id=\"github切换默认分支：\"><a href=\"#github切换默认分支：\" class=\"headerlink\" title=\"github切换默认分支：\"></a>github切换默认分支：</h6><pre><code>进入对应repo → Settings → Branches → Switch to another branch</code></pre></blockquote>\n</li>\n</ol>\n"},{"title":"高并发IO的底层原理","header-img":"/img/header_img/dawn.jpg","catalog":true,"top":null,"abbrlink":"1af5","date":"2021-03-24T07:42:45.000Z","subtitle":null,"_content":"\n## 高并发IO的底层原理\n\n### 一、IO读写基础原理\n\n> ​\t\t用户程序进行IO的读写，会用到底层的read&write两大系统调用。无论是调用操作系统的read，还是write，都会涉及缓冲区。调用read，是把数据从内核缓冲区复制到进程缓冲区；而write，是把数据从进程缓冲区复制到内核缓冲区。也就是说，上层程序的IO操作，实际上不是物理设备级别的读写，而是缓存的复制。数据在内核缓冲区和物理设备（如磁盘）之间的交换，是由操作系统内核（Kernel）来完成的。\n\n#### 内核缓冲区与进程缓冲区\n\n​\t\t外部设备的直接读写，涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，而结束中断之后，还需要恢复之前的进程数据和状态等信息。为了减少这种底层系统的时间损耗、性能损耗，于是出现了内存缓冲区。每个用户程序（进程），有自己独立的缓冲区，叫作进程缓冲区。\n\n**典型的网络IO系统调用流程**，如图：\n\n![image](https://tvax1.sinaimg.cn/large/006YzKDNly1gous8df2kgj30h0096mxz.jpg)\n\n如果是在Java服务器端，完成一次socket请求和响应，完整的流程如下：\n\n- 客户端请求：Linux通过网卡读取客户端的请求数据，将数据读取到内核缓冲区。\n- 获取请求数据：Java服务器通过read系统调用，从Linux内核缓冲区读取数据，再送入Java进程缓冲区。\n- 服务器端业务处理：Java服务器在自己的用户空间中处理客户端的请求。\n- 服务器端返回数据：Java服务器完成处理后，构建好的响应数据，将这些数据从用户缓冲区写入内核缓冲区。这里用到的是write系统调用。\n- 发送给客户端：Linux内核通过网络IO，将内核缓冲区中的数据写入网卡，网卡通过底层的通信协议，会将数据发送给目标客户端。\n\n### 二、四种主要的IO模型\n\n> **阻塞与非阻塞**：阻塞IO，指的是需要内核IO操作彻底完成后，才返回到用户空间执行用户的操作。阻塞指的是用户空间程序的执行状态。\n>\n> **同步与异步**：同步IO是指用户空间的线程是主动发起IO请求的一方，内核空间是被动接受方。异步IO则反过来，是指系统内核是主动发起IO请求的一方（通知或回调），用户空间的线程是被动接受方。\n\n#### 1. 同步阻塞IO（Blocking IO）\n\n​\t\t在Java中，默认创建的socket都是同步阻塞的。在阻塞式IO模型中，Java应用程序**从IO系统调用开始，直到系统调用返回**，在这段时间内，Java进程是**阻塞**的。返回成功后，应用进程开始处理用户空间的缓存区数据。\n\n**同步阻塞IO流程**，如图：\n\n![image](https://tvax1.sinaimg.cn/large/006YzKDNly1gov1uvelijj30i30bbgph.jpg)\n\n- 阻塞IO特点：在内核进行IO执行的两个阶段（等待数据和复制数据），用户线程都被阻塞了。\n\n- 阻塞IO优点：应用的程序开发非常简单；在阻塞等待数据期间，用户线程挂起，基本不会占用CPU资源。\n\n- 阻塞IO缺点：一般情况下，会为每个连接配备一个独立的线程；反过来说，就是一个线程维护一个连接的IO操作。在并发量小的情况下，这样做没有什么问题。但是，当在高并发的应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。因此，基本上阻塞IO模型在高并发应用场景下是不可用的。\n\n#### 2. 同步非阻塞IO（Non-blocking IO）\n\n> 这里的NIO并非Java的NIO（New IO），Java的NIO，对应的不是四种基础IO模型中的NIO（None Blocking IO）模型，而是另外的一种模型，叫作IO多路复用模型（IO Multiplexing）。\n\n​\t\t在NIO模型中，应用程序一旦开始IO系统调用，会出现以下两种情况：\n\n​\t\t1. 在内核缓冲区中**没有数据**的情况下，系统调用会立即返回，返回一个调用失败的信息。\n\n​\t\t2. 在内核缓冲区中**有数据**的情况下，是**阻塞**的，直到数据从内核缓冲复制到用户进程缓冲。复制完成后，系统调用返回成功，应用进程开始处理用户空间的缓存数据。\n\n**同步非阻塞IO流程**，如图*(图源公众号“码农翻身”，侵删)*：\n\n![image](https://tva4.sinaimg.cn/large/006YzKDNgy1goxfc4wvqoj30ll0fmgmt.jpg)\n\n- 同步非阻塞IO**特点**：应用程序的线程需要不断地进行IO系统调用，轮询数据是否已经准备好，如果没有准备好，就继续**轮询**，直到完成IO系统调用为止。一般不单独使用，在其他模型中应用。\n\n- 同步非阻塞IO**优点**：每次发起的IO系统调用，在内核等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。\n\n- 同步非阻塞IO**缺点**：不断地轮询内核，这将占用大量的CPU时间，效率低下。\n\n#### 3. IO多路复用（IO Multiplexing）\n\n> 解决同步非阻塞IO模型中轮询等待的问题\n\n​\t\t在IO多路复用模型中，引入了一种新的系统调用，查询IO的就绪状态。在Linux系统中，对应的系统调用为select/epoll系统调用。通过该系统调用，单个应用程序的线程，可以不断地轮询成百上千的socket连接，一旦某个socket就绪（一般是内核缓冲区可读/可写），内核能够将就绪的状态返回给应用程序。随后，应用程序根据就绪的状态，进行相应的IO系统调用。\n\n**IO多路复用模型流程**，如图：\n\n![image](https://tvax3.sinaimg.cn/large/006YzKDNly1gov3zz1xp6j30h80bhdkc.jpg)\n\n- IO多路复用模型**特点**：涉及两种系统调用（SystemCall），一种是select/epoll（就绪查询），一种是IO操作。要使用IO多路复用模型，操作系统必须支持提供多路分离的系统调用select/epoll。负责select/epoll状态查询调用的线程，需要不断地进行select/epoll轮询，查找出达到IO操作就绪的socket连接。对于注册在选择器（Java中对应的选择器类是Selector类）上的**每一个可以查询的socket连接**，一般都设置成为**同步非阻塞模型**。\n- IO多路复用模型**优点**：一个选择器查询线程可以同时处理成千上万个连接（Connection）。系统不必创建和维护大量线程，减小系统开销。*Java的NIO（New IO）技术和Netty框架，使用的就是IO多路复用模型。在Linux系统上，使用的是epoll系统调用。*\n- IO多路复用模型**缺点**：本质上，select/epoll系统调用是阻塞式的，属于同步IO。都需要在读写事件就绪后，由系统调用本身负责进行读写，也就是说这个读写过程是阻塞的。\n\n##### select: \n\n​\t\tselect可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理*(图源公众号“码农翻身”，侵删)*：\n\n![20210326180007](https://tva2.sinaimg.cn/large/006YzKDNgy1goxgnhkba8g30fa0b4x6p.gif)\n\n1. 首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。\n2. 然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。\n3. 不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。\n\n可以看出几个问题：\n\n​\t1. select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）\n\n​\t2. select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）\n\n​\t3. select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）\n\n##### epoll:\n\n​\t\t解决了 select 的上述问题:\n\n  1. 内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。\n\n  2. 内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。\n\n  3. 内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。\n\n     原理如图*(图源公众号“码农翻身”，侵删)*：\n\n     ![20210326181258](https://tvax2.sinaimg.cn/large/006YzKDNgy1goxh0qffnzg30fa0b4e81.gif)\n\n     **多路复用快的原因**：操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。\n\n#### 4. 异步IO（Asynchronous IO）\n\n> 彻底解除线程的阻塞\n\n​\t\t对于异步IO，当用户线程发起read系统调用后，立刻就可以做其他的事，不阻塞。内核开始准备数据，并复制数据到用户缓冲区。复制完成后，内核会给用户线程发送一个信号（Signal），或者回调用户线程注册的回调接口，告诉用户线程read操作完成了。\n\n**异步IO模型流程**，如图：\n\n![image](https://tvax3.sinaimg.cn/large/006YzKDNly1gov4h3y1m6j30go0c2q7m.jpg)\n\n- 异步IO模型**特点**：在内核等待数据和复制数据的**两个阶段，用户线程都不阻塞**。用户线程需要接收内核的IO操作完成的事件，或者用户线程需要注册一个IO操作完成的回调函数。正因为如此，异步IO有的时候也被称为信号驱动IO。\n- 异步IO模型缺点：应用程序仅需要进行事件的注册与接收，其余的工作都留给了操作系统，也就是说，需要底层内核提供支持。\n\n> ​        就目前而言，Windows系统下通过IOCP实现了真正的异步IO。而在Linux系统下，异步IO模型在2.6版本才引入，目前并不完善，其底层实现仍使用epoll，与IO多路复用相同，因此在性能上没有明显的优势。大多数高并发服务器端程序，都是基于Linux系统的。因而，**目前这类高并发网络应用程序的开发，大多采用IO多路复用模型。**\n\n### 三、系统配置最大句柄\n\n> 在生产环境Linux系统中，基本上都需要解除文件句柄数的限制。因为Linux的系统默认值为1024，也就是说，一个进程最多可以接受1024个socket连接。\n\n#### 文件句柄\n\n​\t\t也叫文件描述符，在Linux系统中，文件可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（File Descriptor）是内核为了高效管理已被打开的文件所创建的索引，它是一个非负整数（通常是小整数），用于指代被打开的文件。所有的IO系统调用，包括socket的读写调用，都是通过文件描述符完成的。在Linux下，可以通过`ulimit -n`看到单个进程能够打开的最大文件句柄数量。Linux的系统默认值为1024。\n\n​\t\t对于高并发的应用，面临的并发连接数往往是十万级、百万级、千万级、甚至像腾讯QQ一样的上亿级。当单个进程打开的文件句柄数量，超过了系统配置上限值时，会发出“Socket/File:Can't open so many files”的错误提示。\n\n#### 配置\n\n​\t\t可以通过`ulimit -n 1000000`修改句柄数（最大值是1048576 ），但是ulimit命令仅对当前用户有效，如果想永久保存配置，可以编辑/etc/rc.local开机启动文件，添加如下内容：\n\n```\nulimit -SHn 1000000\n```\n\n​\t\t增加-S和-H两个命令选项。选项-S表示软性极限值，-H表示硬性极限值。硬性极限（需要root权限）是实际的限制，就是最大可以是100万，不能再多了。软性极限是系统警告（Warning）的极限值，超过这个极限值，内核会发出警告。\n\n​\t\t终极解除Linux系统的最大文件打开数量的限制，可以编辑/etc/security/limits.conf，添加如下内容：\n\n```\nsoft nofile 1000000\nhard nofile 1000000\n```\n\nsoft nofile表示软性极限，hard nofile表示硬性极限。不可以设置unlimited。\n\n","source":"_posts/io.md","raw":"---\ntitle: 高并发IO的底层原理\nheader-img: /img/header_img/dawn.jpg\ncatalog: true\ntop:\ntags:\n  - IO\ncategories:\n  - work\nabbrlink: 1af5\ndate: 2021-3-24 15:42:45\nsubtitle:\n---\n\n## 高并发IO的底层原理\n\n### 一、IO读写基础原理\n\n> ​\t\t用户程序进行IO的读写，会用到底层的read&write两大系统调用。无论是调用操作系统的read，还是write，都会涉及缓冲区。调用read，是把数据从内核缓冲区复制到进程缓冲区；而write，是把数据从进程缓冲区复制到内核缓冲区。也就是说，上层程序的IO操作，实际上不是物理设备级别的读写，而是缓存的复制。数据在内核缓冲区和物理设备（如磁盘）之间的交换，是由操作系统内核（Kernel）来完成的。\n\n#### 内核缓冲区与进程缓冲区\n\n​\t\t外部设备的直接读写，涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，而结束中断之后，还需要恢复之前的进程数据和状态等信息。为了减少这种底层系统的时间损耗、性能损耗，于是出现了内存缓冲区。每个用户程序（进程），有自己独立的缓冲区，叫作进程缓冲区。\n\n**典型的网络IO系统调用流程**，如图：\n\n![image](https://tvax1.sinaimg.cn/large/006YzKDNly1gous8df2kgj30h0096mxz.jpg)\n\n如果是在Java服务器端，完成一次socket请求和响应，完整的流程如下：\n\n- 客户端请求：Linux通过网卡读取客户端的请求数据，将数据读取到内核缓冲区。\n- 获取请求数据：Java服务器通过read系统调用，从Linux内核缓冲区读取数据，再送入Java进程缓冲区。\n- 服务器端业务处理：Java服务器在自己的用户空间中处理客户端的请求。\n- 服务器端返回数据：Java服务器完成处理后，构建好的响应数据，将这些数据从用户缓冲区写入内核缓冲区。这里用到的是write系统调用。\n- 发送给客户端：Linux内核通过网络IO，将内核缓冲区中的数据写入网卡，网卡通过底层的通信协议，会将数据发送给目标客户端。\n\n### 二、四种主要的IO模型\n\n> **阻塞与非阻塞**：阻塞IO，指的是需要内核IO操作彻底完成后，才返回到用户空间执行用户的操作。阻塞指的是用户空间程序的执行状态。\n>\n> **同步与异步**：同步IO是指用户空间的线程是主动发起IO请求的一方，内核空间是被动接受方。异步IO则反过来，是指系统内核是主动发起IO请求的一方（通知或回调），用户空间的线程是被动接受方。\n\n#### 1. 同步阻塞IO（Blocking IO）\n\n​\t\t在Java中，默认创建的socket都是同步阻塞的。在阻塞式IO模型中，Java应用程序**从IO系统调用开始，直到系统调用返回**，在这段时间内，Java进程是**阻塞**的。返回成功后，应用进程开始处理用户空间的缓存区数据。\n\n**同步阻塞IO流程**，如图：\n\n![image](https://tvax1.sinaimg.cn/large/006YzKDNly1gov1uvelijj30i30bbgph.jpg)\n\n- 阻塞IO特点：在内核进行IO执行的两个阶段（等待数据和复制数据），用户线程都被阻塞了。\n\n- 阻塞IO优点：应用的程序开发非常简单；在阻塞等待数据期间，用户线程挂起，基本不会占用CPU资源。\n\n- 阻塞IO缺点：一般情况下，会为每个连接配备一个独立的线程；反过来说，就是一个线程维护一个连接的IO操作。在并发量小的情况下，这样做没有什么问题。但是，当在高并发的应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。因此，基本上阻塞IO模型在高并发应用场景下是不可用的。\n\n#### 2. 同步非阻塞IO（Non-blocking IO）\n\n> 这里的NIO并非Java的NIO（New IO），Java的NIO，对应的不是四种基础IO模型中的NIO（None Blocking IO）模型，而是另外的一种模型，叫作IO多路复用模型（IO Multiplexing）。\n\n​\t\t在NIO模型中，应用程序一旦开始IO系统调用，会出现以下两种情况：\n\n​\t\t1. 在内核缓冲区中**没有数据**的情况下，系统调用会立即返回，返回一个调用失败的信息。\n\n​\t\t2. 在内核缓冲区中**有数据**的情况下，是**阻塞**的，直到数据从内核缓冲复制到用户进程缓冲。复制完成后，系统调用返回成功，应用进程开始处理用户空间的缓存数据。\n\n**同步非阻塞IO流程**，如图*(图源公众号“码农翻身”，侵删)*：\n\n![image](https://tva4.sinaimg.cn/large/006YzKDNgy1goxfc4wvqoj30ll0fmgmt.jpg)\n\n- 同步非阻塞IO**特点**：应用程序的线程需要不断地进行IO系统调用，轮询数据是否已经准备好，如果没有准备好，就继续**轮询**，直到完成IO系统调用为止。一般不单独使用，在其他模型中应用。\n\n- 同步非阻塞IO**优点**：每次发起的IO系统调用，在内核等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。\n\n- 同步非阻塞IO**缺点**：不断地轮询内核，这将占用大量的CPU时间，效率低下。\n\n#### 3. IO多路复用（IO Multiplexing）\n\n> 解决同步非阻塞IO模型中轮询等待的问题\n\n​\t\t在IO多路复用模型中，引入了一种新的系统调用，查询IO的就绪状态。在Linux系统中，对应的系统调用为select/epoll系统调用。通过该系统调用，单个应用程序的线程，可以不断地轮询成百上千的socket连接，一旦某个socket就绪（一般是内核缓冲区可读/可写），内核能够将就绪的状态返回给应用程序。随后，应用程序根据就绪的状态，进行相应的IO系统调用。\n\n**IO多路复用模型流程**，如图：\n\n![image](https://tvax3.sinaimg.cn/large/006YzKDNly1gov3zz1xp6j30h80bhdkc.jpg)\n\n- IO多路复用模型**特点**：涉及两种系统调用（SystemCall），一种是select/epoll（就绪查询），一种是IO操作。要使用IO多路复用模型，操作系统必须支持提供多路分离的系统调用select/epoll。负责select/epoll状态查询调用的线程，需要不断地进行select/epoll轮询，查找出达到IO操作就绪的socket连接。对于注册在选择器（Java中对应的选择器类是Selector类）上的**每一个可以查询的socket连接**，一般都设置成为**同步非阻塞模型**。\n- IO多路复用模型**优点**：一个选择器查询线程可以同时处理成千上万个连接（Connection）。系统不必创建和维护大量线程，减小系统开销。*Java的NIO（New IO）技术和Netty框架，使用的就是IO多路复用模型。在Linux系统上，使用的是epoll系统调用。*\n- IO多路复用模型**缺点**：本质上，select/epoll系统调用是阻塞式的，属于同步IO。都需要在读写事件就绪后，由系统调用本身负责进行读写，也就是说这个读写过程是阻塞的。\n\n##### select: \n\n​\t\tselect可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理*(图源公众号“码农翻身”，侵删)*：\n\n![20210326180007](https://tva2.sinaimg.cn/large/006YzKDNgy1goxgnhkba8g30fa0b4x6p.gif)\n\n1. 首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。\n2. 然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。\n3. 不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。\n\n可以看出几个问题：\n\n​\t1. select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）\n\n​\t2. select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）\n\n​\t3. select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）\n\n##### epoll:\n\n​\t\t解决了 select 的上述问题:\n\n  1. 内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。\n\n  2. 内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。\n\n  3. 内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。\n\n     原理如图*(图源公众号“码农翻身”，侵删)*：\n\n     ![20210326181258](https://tvax2.sinaimg.cn/large/006YzKDNgy1goxh0qffnzg30fa0b4e81.gif)\n\n     **多路复用快的原因**：操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。\n\n#### 4. 异步IO（Asynchronous IO）\n\n> 彻底解除线程的阻塞\n\n​\t\t对于异步IO，当用户线程发起read系统调用后，立刻就可以做其他的事，不阻塞。内核开始准备数据，并复制数据到用户缓冲区。复制完成后，内核会给用户线程发送一个信号（Signal），或者回调用户线程注册的回调接口，告诉用户线程read操作完成了。\n\n**异步IO模型流程**，如图：\n\n![image](https://tvax3.sinaimg.cn/large/006YzKDNly1gov4h3y1m6j30go0c2q7m.jpg)\n\n- 异步IO模型**特点**：在内核等待数据和复制数据的**两个阶段，用户线程都不阻塞**。用户线程需要接收内核的IO操作完成的事件，或者用户线程需要注册一个IO操作完成的回调函数。正因为如此，异步IO有的时候也被称为信号驱动IO。\n- 异步IO模型缺点：应用程序仅需要进行事件的注册与接收，其余的工作都留给了操作系统，也就是说，需要底层内核提供支持。\n\n> ​        就目前而言，Windows系统下通过IOCP实现了真正的异步IO。而在Linux系统下，异步IO模型在2.6版本才引入，目前并不完善，其底层实现仍使用epoll，与IO多路复用相同，因此在性能上没有明显的优势。大多数高并发服务器端程序，都是基于Linux系统的。因而，**目前这类高并发网络应用程序的开发，大多采用IO多路复用模型。**\n\n### 三、系统配置最大句柄\n\n> 在生产环境Linux系统中，基本上都需要解除文件句柄数的限制。因为Linux的系统默认值为1024，也就是说，一个进程最多可以接受1024个socket连接。\n\n#### 文件句柄\n\n​\t\t也叫文件描述符，在Linux系统中，文件可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（File Descriptor）是内核为了高效管理已被打开的文件所创建的索引，它是一个非负整数（通常是小整数），用于指代被打开的文件。所有的IO系统调用，包括socket的读写调用，都是通过文件描述符完成的。在Linux下，可以通过`ulimit -n`看到单个进程能够打开的最大文件句柄数量。Linux的系统默认值为1024。\n\n​\t\t对于高并发的应用，面临的并发连接数往往是十万级、百万级、千万级、甚至像腾讯QQ一样的上亿级。当单个进程打开的文件句柄数量，超过了系统配置上限值时，会发出“Socket/File:Can't open so many files”的错误提示。\n\n#### 配置\n\n​\t\t可以通过`ulimit -n 1000000`修改句柄数（最大值是1048576 ），但是ulimit命令仅对当前用户有效，如果想永久保存配置，可以编辑/etc/rc.local开机启动文件，添加如下内容：\n\n```\nulimit -SHn 1000000\n```\n\n​\t\t增加-S和-H两个命令选项。选项-S表示软性极限值，-H表示硬性极限值。硬性极限（需要root权限）是实际的限制，就是最大可以是100万，不能再多了。软性极限是系统警告（Warning）的极限值，超过这个极限值，内核会发出警告。\n\n​\t\t终极解除Linux系统的最大文件打开数量的限制，可以编辑/etc/security/limits.conf，添加如下内容：\n\n```\nsoft nofile 1000000\nhard nofile 1000000\n```\n\nsoft nofile表示软性极限，hard nofile表示硬性极限。不可以设置unlimited。\n\n","slug":"io","published":1,"updated":"2021-12-10T09:05:27.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1aw000iacbf4dcv52x1","content":"<h2 id=\"高并发IO的底层原理\"><a href=\"#高并发IO的底层原理\" class=\"headerlink\" title=\"高并发IO的底层原理\"></a>高并发IO的底层原理</h2><h3 id=\"一、IO读写基础原理\"><a href=\"#一、IO读写基础原理\" class=\"headerlink\" title=\"一、IO读写基础原理\"></a>一、IO读写基础原理</h3><blockquote>\n<p>​        用户程序进行IO的读写，会用到底层的read&amp;write两大系统调用。无论是调用操作系统的read，还是write，都会涉及缓冲区。调用read，是把数据从内核缓冲区复制到进程缓冲区；而write，是把数据从进程缓冲区复制到内核缓冲区。也就是说，上层程序的IO操作，实际上不是物理设备级别的读写，而是缓存的复制。数据在内核缓冲区和物理设备（如磁盘）之间的交换，是由操作系统内核（Kernel）来完成的。</p>\n</blockquote>\n<h4 id=\"内核缓冲区与进程缓冲区\"><a href=\"#内核缓冲区与进程缓冲区\" class=\"headerlink\" title=\"内核缓冲区与进程缓冲区\"></a>内核缓冲区与进程缓冲区</h4><p>​        外部设备的直接读写，涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，而结束中断之后，还需要恢复之前的进程数据和状态等信息。为了减少这种底层系统的时间损耗、性能损耗，于是出现了内存缓冲区。每个用户程序（进程），有自己独立的缓冲区，叫作进程缓冲区。</p>\n<p><strong>典型的网络IO系统调用流程</strong>，如图：</p>\n<p><img src=\"https://tvax1.sinaimg.cn/large/006YzKDNly1gous8df2kgj30h0096mxz.jpg\" alt=\"image\"></p>\n<p>如果是在Java服务器端，完成一次socket请求和响应，完整的流程如下：</p>\n<ul>\n<li>客户端请求：Linux通过网卡读取客户端的请求数据，将数据读取到内核缓冲区。</li>\n<li>获取请求数据：Java服务器通过read系统调用，从Linux内核缓冲区读取数据，再送入Java进程缓冲区。</li>\n<li>服务器端业务处理：Java服务器在自己的用户空间中处理客户端的请求。</li>\n<li>服务器端返回数据：Java服务器完成处理后，构建好的响应数据，将这些数据从用户缓冲区写入内核缓冲区。这里用到的是write系统调用。</li>\n<li>发送给客户端：Linux内核通过网络IO，将内核缓冲区中的数据写入网卡，网卡通过底层的通信协议，会将数据发送给目标客户端。</li>\n</ul>\n<h3 id=\"二、四种主要的IO模型\"><a href=\"#二、四种主要的IO模型\" class=\"headerlink\" title=\"二、四种主要的IO模型\"></a>二、四种主要的IO模型</h3><blockquote>\n<p><strong>阻塞与非阻塞</strong>：阻塞IO，指的是需要内核IO操作彻底完成后，才返回到用户空间执行用户的操作。阻塞指的是用户空间程序的执行状态。</p>\n<p><strong>同步与异步</strong>：同步IO是指用户空间的线程是主动发起IO请求的一方，内核空间是被动接受方。异步IO则反过来，是指系统内核是主动发起IO请求的一方（通知或回调），用户空间的线程是被动接受方。</p>\n</blockquote>\n<h4 id=\"1-同步阻塞IO（Blocking-IO）\"><a href=\"#1-同步阻塞IO（Blocking-IO）\" class=\"headerlink\" title=\"1. 同步阻塞IO（Blocking IO）\"></a>1. 同步阻塞IO（Blocking IO）</h4><p>​        在Java中，默认创建的socket都是同步阻塞的。在阻塞式IO模型中，Java应用程序<strong>从IO系统调用开始，直到系统调用返回</strong>，在这段时间内，Java进程是<strong>阻塞</strong>的。返回成功后，应用进程开始处理用户空间的缓存区数据。</p>\n<p><strong>同步阻塞IO流程</strong>，如图：</p>\n<p><img src=\"https://tvax1.sinaimg.cn/large/006YzKDNly1gov1uvelijj30i30bbgph.jpg\" alt=\"image\"></p>\n<ul>\n<li><p>阻塞IO特点：在内核进行IO执行的两个阶段（等待数据和复制数据），用户线程都被阻塞了。</p>\n</li>\n<li><p>阻塞IO优点：应用的程序开发非常简单；在阻塞等待数据期间，用户线程挂起，基本不会占用CPU资源。</p>\n</li>\n<li><p>阻塞IO缺点：一般情况下，会为每个连接配备一个独立的线程；反过来说，就是一个线程维护一个连接的IO操作。在并发量小的情况下，这样做没有什么问题。但是，当在高并发的应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。因此，基本上阻塞IO模型在高并发应用场景下是不可用的。</p>\n</li>\n</ul>\n<h4 id=\"2-同步非阻塞IO（Non-blocking-IO）\"><a href=\"#2-同步非阻塞IO（Non-blocking-IO）\" class=\"headerlink\" title=\"2. 同步非阻塞IO（Non-blocking IO）\"></a>2. 同步非阻塞IO（Non-blocking IO）</h4><blockquote>\n<p>这里的NIO并非Java的NIO（New IO），Java的NIO，对应的不是四种基础IO模型中的NIO（None Blocking IO）模型，而是另外的一种模型，叫作IO多路复用模型（IO Multiplexing）。</p>\n</blockquote>\n<p>​        在NIO模型中，应用程序一旦开始IO系统调用，会出现以下两种情况：</p>\n<p>​        1. 在内核缓冲区中<strong>没有数据</strong>的情况下，系统调用会立即返回，返回一个调用失败的信息。</p>\n<p>​        2. 在内核缓冲区中<strong>有数据</strong>的情况下，是<strong>阻塞</strong>的，直到数据从内核缓冲复制到用户进程缓冲。复制完成后，系统调用返回成功，应用进程开始处理用户空间的缓存数据。</p>\n<p><strong>同步非阻塞IO流程</strong>，如图<em>(图源公众号“码农翻身”，侵删)</em>：</p>\n<p><img src=\"https://tva4.sinaimg.cn/large/006YzKDNgy1goxfc4wvqoj30ll0fmgmt.jpg\" alt=\"image\"></p>\n<ul>\n<li><p>同步非阻塞IO<strong>特点</strong>：应用程序的线程需要不断地进行IO系统调用，轮询数据是否已经准备好，如果没有准备好，就继续<strong>轮询</strong>，直到完成IO系统调用为止。一般不单独使用，在其他模型中应用。</p>\n</li>\n<li><p>同步非阻塞IO<strong>优点</strong>：每次发起的IO系统调用，在内核等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。</p>\n</li>\n<li><p>同步非阻塞IO<strong>缺点</strong>：不断地轮询内核，这将占用大量的CPU时间，效率低下。</p>\n</li>\n</ul>\n<h4 id=\"3-IO多路复用（IO-Multiplexing）\"><a href=\"#3-IO多路复用（IO-Multiplexing）\" class=\"headerlink\" title=\"3. IO多路复用（IO Multiplexing）\"></a>3. IO多路复用（IO Multiplexing）</h4><blockquote>\n<p>解决同步非阻塞IO模型中轮询等待的问题</p>\n</blockquote>\n<p>​        在IO多路复用模型中，引入了一种新的系统调用，查询IO的就绪状态。在Linux系统中，对应的系统调用为select/epoll系统调用。通过该系统调用，单个应用程序的线程，可以不断地轮询成百上千的socket连接，一旦某个socket就绪（一般是内核缓冲区可读/可写），内核能够将就绪的状态返回给应用程序。随后，应用程序根据就绪的状态，进行相应的IO系统调用。</p>\n<p><strong>IO多路复用模型流程</strong>，如图：</p>\n<p><img src=\"https://tvax3.sinaimg.cn/large/006YzKDNly1gov3zz1xp6j30h80bhdkc.jpg\" alt=\"image\"></p>\n<ul>\n<li>IO多路复用模型<strong>特点</strong>：涉及两种系统调用（SystemCall），一种是select/epoll（就绪查询），一种是IO操作。要使用IO多路复用模型，操作系统必须支持提供多路分离的系统调用select/epoll。负责select/epoll状态查询调用的线程，需要不断地进行select/epoll轮询，查找出达到IO操作就绪的socket连接。对于注册在选择器（Java中对应的选择器类是Selector类）上的<strong>每一个可以查询的socket连接</strong>，一般都设置成为<strong>同步非阻塞模型</strong>。</li>\n<li>IO多路复用模型<strong>优点</strong>：一个选择器查询线程可以同时处理成千上万个连接（Connection）。系统不必创建和维护大量线程，减小系统开销。<em>Java的NIO（New IO）技术和Netty框架，使用的就是IO多路复用模型。在Linux系统上，使用的是epoll系统调用。</em></li>\n<li>IO多路复用模型<strong>缺点</strong>：本质上，select/epoll系统调用是阻塞式的，属于同步IO。都需要在读写事件就绪后，由系统调用本身负责进行读写，也就是说这个读写过程是阻塞的。</li>\n</ul>\n<h5 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select:\"></a>select:</h5><p>​        select可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理<em>(图源公众号“码农翻身”，侵删)</em>：</p>\n<p><img src=\"https://tva2.sinaimg.cn/large/006YzKDNgy1goxgnhkba8g30fa0b4x6p.gif\" alt=\"20210326180007\"></p>\n<ol>\n<li>首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。</li>\n<li>然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。</li>\n<li>不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。</li>\n</ol>\n<p>可以看出几个问题：</p>\n<p>​    1. select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>\n<p>​    2. select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>\n<p>​    3. select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>\n<h5 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll:\"></a>epoll:</h5><p>​        解决了 select 的上述问题:</p>\n<ol>\n<li><p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</p>\n</li>\n<li><p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p>\n</li>\n<li><p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p>\n<p>原理如图<em>(图源公众号“码农翻身”，侵删)</em>：</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNgy1goxh0qffnzg30fa0b4e81.gif\" alt=\"20210326181258\"></p>\n<p><strong>多路复用快的原因</strong>：操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。</p>\n</li>\n</ol>\n<h4 id=\"4-异步IO（Asynchronous-IO）\"><a href=\"#4-异步IO（Asynchronous-IO）\" class=\"headerlink\" title=\"4. 异步IO（Asynchronous IO）\"></a>4. 异步IO（Asynchronous IO）</h4><blockquote>\n<p>彻底解除线程的阻塞</p>\n</blockquote>\n<p>​        对于异步IO，当用户线程发起read系统调用后，立刻就可以做其他的事，不阻塞。内核开始准备数据，并复制数据到用户缓冲区。复制完成后，内核会给用户线程发送一个信号（Signal），或者回调用户线程注册的回调接口，告诉用户线程read操作完成了。</p>\n<p><strong>异步IO模型流程</strong>，如图：</p>\n<p><img src=\"https://tvax3.sinaimg.cn/large/006YzKDNly1gov4h3y1m6j30go0c2q7m.jpg\" alt=\"image\"></p>\n<ul>\n<li>异步IO模型<strong>特点</strong>：在内核等待数据和复制数据的<strong>两个阶段，用户线程都不阻塞</strong>。用户线程需要接收内核的IO操作完成的事件，或者用户线程需要注册一个IO操作完成的回调函数。正因为如此，异步IO有的时候也被称为信号驱动IO。</li>\n<li>异步IO模型缺点：应用程序仅需要进行事件的注册与接收，其余的工作都留给了操作系统，也就是说，需要底层内核提供支持。</li>\n</ul>\n<blockquote>\n<p>​        就目前而言，Windows系统下通过IOCP实现了真正的异步IO。而在Linux系统下，异步IO模型在2.6版本才引入，目前并不完善，其底层实现仍使用epoll，与IO多路复用相同，因此在性能上没有明显的优势。大多数高并发服务器端程序，都是基于Linux系统的。因而，<strong>目前这类高并发网络应用程序的开发，大多采用IO多路复用模型。</strong></p>\n</blockquote>\n<h3 id=\"三、系统配置最大句柄\"><a href=\"#三、系统配置最大句柄\" class=\"headerlink\" title=\"三、系统配置最大句柄\"></a>三、系统配置最大句柄</h3><blockquote>\n<p>在生产环境Linux系统中，基本上都需要解除文件句柄数的限制。因为Linux的系统默认值为1024，也就是说，一个进程最多可以接受1024个socket连接。</p>\n</blockquote>\n<h4 id=\"文件句柄\"><a href=\"#文件句柄\" class=\"headerlink\" title=\"文件句柄\"></a>文件句柄</h4><p>​        也叫文件描述符，在Linux系统中，文件可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（File Descriptor）是内核为了高效管理已被打开的文件所创建的索引，它是一个非负整数（通常是小整数），用于指代被打开的文件。所有的IO系统调用，包括socket的读写调用，都是通过文件描述符完成的。在Linux下，可以通过<code>ulimit -n</code>看到单个进程能够打开的最大文件句柄数量。Linux的系统默认值为1024。</p>\n<p>​        对于高并发的应用，面临的并发连接数往往是十万级、百万级、千万级、甚至像腾讯QQ一样的上亿级。当单个进程打开的文件句柄数量，超过了系统配置上限值时，会发出“Socket/File:Can’t open so many files”的错误提示。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>​        可以通过<code>ulimit -n 1000000</code>修改句柄数（最大值是1048576 ），但是ulimit命令仅对当前用户有效，如果想永久保存配置，可以编辑/etc/rc.local开机启动文件，添加如下内容：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ulimit -SHn <span class=\"number\">1000000</span></span><br></pre></td></tr></table></figure>\n\n<p>​        增加-S和-H两个命令选项。选项-S表示软性极限值，-H表示硬性极限值。硬性极限（需要root权限）是实际的限制，就是最大可以是100万，不能再多了。软性极限是系统警告（Warning）的极限值，超过这个极限值，内核会发出警告。</p>\n<p>​        终极解除Linux系统的最大文件打开数量的限制，可以编辑/etc/security/limits.conf，添加如下内容：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">soft nofile <span class=\"number\">1000000</span></span><br><span class=\"line\">hard nofile <span class=\"number\">1000000</span></span><br></pre></td></tr></table></figure>\n\n<p>soft nofile表示软性极限，hard nofile表示硬性极限。不可以设置unlimited。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"高并发IO的底层原理\"><a href=\"#高并发IO的底层原理\" class=\"headerlink\" title=\"高并发IO的底层原理\"></a>高并发IO的底层原理</h2><h3 id=\"一、IO读写基础原理\"><a href=\"#一、IO读写基础原理\" class=\"headerlink\" title=\"一、IO读写基础原理\"></a>一、IO读写基础原理</h3><blockquote>\n<p>​        用户程序进行IO的读写，会用到底层的read&amp;write两大系统调用。无论是调用操作系统的read，还是write，都会涉及缓冲区。调用read，是把数据从内核缓冲区复制到进程缓冲区；而write，是把数据从进程缓冲区复制到内核缓冲区。也就是说，上层程序的IO操作，实际上不是物理设备级别的读写，而是缓存的复制。数据在内核缓冲区和物理设备（如磁盘）之间的交换，是由操作系统内核（Kernel）来完成的。</p>\n</blockquote>\n<h4 id=\"内核缓冲区与进程缓冲区\"><a href=\"#内核缓冲区与进程缓冲区\" class=\"headerlink\" title=\"内核缓冲区与进程缓冲区\"></a>内核缓冲区与进程缓冲区</h4><p>​        外部设备的直接读写，涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，而结束中断之后，还需要恢复之前的进程数据和状态等信息。为了减少这种底层系统的时间损耗、性能损耗，于是出现了内存缓冲区。每个用户程序（进程），有自己独立的缓冲区，叫作进程缓冲区。</p>\n<p><strong>典型的网络IO系统调用流程</strong>，如图：</p>\n<p><img src=\"https://tvax1.sinaimg.cn/large/006YzKDNly1gous8df2kgj30h0096mxz.jpg\" alt=\"image\"></p>\n<p>如果是在Java服务器端，完成一次socket请求和响应，完整的流程如下：</p>\n<ul>\n<li>客户端请求：Linux通过网卡读取客户端的请求数据，将数据读取到内核缓冲区。</li>\n<li>获取请求数据：Java服务器通过read系统调用，从Linux内核缓冲区读取数据，再送入Java进程缓冲区。</li>\n<li>服务器端业务处理：Java服务器在自己的用户空间中处理客户端的请求。</li>\n<li>服务器端返回数据：Java服务器完成处理后，构建好的响应数据，将这些数据从用户缓冲区写入内核缓冲区。这里用到的是write系统调用。</li>\n<li>发送给客户端：Linux内核通过网络IO，将内核缓冲区中的数据写入网卡，网卡通过底层的通信协议，会将数据发送给目标客户端。</li>\n</ul>\n<h3 id=\"二、四种主要的IO模型\"><a href=\"#二、四种主要的IO模型\" class=\"headerlink\" title=\"二、四种主要的IO模型\"></a>二、四种主要的IO模型</h3><blockquote>\n<p><strong>阻塞与非阻塞</strong>：阻塞IO，指的是需要内核IO操作彻底完成后，才返回到用户空间执行用户的操作。阻塞指的是用户空间程序的执行状态。</p>\n<p><strong>同步与异步</strong>：同步IO是指用户空间的线程是主动发起IO请求的一方，内核空间是被动接受方。异步IO则反过来，是指系统内核是主动发起IO请求的一方（通知或回调），用户空间的线程是被动接受方。</p>\n</blockquote>\n<h4 id=\"1-同步阻塞IO（Blocking-IO）\"><a href=\"#1-同步阻塞IO（Blocking-IO）\" class=\"headerlink\" title=\"1. 同步阻塞IO（Blocking IO）\"></a>1. 同步阻塞IO（Blocking IO）</h4><p>​        在Java中，默认创建的socket都是同步阻塞的。在阻塞式IO模型中，Java应用程序<strong>从IO系统调用开始，直到系统调用返回</strong>，在这段时间内，Java进程是<strong>阻塞</strong>的。返回成功后，应用进程开始处理用户空间的缓存区数据。</p>\n<p><strong>同步阻塞IO流程</strong>，如图：</p>\n<p><img src=\"https://tvax1.sinaimg.cn/large/006YzKDNly1gov1uvelijj30i30bbgph.jpg\" alt=\"image\"></p>\n<ul>\n<li><p>阻塞IO特点：在内核进行IO执行的两个阶段（等待数据和复制数据），用户线程都被阻塞了。</p>\n</li>\n<li><p>阻塞IO优点：应用的程序开发非常简单；在阻塞等待数据期间，用户线程挂起，基本不会占用CPU资源。</p>\n</li>\n<li><p>阻塞IO缺点：一般情况下，会为每个连接配备一个独立的线程；反过来说，就是一个线程维护一个连接的IO操作。在并发量小的情况下，这样做没有什么问题。但是，当在高并发的应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。因此，基本上阻塞IO模型在高并发应用场景下是不可用的。</p>\n</li>\n</ul>\n<h4 id=\"2-同步非阻塞IO（Non-blocking-IO）\"><a href=\"#2-同步非阻塞IO（Non-blocking-IO）\" class=\"headerlink\" title=\"2. 同步非阻塞IO（Non-blocking IO）\"></a>2. 同步非阻塞IO（Non-blocking IO）</h4><blockquote>\n<p>这里的NIO并非Java的NIO（New IO），Java的NIO，对应的不是四种基础IO模型中的NIO（None Blocking IO）模型，而是另外的一种模型，叫作IO多路复用模型（IO Multiplexing）。</p>\n</blockquote>\n<p>​        在NIO模型中，应用程序一旦开始IO系统调用，会出现以下两种情况：</p>\n<p>​        1. 在内核缓冲区中<strong>没有数据</strong>的情况下，系统调用会立即返回，返回一个调用失败的信息。</p>\n<p>​        2. 在内核缓冲区中<strong>有数据</strong>的情况下，是<strong>阻塞</strong>的，直到数据从内核缓冲复制到用户进程缓冲。复制完成后，系统调用返回成功，应用进程开始处理用户空间的缓存数据。</p>\n<p><strong>同步非阻塞IO流程</strong>，如图<em>(图源公众号“码农翻身”，侵删)</em>：</p>\n<p><img src=\"https://tva4.sinaimg.cn/large/006YzKDNgy1goxfc4wvqoj30ll0fmgmt.jpg\" alt=\"image\"></p>\n<ul>\n<li><p>同步非阻塞IO<strong>特点</strong>：应用程序的线程需要不断地进行IO系统调用，轮询数据是否已经准备好，如果没有准备好，就继续<strong>轮询</strong>，直到完成IO系统调用为止。一般不单独使用，在其他模型中应用。</p>\n</li>\n<li><p>同步非阻塞IO<strong>优点</strong>：每次发起的IO系统调用，在内核等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。</p>\n</li>\n<li><p>同步非阻塞IO<strong>缺点</strong>：不断地轮询内核，这将占用大量的CPU时间，效率低下。</p>\n</li>\n</ul>\n<h4 id=\"3-IO多路复用（IO-Multiplexing）\"><a href=\"#3-IO多路复用（IO-Multiplexing）\" class=\"headerlink\" title=\"3. IO多路复用（IO Multiplexing）\"></a>3. IO多路复用（IO Multiplexing）</h4><blockquote>\n<p>解决同步非阻塞IO模型中轮询等待的问题</p>\n</blockquote>\n<p>​        在IO多路复用模型中，引入了一种新的系统调用，查询IO的就绪状态。在Linux系统中，对应的系统调用为select/epoll系统调用。通过该系统调用，单个应用程序的线程，可以不断地轮询成百上千的socket连接，一旦某个socket就绪（一般是内核缓冲区可读/可写），内核能够将就绪的状态返回给应用程序。随后，应用程序根据就绪的状态，进行相应的IO系统调用。</p>\n<p><strong>IO多路复用模型流程</strong>，如图：</p>\n<p><img src=\"https://tvax3.sinaimg.cn/large/006YzKDNly1gov3zz1xp6j30h80bhdkc.jpg\" alt=\"image\"></p>\n<ul>\n<li>IO多路复用模型<strong>特点</strong>：涉及两种系统调用（SystemCall），一种是select/epoll（就绪查询），一种是IO操作。要使用IO多路复用模型，操作系统必须支持提供多路分离的系统调用select/epoll。负责select/epoll状态查询调用的线程，需要不断地进行select/epoll轮询，查找出达到IO操作就绪的socket连接。对于注册在选择器（Java中对应的选择器类是Selector类）上的<strong>每一个可以查询的socket连接</strong>，一般都设置成为<strong>同步非阻塞模型</strong>。</li>\n<li>IO多路复用模型<strong>优点</strong>：一个选择器查询线程可以同时处理成千上万个连接（Connection）。系统不必创建和维护大量线程，减小系统开销。<em>Java的NIO（New IO）技术和Netty框架，使用的就是IO多路复用模型。在Linux系统上，使用的是epoll系统调用。</em></li>\n<li>IO多路复用模型<strong>缺点</strong>：本质上，select/epoll系统调用是阻塞式的，属于同步IO。都需要在读写事件就绪后，由系统调用本身负责进行读写，也就是说这个读写过程是阻塞的。</li>\n</ul>\n<h5 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select:\"></a>select:</h5><p>​        select可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理<em>(图源公众号“码农翻身”，侵删)</em>：</p>\n<p><img src=\"https://tva2.sinaimg.cn/large/006YzKDNgy1goxgnhkba8g30fa0b4x6p.gif\" alt=\"20210326180007\"></p>\n<ol>\n<li>首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。</li>\n<li>然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。</li>\n<li>不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。</li>\n</ol>\n<p>可以看出几个问题：</p>\n<p>​    1. select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>\n<p>​    2. select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>\n<p>​    3. select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>\n<h5 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll:\"></a>epoll:</h5><p>​        解决了 select 的上述问题:</p>\n<ol>\n<li><p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</p>\n</li>\n<li><p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p>\n</li>\n<li><p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p>\n<p>原理如图<em>(图源公众号“码农翻身”，侵删)</em>：</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNgy1goxh0qffnzg30fa0b4e81.gif\" alt=\"20210326181258\"></p>\n<p><strong>多路复用快的原因</strong>：操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。</p>\n</li>\n</ol>\n<h4 id=\"4-异步IO（Asynchronous-IO）\"><a href=\"#4-异步IO（Asynchronous-IO）\" class=\"headerlink\" title=\"4. 异步IO（Asynchronous IO）\"></a>4. 异步IO（Asynchronous IO）</h4><blockquote>\n<p>彻底解除线程的阻塞</p>\n</blockquote>\n<p>​        对于异步IO，当用户线程发起read系统调用后，立刻就可以做其他的事，不阻塞。内核开始准备数据，并复制数据到用户缓冲区。复制完成后，内核会给用户线程发送一个信号（Signal），或者回调用户线程注册的回调接口，告诉用户线程read操作完成了。</p>\n<p><strong>异步IO模型流程</strong>，如图：</p>\n<p><img src=\"https://tvax3.sinaimg.cn/large/006YzKDNly1gov4h3y1m6j30go0c2q7m.jpg\" alt=\"image\"></p>\n<ul>\n<li>异步IO模型<strong>特点</strong>：在内核等待数据和复制数据的<strong>两个阶段，用户线程都不阻塞</strong>。用户线程需要接收内核的IO操作完成的事件，或者用户线程需要注册一个IO操作完成的回调函数。正因为如此，异步IO有的时候也被称为信号驱动IO。</li>\n<li>异步IO模型缺点：应用程序仅需要进行事件的注册与接收，其余的工作都留给了操作系统，也就是说，需要底层内核提供支持。</li>\n</ul>\n<blockquote>\n<p>​        就目前而言，Windows系统下通过IOCP实现了真正的异步IO。而在Linux系统下，异步IO模型在2.6版本才引入，目前并不完善，其底层实现仍使用epoll，与IO多路复用相同，因此在性能上没有明显的优势。大多数高并发服务器端程序，都是基于Linux系统的。因而，<strong>目前这类高并发网络应用程序的开发，大多采用IO多路复用模型。</strong></p>\n</blockquote>\n<h3 id=\"三、系统配置最大句柄\"><a href=\"#三、系统配置最大句柄\" class=\"headerlink\" title=\"三、系统配置最大句柄\"></a>三、系统配置最大句柄</h3><blockquote>\n<p>在生产环境Linux系统中，基本上都需要解除文件句柄数的限制。因为Linux的系统默认值为1024，也就是说，一个进程最多可以接受1024个socket连接。</p>\n</blockquote>\n<h4 id=\"文件句柄\"><a href=\"#文件句柄\" class=\"headerlink\" title=\"文件句柄\"></a>文件句柄</h4><p>​        也叫文件描述符，在Linux系统中，文件可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（File Descriptor）是内核为了高效管理已被打开的文件所创建的索引，它是一个非负整数（通常是小整数），用于指代被打开的文件。所有的IO系统调用，包括socket的读写调用，都是通过文件描述符完成的。在Linux下，可以通过<code>ulimit -n</code>看到单个进程能够打开的最大文件句柄数量。Linux的系统默认值为1024。</p>\n<p>​        对于高并发的应用，面临的并发连接数往往是十万级、百万级、千万级、甚至像腾讯QQ一样的上亿级。当单个进程打开的文件句柄数量，超过了系统配置上限值时，会发出“Socket/File:Can’t open so many files”的错误提示。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>​        可以通过<code>ulimit -n 1000000</code>修改句柄数（最大值是1048576 ），但是ulimit命令仅对当前用户有效，如果想永久保存配置，可以编辑/etc/rc.local开机启动文件，添加如下内容：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ulimit -SHn <span class=\"number\">1000000</span></span><br></pre></td></tr></table></figure>\n\n<p>​        增加-S和-H两个命令选项。选项-S表示软性极限值，-H表示硬性极限值。硬性极限（需要root权限）是实际的限制，就是最大可以是100万，不能再多了。软性极限是系统警告（Warning）的极限值，超过这个极限值，内核会发出警告。</p>\n<p>​        终极解除Linux系统的最大文件打开数量的限制，可以编辑/etc/security/limits.conf，添加如下内容：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">soft nofile <span class=\"number\">1000000</span></span><br><span class=\"line\">hard nofile <span class=\"number\">1000000</span></span><br></pre></td></tr></table></figure>\n\n<p>soft nofile表示软性极限，hard nofile表示硬性极限。不可以设置unlimited。</p>\n"},{"title":"Java NIO通信基础","header-img":"/img/header_img/squirrel.jpg","catalog":true,"top":null,"abbrlink":"57bd","date":"2021-03-31T10:45:33.000Z","subtitle":null,"_content":"\n## Java NIO通信基础\n\n### 一、NIO简介\n\n> 在1.4版本之前，Java IO类库是阻塞IO；从1.4版本开始，为了支持非阻塞IO，引进了新的异步IO库，被称为Java New IO类库，简称为JAVA NIO。Java NIO属于 IO多路复用模型。\n\n**NIO和OIO（old IO）的区别：**\n\n- OIO面向流（Stream Oriented），NIO面向缓冲区（BufferOriented）\n- OIO的操作是阻塞的，NIO是非阻塞的。\n- OIO没有选择器（Selector）概念，NIO的选择器，需要底层操作系统提供支持。\n\nJava NIO由以下三个核心组件组成：· Channel（通道）· Buffer（缓冲区）· Selector（选择器）\n\n#### 1. 通道（Channel）\n\n​\t\t在OIO中，同一个网络连接会通过输入流（Input Stream）和输出流（Output Stream）不断地进行输入和输出的操作。在NIO中，同一个网络连接使用一个通道表示，所有的NIO的IO操作都是从通道开始的。一个通道类似于OIO中的两个流的结合体，既可以从通道读取，也可以向通道写入。\n\n#### 2. 选择器（Selector）\n\n> IO多路复用指的是一个进程/线程可以同时监视多个文件描述符（一个网络连接，操作系统底层使用一个文件描述符来表示），一旦其中的一个或者多个文件描述符可读或者可写，系统内核就通知该进程/线程。\n\n​\t\t通过选择器，一个线程可以查询多个通道的IO事件的就绪状态，即监视多个文件描述符。具体的开发层面来说，首先把通道注册到选择器中，然后通过选择器内部的机制，可以查询（select）这些注册的通道是否有已经就绪的IO事件（例如可读、可写、网络连接完成等）。一个选择器只需要一个线程进行监控，系统不必为每一个网络连接（文件描述符）创建进程/线程，从而大大减小了系统的开销。\n\n#### 3. 缓冲区（Buffer）\n\n​\t\t应用程序与通道（Channel）主要的交互操作，就是进行数据的read读取和write写入。通道的读取，就是将数据从通道读取到缓冲区中；通道的写入，就是将数据从缓冲区中写入到通道中。\n\n### 二、Buffer类及其属性\n\n> Buffer（缓冲区）本质上是一个内存块（数组），既可以写入数据，也可以从中读取数据。\n\n#### Buffer类\n\n​\t\tBuffer类是一个抽象类，位于java.nio包中，线程不安全。在NIO中有8种缓冲区类：ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer、MappedByteBuffer，其中MappedByteBuffer是专门用于内存映射的一种ByteBuffer类型。使用最多的是ByteBuffer。\n\n#### Buffer类的重要属性\n\n​\t\t为了记录读写的状态和位置，Buffer类提供了一些重要的属性：capacity（容量）、position（读写位置）、limit（读写的限制）、mark（标记）。\n\n![image](https://tvax2.sinaimg.cn/large/006YzKDNly1gp33iz38e4j30kk05pt9v.jpg)\n\n#### Buffer类的重要方法\n\n1. **allocate()创建缓冲区**\n\n    ​\t\t为了获取一个Buffer实例对象，并不是使用子类的构造器new来创建一个实例对象，而是调用子类的allocate()方法，并分配内存空间（capacity）。\n\n    ```java\n    IntBuffer intBuffer = intBuffer.allocate(10);\n    ```\n\n2. **put()写入到缓冲区**\n\n    ```java\n    intBuffer.put(1);\n    ```\n\n3. **flip()翻转**\n\n    ​\t\t向缓冲区写入数据之后，不能直接从缓冲区中读取数据，需要使用flip()将写入模式翻转成读取模式。flip()方法源码如下：\n\n    ```java\n     public final Buffer flip() {\n         limit = position;\n         position = 0;\n         mark = -1;\n         return this;\n     }\n    ```\n\n    容量为10的intBuffer，在写入1个数据时，position=1，limit=10，capacity=10；在写完翻转后，position=0，limit=1，capacity=10；\n\n    > 读取完成后，如何再一次将缓冲区切换成写入模式呢？可以调用Buffer.clear()清空或者Buffer.compact()压缩方法，它们可以将缓冲区转换为写模式。\n\n    缓冲区读写模式的转换如图：\n\n    ![image](https://tvax1.sinaimg.cn/large/006YzKDNly1gp34tey3npj30g1071aay.jpg)\n\n4. **clear()清空**\n\n    ​\t\t清空缓冲区但不清除数据，数据将“被遗忘”，缓冲区切换为写入模式。源码如下：\n\n    ```java\n    public final Buffer clear() {\n        position = 0;\n        limit = capacity;\n        mark = -1;\n    \treturn this;\n    }\n    ```\n\n5. **compact()压缩**\n\n    ​\t\t不覆盖未读的数据，将所有未读的数据拷贝到Buffer起始处，然后将position设到最后一个未读元素后面，limit设置为capacity，缓冲区切换为写入模式。源码如下：\n\n    ```java\n    public ByteBuffer compact() {\n        System.arraycopy(hb, ix(position()), hb, ix(0), remaining()); // 拷贝未读数据\n        position(remaining()); // remaining()返回limit - position\n        limit(capacity()); // limit设置为capacity\n        discardMark(); // mark = -1\n        return this;\n    }\n    ```\n\n6. **get()从缓冲区读取**\n\n    ​\t\t翻转后可读，读操作会改变可读位置position的值，而limit值不会改变。如果position==limit，表示所有数据读取完成，position指向了一个没有数据的元素位置，此时再读，会抛出BufferUnderflowException异常。\n\n    ```java\n    byteBuffer.get();\n    ```\n\n7. **rewind()倒带**\n\n    ​\t\t已读完的数据，如果需要再读一遍，可以调用rewind()方法。rewind()也叫倒带。源码如下：\n\n    ```java\n    public final Buffer rewind() {\n        position = 0; // 重置\n        mark = -1; // 清理标记\n        return this;\n    }\n    ```\n\n    > rewind()和flip()区别在于：rewind()不会影响limit；而flip()会重设limit属性值。\n\n8.  **mark( )和reset( )**\n\n    ​\t\tBuffer.mark()和Buffer.reset()方法是配套使用的，比如读到第3个元素（i= =2时），调用mark()方法，把当前位置position的值保存到mark属性中，这时mark属性的值为2。接下来，就可以调用reset方法，将mark属性的值恢复到position中。然后可以从位置2（第三个元素）开始读。\n\n**Buffer类的基本使用步骤**：\n\n```java\nIntBuffer intBuffer = intBuffer.allocate(10);\nintBuffer.put(1);\nintBuffer.flip();\nintBuffer.get();\nintBuffer.clear();||intBuffer.compact();\n```\n\n### 二、Channel类及其属性\n\n> NIO中一个连接用一个Channel（通道）来表示，一个通道可以表示一个底层的文件描述符，例如硬件设备、文件、网络连接等。对于不同的网络传输协议类型，在Java中都有不同的NIO Channel（通道）实现。\n\n#### Channel（通道）的主要类型\n\n1. FileChannel文件通道，用于文件的数据读写。\n\n2. SocketChannel套接字通道，用于Socket套接字TCP连接的数据读写。\n\n3. ServerSocketChannel服务器嵌套字通道（或服务器监听通道），允许我们监听TCP连接请求，为每个监听到的请求，创建一个SocketChannel套接字通道。\n\n4. DatagramChannel数据报通道，用于UDP协议的数据读写。\n\n#### FileChannel的使用\n\n> 通过FileChannel，既可以从一个文件中读取数据，也可以将数据写入到文件中。FileChannel为**阻塞模式**，不能设置为非阻塞模式。\n\n1. **获取FileChannel通道**\n\n- 通过文件输入输出流获取：\n\n    ```java\n    // 创建文件输入流\n    FileInputStream fis = new FileInputStream(srcFile);\n    // 获取文件流的通道\n    FileChannel inChannel = fis.getChannel();\n    \n    // 创建文件输出流\n    FileOutputStream fos = new FileOutputStream(destFile);\n    // 获取文件流的通道\n    FileChannel outChannel = fis.getChannel();\n    ```\n\n- 通过RandomAccessFile类获取：\n\n    ```java\n    // 创建RandomAccessFile随机访问对象\n    RandomAccessFile rafile = new RandomAccessFile(srcFile, \"rw\");\n    // 获取文件流的通道\n    FileChannel raFileChannel = rafile.getChannel();\n    ```\n\n2. **读取FileChannel通道**\n\n    ​\t\t调用`public abstract int read(ByteBuffer src) throws IOException`方法读取通道数据，写入ByteBuffer缓冲区，并返回数据。**虽然对于通道来说是读取数据，但是对于ByteBuffer缓冲区来说是写入数据，这时，ByteBuffer缓冲区处于写入模式。**\n\n    ```java\n    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n    int length = -1;\n    while (-1 != (length = raFileChannel.read(byteBuffer))) {\n    // TODO\n    }\n    ```\n\n3. **写入FileChannel通道**\n\n    ​\t\t调用`public abstract int write(ByteBuffer src) throws IOException`方法读取缓冲区数据写入通道，并返回写入的字节数。**对于ByteBuffer缓冲区来说是读入数据，对通道来说是写入。**\n\n    ```java\n    // 刚写完要翻转成读取模式\n    byteBuffer.flip();\n    int outlength = 0;\n    while (0 != (outlength = raFileChannel.write(byteBuffer))) {\n    \tSystem.out.println(\"写入字节数：\" + outlength);\n    }\n    ```\n\n4. **关闭通道**\n\n    ```java\n    inChannel.close();\n    ```\n\n5. **强制刷新到磁盘**\n\n    ​\t\t在将缓冲区写入通道时，出于性能原因，操作系统不可能每次都实时将数据写入磁盘。如果需要保证写入通道的缓冲数据，最终都真正地写入磁盘，可以调用FileChannel的force()方法。\n\n    ```java\n    inChannel.force(true);\n    ```\n\n#### SocketChannel和ServerSocketChannel的使用\n\n> 在NIO中，涉及网络连接的通道有两个，一个是SocketChannel负责连接传输，另一个是ServerSocketChannel负责连接的监听。都**支持阻塞和非阻塞两种模式**。ServerSocketChannel应用于服务器端，而SocketChannel同时处于服务器端和客户端。对于一个连接，两端都有一个负责传输的SocketChannel传输通道。SocketChannel与OIO中的Socket类对应，ServerSocketChannel与OIO中的ServerSocket类对应。\n\n1. **获取SocketChannel传输通道**\n\n    ​\t\t在**客户端**，先通过SocketChannel静态方法open()获得一个套接字传输通道；然后，将socket套接字设置为非阻塞模式；最后，通过connect()实例方法，对服务器的IP和端口发起连接。\n\n    ```java\n    // 获取通道\n    SocketChannel socketChannel = SocketChannel.open();\n    // 设置为非阻塞\n    socketChannel.configureBlocking(false);\n    // 对服务器的IP和端口发起连接\n    socketChannel.connect(new InetSocketAddress(InetAddress.getLocalHost(),5252));\n    ```\n\n    ​\t\t非阻塞情况下，与服务器的连接可能还没有真正建立，socketChannel.connect方法就返回了，因此需要不断地自旋，检查当前是否连接到了主机：\n\n    ```java\n    // 不断自旋，等待连接完成\n    while (!socketChannel.finishConnect()) {\n    }\n    ```\n\n    ​\t\t在**服务器端**，当新连接事件到来时，ServerSocketChannel能成功地查询，通过accept()方法，来获取新连接的套接字通道：\n\n    ```java\n    // 新连接事件到来,通过事件（后面会讲到key）获取服务器监听通道\n    ServerSocketChannel serverSocketChannel = （ServerSocketChannel）key.channel();\n    // 获取新连接的套接字通道\n    SocketChannel socketChannel = serverSocketChannel.accept();\n    // 切换为非阻塞模式\n    socketChannel.configureBlocking(false);\n    ```\n\n2. **读取SocketChannel传输通道**\n\n    ​\t\t与FileChannel一样\n\n3. **写入SocketChannel传输通道**\n\n    ​\t\t与FileChannel一样\n\n4. **关闭SocketChannel传输通道**\n\n    ​\t\t在关闭SocketChannel传输通道前，如果传输通道用来写入数据，则建议调用一次shutdownOutput()终止输出方法，向对方发送一个输出的结束标志（-1）。然后调用socketChannel.close()方法，关闭套接字连接。\n\n    ```\n    // 终止输出方法，向对方发送一个输出的结束标志\n    socketChannel.shutdownOutput();\n    // 关闭套接字连接\n    socketChannel.close();\n    ```\n\n#### DatagramChannel的使用\n\n> DatagramChannel数据报通道用来处理UDP协议的数据传输。和Socket套接字的TCP传输协议不同，UDP协议不是面向连接的协议。使用UDP协议时，只要知道服务器的IP和端口，就可以直接向对方发送数据。\n\n1. **获取DatagramChannel传输通道**\n\n    ​\t\t调用DatagramChannel静态方法open()获得通道，然后设置为非阻塞模式，绑定数据报的监听端口：\n\n    ```java\n    // 获取通道\n    DatagramChannel datagramChannel = DatagramChannel.open();\n    // 设置为非阻塞\n    datagramChannel.configureBlocking(false);\t\t\n    // 绑定监听IP和端口\n    datagramChannel.socket().bind(new InetSocketAddress(InetAddress.getLocalHost(),5252));\n    ```\n\n2. **读取DatagramChannel传输通道**\n\n    ​\t\t不是调用read方法，而是调用receive：\n\n    ```java\n    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n    SocketAddress clientAddr = datagramChannel.receive(byteBuffer);\n    ```\n\n    ​\t\t通道读取receive（ByteBuffer buf）方法的返回值，是SocketAddress类型，表示返回发送端的连接地址（包括IP和端口）。\n\n3. **写入DatagramChannel传输通道**\n\n    ​\t\t不是调用write方法，而是调用send方法，由于UDP是面向非连接的协议，因此，在发送数据的时候，需要指定接收方的地址：\n\n    ```java\n    byteBuffer.flip();\n    datagramChannel.send(byteBuffer, new InetSocketAddress(InetAddress.getLocalHost(),5252));\n    byteBuffer.clear();\n    ```\n\n4. **关闭DatagramChannel传输通道**\n\n    ​\t\t与FileChannel一样，close()即可。\n\n### 三、Select类及其属性\n\n> 非阻塞模式下，如何知道SocketChannel和DatagramChannel通道何时是可读的呢？这时就需要用到NIO的新组件——Selector通道选择器\n>\n> 简单地说：**选择器的使命是完成IO的多路复用**。一个通道代表一条连接，通过选择器可以同时监控多个通道的IO（输入输出）状况。选择器和通道的关系，是监控和被监控的关系。\n\n#### Selector 选择器及注册\n\n​\t\t通道和选择器之间的关系，通过`Channel.register（Selector sel, int ops）`方法完成，需要传入待注册的选择器实例和待监控事件类型。\n\n可供选择器监控的**通道IO事件类型**（就绪状态），包括以下四种：\n\n1. 可读：SelectionKey.OP_READ\n2. 可写：SelectionKey.OP_WRITE\n3. 连接：SelectionKey.OP_CONNECT\n4. 接收：SelectionKey.OP_ACCEPT\n\n事件类型的定义在SelectionKey类中。如果选择器要监控通道的多种事件，可以用“按位或”运算符来实现。例如，同时监控可读和可写IO事件：\n\n```java\nint key = SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n```\n\n#### SelectableChannel(可选择通道)\n\n​\t\t一条通道若能被选择，必须继承SelectableChannel类。所有网络链接Socket套接字通道，都继承了SelectableChannel类，都是可选择的。而FileChannel文件通道，并没有继承SelectableChannel，因此不是可选择通道。\n\n#### SelectionKey(选择键)\n\n​\t\t一旦在通道中发生了某些IO事件（就绪状态达成），并且在选择器中注册过，就会被选择器选中，并放入SelectionKey的集合中。SelectionKey可以获得通道的IO事件类型，比方说SelectionKey.OP_READ，还可以获得发生IO事件所在的通道及选择器实例。\n\n#### 选择器的使用\n\n1. **获取选择器实例**\n\n    ​\t\t通过调用静态工厂方法open()来获取：\n\n    ```java\n    Selector selector = Selector.open();\n    ```\n\n    *open()的内部，是向选择器SPI（SelectorProvider）发出请求，通过默认的SPI对象，获取一个新的选择器实例。SPI全称为（Service Provider Interface，服务提供者接口），是JDK的一种可以扩展的服务提供和发现机制。Java通过SPI的方式，提供选择器的默认实现版本。也就是说，其他的服务提供商可以通过SPI的方式，提供定制化版本的选择器的动态替换或者扩展。*\n\n2. **将通道注册到选择器中**\n\n    ​\t\t需要注意：注册到选择器的通道，必须处于非阻塞模式下，否则将抛出IllegalBlockingModeException异常。并且一个通道，并不一定支持所有的四种IO事件。例如服务器监听通道ServerSocketChannel，仅支持Accept（接收到新连接）IO事件；而SocketChannel传输通道，则不支持Accept（接收到新连接）IO事件。可以在注册之前，通过通道的validOps()方法，来获取该通道所有支持的IO事件集合。\n\n    ```java\n    // 获取通道\n    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n    // 设置为非阻塞\n    serverSocketChannel.configureBlocking(false);\n    // 绑定连接\n    serverSocketChannel.bind(new InetSocketAddress(5252));\n    System.out.println(\"服务器启动成功\");\n    // 将通道注册的“接收新连接”IO事件注册到选择器上\n    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n    ```\n\n3. **选出感兴趣的IO就绪事件（选择键集合）**\n\n    ```java\n    // 轮询感兴趣的IO就绪事件（选择键集合）\n    while (selector.select() > 0) {\n        // 获取选择键集合\n        Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();\n        while (selectedKeys.hasNext()) {\n            // 获取单个的选择键并处理\n            SelectionKey selectedKey = selectedKeys.next();\n            if (selectedKey.isAcceptable()) {\n         \t\t// 通道有新连接\n            } else if (selectedKey.isConnectalbe()) {\n                // 通道连接成功\n            }  else if (selectedKey.isReadalbe()) {\n                // 通道可读\n            }  else if (selectedKey.isWritalbe()) {\n                // 通道可写\n            }\n            // 处理完后移除选择键\n            selectedKeys.remove();\n        }\n    }\n    ```\n\n    SelectionKey集合不能添加元素，如果试图向SelectionKey选择键集合中添加元素，则将抛出java.lang.UnsupportedOperationException异常。\n\n    select()方法有三个重载的实现版本，具体如下：\n\n    1. select()：阻塞调用，一直到至少有一个通道发生了注册的IO事件。\n    2. select(long timeout)：和select()一样，但最长阻塞时间为timeout指定的毫秒数。\n    3. selectNow()：非阻塞，不管有没有IO事件，都会立刻返回。\n\n    select()方法返回的整数值，表示从上一次select到这一次select之间，有多少**通道**发生了注册的IO事件。强调一下，select()方法返回的数量，指的是通道数，而不是IO事件数。\n\n#### 实践案例\n\n使用NIO实现Discard服务器，Discard服务器的功能很简单，读取客户端通道的输入数据，读取完成后直接关闭客户端通道；并且读取到的数据直接抛弃掉。\n\n**服务器端：**\n\n```java\n/**\n * 使用NIO实现Discard服务器端功能：\n *      仅读取客户端通道的输入数据，读取完成后直接关闭客户端通道，并且读取到的数据直接抛弃掉。\n */\npublic class NioDiscardServer {\n    public static void startServer() throws IOException {\n\n        // 获取选择器\n        Selector selector = Selector.open();\n        // 获取通道\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        // 设置为非阻塞\n        serverSocketChannel.configureBlocking(false);\n        // 绑定连接\n        serverSocketChannel.bind(new InetSocketAddress(5252));\n        System.out.println(\"服务器启动成功\");\n        // 将通道注册的“接收新连接”IO事件注册到选择器上\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        // 轮询感兴趣的IO就绪事件（选择键集合）\n        while (selector.select() > 0) {\n            // 获取选择键集合\n            Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();\n            while (selectedKeys.hasNext()) {\n                // 获取单个的选择键并处理\n                SelectionKey selectedKey = selectedKeys.next();\n                if (selectedKey.isAcceptable()) {\n                    // 若选择键的IO事件是“连接就绪”，就获取客户端连接\n                    SocketChannel socketChannel = serverSocketChannel.accept();\n                    // 切换为非阻塞模式\n                    socketChannel.configureBlocking(false);\n                    // 将新连接的通道可读事件注册到选择器上\n                    socketChannel.register(selector, SelectionKey.OP_READ);\n                } else if (selectedKey.isReadable()) {\n                    // 若选择键的IO事件是“可读”，就读取数据\n                    SocketChannel socketChannel = (SocketChannel) selectedKey.channel();\n                    // 读取数据，然后丢弃\n                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                    int length = 0;\n                    // 调用通道的read方法，从通道读取数据写入缓冲区，并返回读取到的数据\n                    while ((length = socketChannel.read(byteBuffer)) > 0) {\n                        byteBuffer.flip();\n                        System.out.println(new String(byteBuffer.array(), 0, length));\n                        byteBuffer.clear();\n                    }\n                    socketChannel.close();\n                }\n                // 移除选择键\n                selectedKeys.remove();\n            }\n        }\n        // 关闭连接\n        serverSocketChannel.close();\n    }\n}\n```\n\n**客户端：**\n\n```java\n/**\n * 使用NIO实现Discard客户端功能：\n *      客户端首先建立到服务器的连接，发送一些简单的数据，然后直接关闭连接。\n */\npublic class NioDiscardClient {\n\n    public static void startClient() throws IOException {\n        InetSocketAddress address = new InetSocketAddress(InetAddress.getLocalHost(),5252);\n        // 获取通道\n        SocketChannel socketChannel = SocketChannel.open(address);\n        // 设置为非阻塞\n        socketChannel.configureBlocking(false);\n        // 不断自旋，等待连接完成\n        while (!socketChannel.finishConnect()) {\n        }\n        System.out.println(\"客户端连接成功\");\n        // 分配指定大小的缓冲区\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        byteBuffer.put(\"hello nio\".getBytes());\n        byteBuffer.flip();\n        // 发送到服务器\n        socketChannel.write(byteBuffer);\n        // 终止输出方法，向对方发送一个输出的结束标志\n        socketChannel.shutdownOutput();\n        // 关闭套接字连接\n        socketChannel.close();\n    }\n}\n```\n\n**测试：**\n\n​\t\t先启动服务器，等到控制台出现“服务器启动成功”，再启动客户端，客户端连接成功后，发现服务器端出现“hello nio”则成功：\n\n服务器端：\n\n```\n服务器启动成功\n```\n\n客户端：\n\n```\n客户端连接成功\n```\n\n服务器端：\n\n```\n服务器启动成功\nhello nio\n```\n\n\n\n","source":"_posts/java-nio.md","raw":"---\ntitle: Java NIO通信基础\nheader-img: /img/header_img/squirrel.jpg\ncatalog: true\ntop:\ntags:\n  - IO\ncategories:\n  - work\nabbrlink: 57bd\ndate: 2021-03-31 18:45:33\nsubtitle:\n---\n\n## Java NIO通信基础\n\n### 一、NIO简介\n\n> 在1.4版本之前，Java IO类库是阻塞IO；从1.4版本开始，为了支持非阻塞IO，引进了新的异步IO库，被称为Java New IO类库，简称为JAVA NIO。Java NIO属于 IO多路复用模型。\n\n**NIO和OIO（old IO）的区别：**\n\n- OIO面向流（Stream Oriented），NIO面向缓冲区（BufferOriented）\n- OIO的操作是阻塞的，NIO是非阻塞的。\n- OIO没有选择器（Selector）概念，NIO的选择器，需要底层操作系统提供支持。\n\nJava NIO由以下三个核心组件组成：· Channel（通道）· Buffer（缓冲区）· Selector（选择器）\n\n#### 1. 通道（Channel）\n\n​\t\t在OIO中，同一个网络连接会通过输入流（Input Stream）和输出流（Output Stream）不断地进行输入和输出的操作。在NIO中，同一个网络连接使用一个通道表示，所有的NIO的IO操作都是从通道开始的。一个通道类似于OIO中的两个流的结合体，既可以从通道读取，也可以向通道写入。\n\n#### 2. 选择器（Selector）\n\n> IO多路复用指的是一个进程/线程可以同时监视多个文件描述符（一个网络连接，操作系统底层使用一个文件描述符来表示），一旦其中的一个或者多个文件描述符可读或者可写，系统内核就通知该进程/线程。\n\n​\t\t通过选择器，一个线程可以查询多个通道的IO事件的就绪状态，即监视多个文件描述符。具体的开发层面来说，首先把通道注册到选择器中，然后通过选择器内部的机制，可以查询（select）这些注册的通道是否有已经就绪的IO事件（例如可读、可写、网络连接完成等）。一个选择器只需要一个线程进行监控，系统不必为每一个网络连接（文件描述符）创建进程/线程，从而大大减小了系统的开销。\n\n#### 3. 缓冲区（Buffer）\n\n​\t\t应用程序与通道（Channel）主要的交互操作，就是进行数据的read读取和write写入。通道的读取，就是将数据从通道读取到缓冲区中；通道的写入，就是将数据从缓冲区中写入到通道中。\n\n### 二、Buffer类及其属性\n\n> Buffer（缓冲区）本质上是一个内存块（数组），既可以写入数据，也可以从中读取数据。\n\n#### Buffer类\n\n​\t\tBuffer类是一个抽象类，位于java.nio包中，线程不安全。在NIO中有8种缓冲区类：ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer、MappedByteBuffer，其中MappedByteBuffer是专门用于内存映射的一种ByteBuffer类型。使用最多的是ByteBuffer。\n\n#### Buffer类的重要属性\n\n​\t\t为了记录读写的状态和位置，Buffer类提供了一些重要的属性：capacity（容量）、position（读写位置）、limit（读写的限制）、mark（标记）。\n\n![image](https://tvax2.sinaimg.cn/large/006YzKDNly1gp33iz38e4j30kk05pt9v.jpg)\n\n#### Buffer类的重要方法\n\n1. **allocate()创建缓冲区**\n\n    ​\t\t为了获取一个Buffer实例对象，并不是使用子类的构造器new来创建一个实例对象，而是调用子类的allocate()方法，并分配内存空间（capacity）。\n\n    ```java\n    IntBuffer intBuffer = intBuffer.allocate(10);\n    ```\n\n2. **put()写入到缓冲区**\n\n    ```java\n    intBuffer.put(1);\n    ```\n\n3. **flip()翻转**\n\n    ​\t\t向缓冲区写入数据之后，不能直接从缓冲区中读取数据，需要使用flip()将写入模式翻转成读取模式。flip()方法源码如下：\n\n    ```java\n     public final Buffer flip() {\n         limit = position;\n         position = 0;\n         mark = -1;\n         return this;\n     }\n    ```\n\n    容量为10的intBuffer，在写入1个数据时，position=1，limit=10，capacity=10；在写完翻转后，position=0，limit=1，capacity=10；\n\n    > 读取完成后，如何再一次将缓冲区切换成写入模式呢？可以调用Buffer.clear()清空或者Buffer.compact()压缩方法，它们可以将缓冲区转换为写模式。\n\n    缓冲区读写模式的转换如图：\n\n    ![image](https://tvax1.sinaimg.cn/large/006YzKDNly1gp34tey3npj30g1071aay.jpg)\n\n4. **clear()清空**\n\n    ​\t\t清空缓冲区但不清除数据，数据将“被遗忘”，缓冲区切换为写入模式。源码如下：\n\n    ```java\n    public final Buffer clear() {\n        position = 0;\n        limit = capacity;\n        mark = -1;\n    \treturn this;\n    }\n    ```\n\n5. **compact()压缩**\n\n    ​\t\t不覆盖未读的数据，将所有未读的数据拷贝到Buffer起始处，然后将position设到最后一个未读元素后面，limit设置为capacity，缓冲区切换为写入模式。源码如下：\n\n    ```java\n    public ByteBuffer compact() {\n        System.arraycopy(hb, ix(position()), hb, ix(0), remaining()); // 拷贝未读数据\n        position(remaining()); // remaining()返回limit - position\n        limit(capacity()); // limit设置为capacity\n        discardMark(); // mark = -1\n        return this;\n    }\n    ```\n\n6. **get()从缓冲区读取**\n\n    ​\t\t翻转后可读，读操作会改变可读位置position的值，而limit值不会改变。如果position==limit，表示所有数据读取完成，position指向了一个没有数据的元素位置，此时再读，会抛出BufferUnderflowException异常。\n\n    ```java\n    byteBuffer.get();\n    ```\n\n7. **rewind()倒带**\n\n    ​\t\t已读完的数据，如果需要再读一遍，可以调用rewind()方法。rewind()也叫倒带。源码如下：\n\n    ```java\n    public final Buffer rewind() {\n        position = 0; // 重置\n        mark = -1; // 清理标记\n        return this;\n    }\n    ```\n\n    > rewind()和flip()区别在于：rewind()不会影响limit；而flip()会重设limit属性值。\n\n8.  **mark( )和reset( )**\n\n    ​\t\tBuffer.mark()和Buffer.reset()方法是配套使用的，比如读到第3个元素（i= =2时），调用mark()方法，把当前位置position的值保存到mark属性中，这时mark属性的值为2。接下来，就可以调用reset方法，将mark属性的值恢复到position中。然后可以从位置2（第三个元素）开始读。\n\n**Buffer类的基本使用步骤**：\n\n```java\nIntBuffer intBuffer = intBuffer.allocate(10);\nintBuffer.put(1);\nintBuffer.flip();\nintBuffer.get();\nintBuffer.clear();||intBuffer.compact();\n```\n\n### 二、Channel类及其属性\n\n> NIO中一个连接用一个Channel（通道）来表示，一个通道可以表示一个底层的文件描述符，例如硬件设备、文件、网络连接等。对于不同的网络传输协议类型，在Java中都有不同的NIO Channel（通道）实现。\n\n#### Channel（通道）的主要类型\n\n1. FileChannel文件通道，用于文件的数据读写。\n\n2. SocketChannel套接字通道，用于Socket套接字TCP连接的数据读写。\n\n3. ServerSocketChannel服务器嵌套字通道（或服务器监听通道），允许我们监听TCP连接请求，为每个监听到的请求，创建一个SocketChannel套接字通道。\n\n4. DatagramChannel数据报通道，用于UDP协议的数据读写。\n\n#### FileChannel的使用\n\n> 通过FileChannel，既可以从一个文件中读取数据，也可以将数据写入到文件中。FileChannel为**阻塞模式**，不能设置为非阻塞模式。\n\n1. **获取FileChannel通道**\n\n- 通过文件输入输出流获取：\n\n    ```java\n    // 创建文件输入流\n    FileInputStream fis = new FileInputStream(srcFile);\n    // 获取文件流的通道\n    FileChannel inChannel = fis.getChannel();\n    \n    // 创建文件输出流\n    FileOutputStream fos = new FileOutputStream(destFile);\n    // 获取文件流的通道\n    FileChannel outChannel = fis.getChannel();\n    ```\n\n- 通过RandomAccessFile类获取：\n\n    ```java\n    // 创建RandomAccessFile随机访问对象\n    RandomAccessFile rafile = new RandomAccessFile(srcFile, \"rw\");\n    // 获取文件流的通道\n    FileChannel raFileChannel = rafile.getChannel();\n    ```\n\n2. **读取FileChannel通道**\n\n    ​\t\t调用`public abstract int read(ByteBuffer src) throws IOException`方法读取通道数据，写入ByteBuffer缓冲区，并返回数据。**虽然对于通道来说是读取数据，但是对于ByteBuffer缓冲区来说是写入数据，这时，ByteBuffer缓冲区处于写入模式。**\n\n    ```java\n    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n    int length = -1;\n    while (-1 != (length = raFileChannel.read(byteBuffer))) {\n    // TODO\n    }\n    ```\n\n3. **写入FileChannel通道**\n\n    ​\t\t调用`public abstract int write(ByteBuffer src) throws IOException`方法读取缓冲区数据写入通道，并返回写入的字节数。**对于ByteBuffer缓冲区来说是读入数据，对通道来说是写入。**\n\n    ```java\n    // 刚写完要翻转成读取模式\n    byteBuffer.flip();\n    int outlength = 0;\n    while (0 != (outlength = raFileChannel.write(byteBuffer))) {\n    \tSystem.out.println(\"写入字节数：\" + outlength);\n    }\n    ```\n\n4. **关闭通道**\n\n    ```java\n    inChannel.close();\n    ```\n\n5. **强制刷新到磁盘**\n\n    ​\t\t在将缓冲区写入通道时，出于性能原因，操作系统不可能每次都实时将数据写入磁盘。如果需要保证写入通道的缓冲数据，最终都真正地写入磁盘，可以调用FileChannel的force()方法。\n\n    ```java\n    inChannel.force(true);\n    ```\n\n#### SocketChannel和ServerSocketChannel的使用\n\n> 在NIO中，涉及网络连接的通道有两个，一个是SocketChannel负责连接传输，另一个是ServerSocketChannel负责连接的监听。都**支持阻塞和非阻塞两种模式**。ServerSocketChannel应用于服务器端，而SocketChannel同时处于服务器端和客户端。对于一个连接，两端都有一个负责传输的SocketChannel传输通道。SocketChannel与OIO中的Socket类对应，ServerSocketChannel与OIO中的ServerSocket类对应。\n\n1. **获取SocketChannel传输通道**\n\n    ​\t\t在**客户端**，先通过SocketChannel静态方法open()获得一个套接字传输通道；然后，将socket套接字设置为非阻塞模式；最后，通过connect()实例方法，对服务器的IP和端口发起连接。\n\n    ```java\n    // 获取通道\n    SocketChannel socketChannel = SocketChannel.open();\n    // 设置为非阻塞\n    socketChannel.configureBlocking(false);\n    // 对服务器的IP和端口发起连接\n    socketChannel.connect(new InetSocketAddress(InetAddress.getLocalHost(),5252));\n    ```\n\n    ​\t\t非阻塞情况下，与服务器的连接可能还没有真正建立，socketChannel.connect方法就返回了，因此需要不断地自旋，检查当前是否连接到了主机：\n\n    ```java\n    // 不断自旋，等待连接完成\n    while (!socketChannel.finishConnect()) {\n    }\n    ```\n\n    ​\t\t在**服务器端**，当新连接事件到来时，ServerSocketChannel能成功地查询，通过accept()方法，来获取新连接的套接字通道：\n\n    ```java\n    // 新连接事件到来,通过事件（后面会讲到key）获取服务器监听通道\n    ServerSocketChannel serverSocketChannel = （ServerSocketChannel）key.channel();\n    // 获取新连接的套接字通道\n    SocketChannel socketChannel = serverSocketChannel.accept();\n    // 切换为非阻塞模式\n    socketChannel.configureBlocking(false);\n    ```\n\n2. **读取SocketChannel传输通道**\n\n    ​\t\t与FileChannel一样\n\n3. **写入SocketChannel传输通道**\n\n    ​\t\t与FileChannel一样\n\n4. **关闭SocketChannel传输通道**\n\n    ​\t\t在关闭SocketChannel传输通道前，如果传输通道用来写入数据，则建议调用一次shutdownOutput()终止输出方法，向对方发送一个输出的结束标志（-1）。然后调用socketChannel.close()方法，关闭套接字连接。\n\n    ```\n    // 终止输出方法，向对方发送一个输出的结束标志\n    socketChannel.shutdownOutput();\n    // 关闭套接字连接\n    socketChannel.close();\n    ```\n\n#### DatagramChannel的使用\n\n> DatagramChannel数据报通道用来处理UDP协议的数据传输。和Socket套接字的TCP传输协议不同，UDP协议不是面向连接的协议。使用UDP协议时，只要知道服务器的IP和端口，就可以直接向对方发送数据。\n\n1. **获取DatagramChannel传输通道**\n\n    ​\t\t调用DatagramChannel静态方法open()获得通道，然后设置为非阻塞模式，绑定数据报的监听端口：\n\n    ```java\n    // 获取通道\n    DatagramChannel datagramChannel = DatagramChannel.open();\n    // 设置为非阻塞\n    datagramChannel.configureBlocking(false);\t\t\n    // 绑定监听IP和端口\n    datagramChannel.socket().bind(new InetSocketAddress(InetAddress.getLocalHost(),5252));\n    ```\n\n2. **读取DatagramChannel传输通道**\n\n    ​\t\t不是调用read方法，而是调用receive：\n\n    ```java\n    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n    SocketAddress clientAddr = datagramChannel.receive(byteBuffer);\n    ```\n\n    ​\t\t通道读取receive（ByteBuffer buf）方法的返回值，是SocketAddress类型，表示返回发送端的连接地址（包括IP和端口）。\n\n3. **写入DatagramChannel传输通道**\n\n    ​\t\t不是调用write方法，而是调用send方法，由于UDP是面向非连接的协议，因此，在发送数据的时候，需要指定接收方的地址：\n\n    ```java\n    byteBuffer.flip();\n    datagramChannel.send(byteBuffer, new InetSocketAddress(InetAddress.getLocalHost(),5252));\n    byteBuffer.clear();\n    ```\n\n4. **关闭DatagramChannel传输通道**\n\n    ​\t\t与FileChannel一样，close()即可。\n\n### 三、Select类及其属性\n\n> 非阻塞模式下，如何知道SocketChannel和DatagramChannel通道何时是可读的呢？这时就需要用到NIO的新组件——Selector通道选择器\n>\n> 简单地说：**选择器的使命是完成IO的多路复用**。一个通道代表一条连接，通过选择器可以同时监控多个通道的IO（输入输出）状况。选择器和通道的关系，是监控和被监控的关系。\n\n#### Selector 选择器及注册\n\n​\t\t通道和选择器之间的关系，通过`Channel.register（Selector sel, int ops）`方法完成，需要传入待注册的选择器实例和待监控事件类型。\n\n可供选择器监控的**通道IO事件类型**（就绪状态），包括以下四种：\n\n1. 可读：SelectionKey.OP_READ\n2. 可写：SelectionKey.OP_WRITE\n3. 连接：SelectionKey.OP_CONNECT\n4. 接收：SelectionKey.OP_ACCEPT\n\n事件类型的定义在SelectionKey类中。如果选择器要监控通道的多种事件，可以用“按位或”运算符来实现。例如，同时监控可读和可写IO事件：\n\n```java\nint key = SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n```\n\n#### SelectableChannel(可选择通道)\n\n​\t\t一条通道若能被选择，必须继承SelectableChannel类。所有网络链接Socket套接字通道，都继承了SelectableChannel类，都是可选择的。而FileChannel文件通道，并没有继承SelectableChannel，因此不是可选择通道。\n\n#### SelectionKey(选择键)\n\n​\t\t一旦在通道中发生了某些IO事件（就绪状态达成），并且在选择器中注册过，就会被选择器选中，并放入SelectionKey的集合中。SelectionKey可以获得通道的IO事件类型，比方说SelectionKey.OP_READ，还可以获得发生IO事件所在的通道及选择器实例。\n\n#### 选择器的使用\n\n1. **获取选择器实例**\n\n    ​\t\t通过调用静态工厂方法open()来获取：\n\n    ```java\n    Selector selector = Selector.open();\n    ```\n\n    *open()的内部，是向选择器SPI（SelectorProvider）发出请求，通过默认的SPI对象，获取一个新的选择器实例。SPI全称为（Service Provider Interface，服务提供者接口），是JDK的一种可以扩展的服务提供和发现机制。Java通过SPI的方式，提供选择器的默认实现版本。也就是说，其他的服务提供商可以通过SPI的方式，提供定制化版本的选择器的动态替换或者扩展。*\n\n2. **将通道注册到选择器中**\n\n    ​\t\t需要注意：注册到选择器的通道，必须处于非阻塞模式下，否则将抛出IllegalBlockingModeException异常。并且一个通道，并不一定支持所有的四种IO事件。例如服务器监听通道ServerSocketChannel，仅支持Accept（接收到新连接）IO事件；而SocketChannel传输通道，则不支持Accept（接收到新连接）IO事件。可以在注册之前，通过通道的validOps()方法，来获取该通道所有支持的IO事件集合。\n\n    ```java\n    // 获取通道\n    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n    // 设置为非阻塞\n    serverSocketChannel.configureBlocking(false);\n    // 绑定连接\n    serverSocketChannel.bind(new InetSocketAddress(5252));\n    System.out.println(\"服务器启动成功\");\n    // 将通道注册的“接收新连接”IO事件注册到选择器上\n    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n    ```\n\n3. **选出感兴趣的IO就绪事件（选择键集合）**\n\n    ```java\n    // 轮询感兴趣的IO就绪事件（选择键集合）\n    while (selector.select() > 0) {\n        // 获取选择键集合\n        Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();\n        while (selectedKeys.hasNext()) {\n            // 获取单个的选择键并处理\n            SelectionKey selectedKey = selectedKeys.next();\n            if (selectedKey.isAcceptable()) {\n         \t\t// 通道有新连接\n            } else if (selectedKey.isConnectalbe()) {\n                // 通道连接成功\n            }  else if (selectedKey.isReadalbe()) {\n                // 通道可读\n            }  else if (selectedKey.isWritalbe()) {\n                // 通道可写\n            }\n            // 处理完后移除选择键\n            selectedKeys.remove();\n        }\n    }\n    ```\n\n    SelectionKey集合不能添加元素，如果试图向SelectionKey选择键集合中添加元素，则将抛出java.lang.UnsupportedOperationException异常。\n\n    select()方法有三个重载的实现版本，具体如下：\n\n    1. select()：阻塞调用，一直到至少有一个通道发生了注册的IO事件。\n    2. select(long timeout)：和select()一样，但最长阻塞时间为timeout指定的毫秒数。\n    3. selectNow()：非阻塞，不管有没有IO事件，都会立刻返回。\n\n    select()方法返回的整数值，表示从上一次select到这一次select之间，有多少**通道**发生了注册的IO事件。强调一下，select()方法返回的数量，指的是通道数，而不是IO事件数。\n\n#### 实践案例\n\n使用NIO实现Discard服务器，Discard服务器的功能很简单，读取客户端通道的输入数据，读取完成后直接关闭客户端通道；并且读取到的数据直接抛弃掉。\n\n**服务器端：**\n\n```java\n/**\n * 使用NIO实现Discard服务器端功能：\n *      仅读取客户端通道的输入数据，读取完成后直接关闭客户端通道，并且读取到的数据直接抛弃掉。\n */\npublic class NioDiscardServer {\n    public static void startServer() throws IOException {\n\n        // 获取选择器\n        Selector selector = Selector.open();\n        // 获取通道\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        // 设置为非阻塞\n        serverSocketChannel.configureBlocking(false);\n        // 绑定连接\n        serverSocketChannel.bind(new InetSocketAddress(5252));\n        System.out.println(\"服务器启动成功\");\n        // 将通道注册的“接收新连接”IO事件注册到选择器上\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        // 轮询感兴趣的IO就绪事件（选择键集合）\n        while (selector.select() > 0) {\n            // 获取选择键集合\n            Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();\n            while (selectedKeys.hasNext()) {\n                // 获取单个的选择键并处理\n                SelectionKey selectedKey = selectedKeys.next();\n                if (selectedKey.isAcceptable()) {\n                    // 若选择键的IO事件是“连接就绪”，就获取客户端连接\n                    SocketChannel socketChannel = serverSocketChannel.accept();\n                    // 切换为非阻塞模式\n                    socketChannel.configureBlocking(false);\n                    // 将新连接的通道可读事件注册到选择器上\n                    socketChannel.register(selector, SelectionKey.OP_READ);\n                } else if (selectedKey.isReadable()) {\n                    // 若选择键的IO事件是“可读”，就读取数据\n                    SocketChannel socketChannel = (SocketChannel) selectedKey.channel();\n                    // 读取数据，然后丢弃\n                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                    int length = 0;\n                    // 调用通道的read方法，从通道读取数据写入缓冲区，并返回读取到的数据\n                    while ((length = socketChannel.read(byteBuffer)) > 0) {\n                        byteBuffer.flip();\n                        System.out.println(new String(byteBuffer.array(), 0, length));\n                        byteBuffer.clear();\n                    }\n                    socketChannel.close();\n                }\n                // 移除选择键\n                selectedKeys.remove();\n            }\n        }\n        // 关闭连接\n        serverSocketChannel.close();\n    }\n}\n```\n\n**客户端：**\n\n```java\n/**\n * 使用NIO实现Discard客户端功能：\n *      客户端首先建立到服务器的连接，发送一些简单的数据，然后直接关闭连接。\n */\npublic class NioDiscardClient {\n\n    public static void startClient() throws IOException {\n        InetSocketAddress address = new InetSocketAddress(InetAddress.getLocalHost(),5252);\n        // 获取通道\n        SocketChannel socketChannel = SocketChannel.open(address);\n        // 设置为非阻塞\n        socketChannel.configureBlocking(false);\n        // 不断自旋，等待连接完成\n        while (!socketChannel.finishConnect()) {\n        }\n        System.out.println(\"客户端连接成功\");\n        // 分配指定大小的缓冲区\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        byteBuffer.put(\"hello nio\".getBytes());\n        byteBuffer.flip();\n        // 发送到服务器\n        socketChannel.write(byteBuffer);\n        // 终止输出方法，向对方发送一个输出的结束标志\n        socketChannel.shutdownOutput();\n        // 关闭套接字连接\n        socketChannel.close();\n    }\n}\n```\n\n**测试：**\n\n​\t\t先启动服务器，等到控制台出现“服务器启动成功”，再启动客户端，客户端连接成功后，发现服务器端出现“hello nio”则成功：\n\n服务器端：\n\n```\n服务器启动成功\n```\n\n客户端：\n\n```\n客户端连接成功\n```\n\n服务器端：\n\n```\n服务器启动成功\nhello nio\n```\n\n\n\n","slug":"java-nio","published":1,"updated":"2021-12-10T09:05:27.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1ay000nacbf7nyoexnk","content":"<h2 id=\"Java-NIO通信基础\"><a href=\"#Java-NIO通信基础\" class=\"headerlink\" title=\"Java NIO通信基础\"></a>Java NIO通信基础</h2><h3 id=\"一、NIO简介\"><a href=\"#一、NIO简介\" class=\"headerlink\" title=\"一、NIO简介\"></a>一、NIO简介</h3><blockquote>\n<p>在1.4版本之前，Java IO类库是阻塞IO；从1.4版本开始，为了支持非阻塞IO，引进了新的异步IO库，被称为Java New IO类库，简称为JAVA NIO。Java NIO属于 IO多路复用模型。</p>\n</blockquote>\n<p><strong>NIO和OIO（old IO）的区别：</strong></p>\n<ul>\n<li>OIO面向流（Stream Oriented），NIO面向缓冲区（BufferOriented）</li>\n<li>OIO的操作是阻塞的，NIO是非阻塞的。</li>\n<li>OIO没有选择器（Selector）概念，NIO的选择器，需要底层操作系统提供支持。</li>\n</ul>\n<p>Java NIO由以下三个核心组件组成：· Channel（通道）· Buffer（缓冲区）· Selector（选择器）</p>\n<h4 id=\"1-通道（Channel）\"><a href=\"#1-通道（Channel）\" class=\"headerlink\" title=\"1. 通道（Channel）\"></a>1. 通道（Channel）</h4><p>​        在OIO中，同一个网络连接会通过输入流（Input Stream）和输出流（Output Stream）不断地进行输入和输出的操作。在NIO中，同一个网络连接使用一个通道表示，所有的NIO的IO操作都是从通道开始的。一个通道类似于OIO中的两个流的结合体，既可以从通道读取，也可以向通道写入。</p>\n<h4 id=\"2-选择器（Selector）\"><a href=\"#2-选择器（Selector）\" class=\"headerlink\" title=\"2. 选择器（Selector）\"></a>2. 选择器（Selector）</h4><blockquote>\n<p>IO多路复用指的是一个进程/线程可以同时监视多个文件描述符（一个网络连接，操作系统底层使用一个文件描述符来表示），一旦其中的一个或者多个文件描述符可读或者可写，系统内核就通知该进程/线程。</p>\n</blockquote>\n<p>​        通过选择器，一个线程可以查询多个通道的IO事件的就绪状态，即监视多个文件描述符。具体的开发层面来说，首先把通道注册到选择器中，然后通过选择器内部的机制，可以查询（select）这些注册的通道是否有已经就绪的IO事件（例如可读、可写、网络连接完成等）。一个选择器只需要一个线程进行监控，系统不必为每一个网络连接（文件描述符）创建进程/线程，从而大大减小了系统的开销。</p>\n<h4 id=\"3-缓冲区（Buffer）\"><a href=\"#3-缓冲区（Buffer）\" class=\"headerlink\" title=\"3. 缓冲区（Buffer）\"></a>3. 缓冲区（Buffer）</h4><p>​        应用程序与通道（Channel）主要的交互操作，就是进行数据的read读取和write写入。通道的读取，就是将数据从通道读取到缓冲区中；通道的写入，就是将数据从缓冲区中写入到通道中。</p>\n<h3 id=\"二、Buffer类及其属性\"><a href=\"#二、Buffer类及其属性\" class=\"headerlink\" title=\"二、Buffer类及其属性\"></a>二、Buffer类及其属性</h3><blockquote>\n<p>Buffer（缓冲区）本质上是一个内存块（数组），既可以写入数据，也可以从中读取数据。</p>\n</blockquote>\n<h4 id=\"Buffer类\"><a href=\"#Buffer类\" class=\"headerlink\" title=\"Buffer类\"></a>Buffer类</h4><p>​        Buffer类是一个抽象类，位于java.nio包中，线程不安全。在NIO中有8种缓冲区类：ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer、MappedByteBuffer，其中MappedByteBuffer是专门用于内存映射的一种ByteBuffer类型。使用最多的是ByteBuffer。</p>\n<h4 id=\"Buffer类的重要属性\"><a href=\"#Buffer类的重要属性\" class=\"headerlink\" title=\"Buffer类的重要属性\"></a>Buffer类的重要属性</h4><p>​        为了记录读写的状态和位置，Buffer类提供了一些重要的属性：capacity（容量）、position（读写位置）、limit（读写的限制）、mark（标记）。</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gp33iz38e4j30kk05pt9v.jpg\" alt=\"image\"></p>\n<h4 id=\"Buffer类的重要方法\"><a href=\"#Buffer类的重要方法\" class=\"headerlink\" title=\"Buffer类的重要方法\"></a>Buffer类的重要方法</h4><ol>\n<li><p><strong>allocate()创建缓冲区</strong></p>\n<p> ​        为了获取一个Buffer实例对象，并不是使用子类的构造器new来创建一个实例对象，而是调用子类的allocate()方法，并分配内存空间（capacity）。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntBuffer intBuffer = intBuffer.allocate(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>put()写入到缓冲区</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intBuffer.put(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>flip()翻转</strong></p>\n<p> ​        向缓冲区写入数据之后，不能直接从缓冲区中读取数据，需要使用flip()将写入模式翻转成读取模式。flip()方法源码如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">flip</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    limit = position;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>;</span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 容量为10的intBuffer，在写入1个数据时，position=1，limit=10，capacity=10；在写完翻转后，position=0，limit=1，capacity=10；</p>\n<blockquote>\n<p>读取完成后，如何再一次将缓冲区切换成写入模式呢？可以调用Buffer.clear()清空或者Buffer.compact()压缩方法，它们可以将缓冲区转换为写模式。</p>\n</blockquote>\n<p> 缓冲区读写模式的转换如图：</p>\n<p> <img src=\"https://tvax1.sinaimg.cn/large/006YzKDNly1gp34tey3npj30g1071aay.jpg\" alt=\"image\"></p>\n</li>\n<li><p><strong>clear()清空</strong></p>\n<p> ​        清空缓冲区但不清除数据，数据将“被遗忘”，缓冲区切换为写入模式。源码如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>;</span><br><span class=\"line\">    limit = capacity;</span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>compact()压缩</strong></p>\n<p> ​        不覆盖未读的数据，将所有未读的数据拷贝到Buffer起始处，然后将position设到最后一个未读元素后面，limit设置为capacity，缓冲区切换为写入模式。源码如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ByteBuffer <span class=\"title\">compact</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.arraycopy(hb, ix(position()), hb, ix(<span class=\"number\">0</span>), remaining()); <span class=\"comment\">// 拷贝未读数据</span></span><br><span class=\"line\">    position(remaining()); <span class=\"comment\">// remaining()返回limit - position</span></span><br><span class=\"line\">    limit(capacity()); <span class=\"comment\">// limit设置为capacity</span></span><br><span class=\"line\">    discardMark(); <span class=\"comment\">// mark = -1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>get()从缓冲区读取</strong></p>\n<p> ​        翻转后可读，读操作会改变可读位置position的值，而limit值不会改变。如果position==limit，表示所有数据读取完成，position指向了一个没有数据的元素位置，此时再读，会抛出BufferUnderflowException异常。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byteBuffer.get();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>rewind()倒带</strong></p>\n<p> ​        已读完的数据，如果需要再读一遍，可以调用rewind()方法。rewind()也叫倒带。源码如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">rewind</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>; <span class=\"comment\">// 重置</span></span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>; <span class=\"comment\">// 清理标记</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>rewind()和flip()区别在于：rewind()不会影响limit；而flip()会重设limit属性值。</p>\n</blockquote>\n</li>\n<li><p><strong>mark( )和reset( )</strong></p>\n<p>​        Buffer.mark()和Buffer.reset()方法是配套使用的，比如读到第3个元素（i= =2时），调用mark()方法，把当前位置position的值保存到mark属性中，这时mark属性的值为2。接下来，就可以调用reset方法，将mark属性的值恢复到position中。然后可以从位置2（第三个元素）开始读。</p>\n</li>\n</ol>\n<p><strong>Buffer类的基本使用步骤</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntBuffer intBuffer = intBuffer.allocate(<span class=\"number\">10</span>);</span><br><span class=\"line\">intBuffer.put(<span class=\"number\">1</span>);</span><br><span class=\"line\">intBuffer.flip();</span><br><span class=\"line\">intBuffer.get();</span><br><span class=\"line\">intBuffer.clear();||intBuffer.compact();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、Channel类及其属性\"><a href=\"#二、Channel类及其属性\" class=\"headerlink\" title=\"二、Channel类及其属性\"></a>二、Channel类及其属性</h3><blockquote>\n<p>NIO中一个连接用一个Channel（通道）来表示，一个通道可以表示一个底层的文件描述符，例如硬件设备、文件、网络连接等。对于不同的网络传输协议类型，在Java中都有不同的NIO Channel（通道）实现。</p>\n</blockquote>\n<h4 id=\"Channel（通道）的主要类型\"><a href=\"#Channel（通道）的主要类型\" class=\"headerlink\" title=\"Channel（通道）的主要类型\"></a>Channel（通道）的主要类型</h4><ol>\n<li><p>FileChannel文件通道，用于文件的数据读写。</p>\n</li>\n<li><p>SocketChannel套接字通道，用于Socket套接字TCP连接的数据读写。</p>\n</li>\n<li><p>ServerSocketChannel服务器嵌套字通道（或服务器监听通道），允许我们监听TCP连接请求，为每个监听到的请求，创建一个SocketChannel套接字通道。</p>\n</li>\n<li><p>DatagramChannel数据报通道，用于UDP协议的数据读写。</p>\n</li>\n</ol>\n<h4 id=\"FileChannel的使用\"><a href=\"#FileChannel的使用\" class=\"headerlink\" title=\"FileChannel的使用\"></a>FileChannel的使用</h4><blockquote>\n<p>通过FileChannel，既可以从一个文件中读取数据，也可以将数据写入到文件中。FileChannel为<strong>阻塞模式</strong>，不能设置为非阻塞模式。</p>\n</blockquote>\n<ol>\n<li><strong>获取FileChannel通道</strong></li>\n</ol>\n<ul>\n<li><p>通过文件输入输出流获取：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建文件输入流</span></span><br><span class=\"line\">FileInputStream fis = <span class=\"keyword\">new</span> FileInputStream(srcFile);</span><br><span class=\"line\"><span class=\"comment\">// 获取文件流的通道</span></span><br><span class=\"line\">FileChannel inChannel = fis.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建文件输出流</span></span><br><span class=\"line\">FileOutputStream fos = <span class=\"keyword\">new</span> FileOutputStream(destFile);</span><br><span class=\"line\"><span class=\"comment\">// 获取文件流的通道</span></span><br><span class=\"line\">FileChannel outChannel = fis.getChannel();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过RandomAccessFile类获取：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建RandomAccessFile随机访问对象</span></span><br><span class=\"line\">RandomAccessFile rafile = <span class=\"keyword\">new</span> RandomAccessFile(srcFile, <span class=\"string\">\"rw\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 获取文件流的通道</span></span><br><span class=\"line\">FileChannel raFileChannel = rafile.getChannel();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p><strong>读取FileChannel通道</strong></p>\n<p> ​        调用<code>public abstract int read(ByteBuffer src) throws IOException</code>方法读取通道数据，写入ByteBuffer缓冲区，并返回数据。<strong>虽然对于通道来说是读取数据，但是对于ByteBuffer缓冲区来说是写入数据，这时，ByteBuffer缓冲区处于写入模式。</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> length = -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (-<span class=\"number\">1</span> != (length = raFileChannel.read(byteBuffer))) &#123;</span><br><span class=\"line\"><span class=\"comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>写入FileChannel通道</strong></p>\n<p> ​        调用<code>public abstract int write(ByteBuffer src) throws IOException</code>方法读取缓冲区数据写入通道，并返回写入的字节数。<strong>对于ByteBuffer缓冲区来说是读入数据，对通道来说是写入。</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 刚写完要翻转成读取模式</span></span><br><span class=\"line\">byteBuffer.flip();</span><br><span class=\"line\"><span class=\"keyword\">int</span> outlength = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"number\">0</span> != (outlength = raFileChannel.write(byteBuffer))) &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"写入字节数：\"</span> + outlength);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>关闭通道</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inChannel.close();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>强制刷新到磁盘</strong></p>\n<p> ​        在将缓冲区写入通道时，出于性能原因，操作系统不可能每次都实时将数据写入磁盘。如果需要保证写入通道的缓冲数据，最终都真正地写入磁盘，可以调用FileChannel的force()方法。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inChannel.force(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"SocketChannel和ServerSocketChannel的使用\"><a href=\"#SocketChannel和ServerSocketChannel的使用\" class=\"headerlink\" title=\"SocketChannel和ServerSocketChannel的使用\"></a>SocketChannel和ServerSocketChannel的使用</h4><blockquote>\n<p>在NIO中，涉及网络连接的通道有两个，一个是SocketChannel负责连接传输，另一个是ServerSocketChannel负责连接的监听。都<strong>支持阻塞和非阻塞两种模式</strong>。ServerSocketChannel应用于服务器端，而SocketChannel同时处于服务器端和客户端。对于一个连接，两端都有一个负责传输的SocketChannel传输通道。SocketChannel与OIO中的Socket类对应，ServerSocketChannel与OIO中的ServerSocket类对应。</p>\n</blockquote>\n<ol>\n<li><p><strong>获取SocketChannel传输通道</strong></p>\n<p> ​        在<strong>客户端</strong>，先通过SocketChannel静态方法open()获得一个套接字传输通道；然后，将socket套接字设置为非阻塞模式；最后，通过connect()实例方法，对服务器的IP和端口发起连接。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">SocketChannel socketChannel = SocketChannel.open();</span><br><span class=\"line\"><span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 对服务器的IP和端口发起连接</span></span><br><span class=\"line\">socketChannel.connect(<span class=\"keyword\">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class=\"number\">5252</span>));</span><br></pre></td></tr></table></figure>\n\n<p> ​        非阻塞情况下，与服务器的连接可能还没有真正建立，socketChannel.connect方法就返回了，因此需要不断地自旋，检查当前是否连接到了主机：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不断自旋，等待连接完成</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (!socketChannel.finishConnect()) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> ​        在<strong>服务器端</strong>，当新连接事件到来时，ServerSocketChannel能成功地查询，通过accept()方法，来获取新连接的套接字通道：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新连接事件到来,通过事件（后面会讲到key）获取服务器监听通道</span></span><br><span class=\"line\">ServerSocketChannel serverSocketChannel = （ServerSocketChannel）key.channel();</span><br><span class=\"line\"><span class=\"comment\">// 获取新连接的套接字通道</span></span><br><span class=\"line\">SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class=\"line\"><span class=\"comment\">// 切换为非阻塞模式</span></span><br><span class=\"line\">socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>读取SocketChannel传输通道</strong></p>\n<p> ​        与FileChannel一样</p>\n</li>\n<li><p><strong>写入SocketChannel传输通道</strong></p>\n<p> ​        与FileChannel一样</p>\n</li>\n<li><p><strong>关闭SocketChannel传输通道</strong></p>\n<p> ​        在关闭SocketChannel传输通道前，如果传输通道用来写入数据，则建议调用一次shutdownOutput()终止输出方法，向对方发送一个输出的结束标志（-1）。然后调用socketChannel.close()方法，关闭套接字连接。</p>\n <figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 终止输出方法，向对方发送一个输出的结束标志</span></span><br><span class=\"line\"><span class=\"selector-tag\">socketChannel</span><span class=\"selector-class\">.shutdownOutput</span>();</span><br><span class=\"line\"><span class=\"comment\">// 关闭套接字连接</span></span><br><span class=\"line\"><span class=\"selector-tag\">socketChannel</span><span class=\"selector-class\">.close</span>();</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"DatagramChannel的使用\"><a href=\"#DatagramChannel的使用\" class=\"headerlink\" title=\"DatagramChannel的使用\"></a>DatagramChannel的使用</h4><blockquote>\n<p>DatagramChannel数据报通道用来处理UDP协议的数据传输。和Socket套接字的TCP传输协议不同，UDP协议不是面向连接的协议。使用UDP协议时，只要知道服务器的IP和端口，就可以直接向对方发送数据。</p>\n</blockquote>\n<ol>\n<li><p><strong>获取DatagramChannel传输通道</strong></p>\n<p> ​        调用DatagramChannel静态方法open()获得通道，然后设置为非阻塞模式，绑定数据报的监听端口：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class=\"line\"><span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">datagramChannel.configureBlocking(<span class=\"keyword\">false</span>);\t\t</span><br><span class=\"line\"><span class=\"comment\">// 绑定监听IP和端口</span></span><br><span class=\"line\">datagramChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class=\"number\">5252</span>));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>读取DatagramChannel传输通道</strong></p>\n<p> ​        不是调用read方法，而是调用receive：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">SocketAddress clientAddr = datagramChannel.receive(byteBuffer);</span><br></pre></td></tr></table></figure>\n\n<p> ​        通道读取receive（ByteBuffer buf）方法的返回值，是SocketAddress类型，表示返回发送端的连接地址（包括IP和端口）。</p>\n</li>\n<li><p><strong>写入DatagramChannel传输通道</strong></p>\n<p> ​        不是调用write方法，而是调用send方法，由于UDP是面向非连接的协议，因此，在发送数据的时候，需要指定接收方的地址：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byteBuffer.flip();</span><br><span class=\"line\">datagramChannel.send(byteBuffer, <span class=\"keyword\">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class=\"number\">5252</span>));</span><br><span class=\"line\">byteBuffer.clear();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>关闭DatagramChannel传输通道</strong></p>\n<p> ​        与FileChannel一样，close()即可。</p>\n</li>\n</ol>\n<h3 id=\"三、Select类及其属性\"><a href=\"#三、Select类及其属性\" class=\"headerlink\" title=\"三、Select类及其属性\"></a>三、Select类及其属性</h3><blockquote>\n<p>非阻塞模式下，如何知道SocketChannel和DatagramChannel通道何时是可读的呢？这时就需要用到NIO的新组件——Selector通道选择器</p>\n<p>简单地说：<strong>选择器的使命是完成IO的多路复用</strong>。一个通道代表一条连接，通过选择器可以同时监控多个通道的IO（输入输出）状况。选择器和通道的关系，是监控和被监控的关系。</p>\n</blockquote>\n<h4 id=\"Selector-选择器及注册\"><a href=\"#Selector-选择器及注册\" class=\"headerlink\" title=\"Selector 选择器及注册\"></a>Selector 选择器及注册</h4><p>​        通道和选择器之间的关系，通过<code>Channel.register（Selector sel, int ops）</code>方法完成，需要传入待注册的选择器实例和待监控事件类型。</p>\n<p>可供选择器监控的<strong>通道IO事件类型</strong>（就绪状态），包括以下四种：</p>\n<ol>\n<li>可读：SelectionKey.OP_READ</li>\n<li>可写：SelectionKey.OP_WRITE</li>\n<li>连接：SelectionKey.OP_CONNECT</li>\n<li>接收：SelectionKey.OP_ACCEPT</li>\n</ol>\n<p>事件类型的定义在SelectionKey类中。如果选择器要监控通道的多种事件，可以用“按位或”运算符来实现。例如，同时监控可读和可写IO事件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> key = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SelectableChannel-可选择通道\"><a href=\"#SelectableChannel-可选择通道\" class=\"headerlink\" title=\"SelectableChannel(可选择通道)\"></a>SelectableChannel(可选择通道)</h4><p>​        一条通道若能被选择，必须继承SelectableChannel类。所有网络链接Socket套接字通道，都继承了SelectableChannel类，都是可选择的。而FileChannel文件通道，并没有继承SelectableChannel，因此不是可选择通道。</p>\n<h4 id=\"SelectionKey-选择键\"><a href=\"#SelectionKey-选择键\" class=\"headerlink\" title=\"SelectionKey(选择键)\"></a>SelectionKey(选择键)</h4><p>​        一旦在通道中发生了某些IO事件（就绪状态达成），并且在选择器中注册过，就会被选择器选中，并放入SelectionKey的集合中。SelectionKey可以获得通道的IO事件类型，比方说SelectionKey.OP_READ，还可以获得发生IO事件所在的通道及选择器实例。</p>\n<h4 id=\"选择器的使用\"><a href=\"#选择器的使用\" class=\"headerlink\" title=\"选择器的使用\"></a>选择器的使用</h4><ol>\n<li><p><strong>获取选择器实例</strong></p>\n<p> ​        通过调用静态工厂方法open()来获取：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>\n\n<p> <em>open()的内部，是向选择器SPI（SelectorProvider）发出请求，通过默认的SPI对象，获取一个新的选择器实例。SPI全称为（Service Provider Interface，服务提供者接口），是JDK的一种可以扩展的服务提供和发现机制。Java通过SPI的方式，提供选择器的默认实现版本。也就是说，其他的服务提供商可以通过SPI的方式，提供定制化版本的选择器的动态替换或者扩展。</em></p>\n</li>\n<li><p><strong>将通道注册到选择器中</strong></p>\n<p> ​        需要注意：注册到选择器的通道，必须处于非阻塞模式下，否则将抛出IllegalBlockingModeException异常。并且一个通道，并不一定支持所有的四种IO事件。例如服务器监听通道ServerSocketChannel，仅支持Accept（接收到新连接）IO事件；而SocketChannel传输通道，则不支持Accept（接收到新连接）IO事件。可以在注册之前，通过通道的validOps()方法，来获取该通道所有支持的IO事件集合。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\"><span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 绑定连接</span></span><br><span class=\"line\">serverSocketChannel.bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">5252</span>));</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"服务器启动成功\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 将通道注册的“接收新连接”IO事件注册到选择器上</span></span><br><span class=\"line\">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>选出感兴趣的IO就绪事件（选择键集合）</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 轮询感兴趣的IO就绪事件（选择键集合）</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (selector.select() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取选择键集合</span></span><br><span class=\"line\">    Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (selectedKeys.hasNext()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取单个的选择键并处理</span></span><br><span class=\"line\">        SelectionKey selectedKey = selectedKeys.next();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedKey.isAcceptable()) &#123;</span><br><span class=\"line\">     \t\t<span class=\"comment\">// 通道有新连接</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isConnectalbe()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通道连接成功</span></span><br><span class=\"line\">        &#125;  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isReadalbe()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通道可读</span></span><br><span class=\"line\">        &#125;  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isWritalbe()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通道可写</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 处理完后移除选择键</span></span><br><span class=\"line\">        selectedKeys.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> SelectionKey集合不能添加元素，如果试图向SelectionKey选择键集合中添加元素，则将抛出java.lang.UnsupportedOperationException异常。</p>\n<p> select()方法有三个重载的实现版本，具体如下：</p>\n<ol>\n<li><p>select()：阻塞调用，一直到至少有一个通道发生了注册的IO事件。</p>\n</li>\n<li><p>select(long timeout)：和select()一样，但最长阻塞时间为timeout指定的毫秒数。</p>\n</li>\n<li><p>selectNow()：非阻塞，不管有没有IO事件，都会立刻返回。</p>\n<p>select()方法返回的整数值，表示从上一次select到这一次select之间，有多少<strong>通道</strong>发生了注册的IO事件。强调一下，select()方法返回的数量，指的是通道数，而不是IO事件数。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"实践案例\"><a href=\"#实践案例\" class=\"headerlink\" title=\"实践案例\"></a>实践案例</h4><p>使用NIO实现Discard服务器，Discard服务器的功能很简单，读取客户端通道的输入数据，读取完成后直接关闭客户端通道；并且读取到的数据直接抛弃掉。</p>\n<p><strong>服务器端：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用NIO实现Discard服务器端功能：</span></span><br><span class=\"line\"><span class=\"comment\"> *      仅读取客户端通道的输入数据，读取完成后直接关闭客户端通道，并且读取到的数据直接抛弃掉。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioDiscardServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startServer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取选择器</span></span><br><span class=\"line\">        Selector selector = Selector.open();</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\">        <span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">        serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 绑定连接</span></span><br><span class=\"line\">        serverSocketChannel.bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">5252</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"服务器启动成功\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 将通道注册的“接收新连接”IO事件注册到选择器上</span></span><br><span class=\"line\">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 轮询感兴趣的IO就绪事件（选择键集合）</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (selector.select() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取选择键集合</span></span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (selectedKeys.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取单个的选择键并处理</span></span><br><span class=\"line\">                SelectionKey selectedKey = selectedKeys.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (selectedKey.isAcceptable()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 若选择键的IO事件是“连接就绪”，就获取客户端连接</span></span><br><span class=\"line\">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class=\"line\">                    <span class=\"comment\">// 切换为非阻塞模式</span></span><br><span class=\"line\">                    socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 将新连接的通道可读事件注册到选择器上</span></span><br><span class=\"line\">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isReadable()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 若选择键的IO事件是“可读”，就读取数据</span></span><br><span class=\"line\">                    SocketChannel socketChannel = (SocketChannel) selectedKey.channel();</span><br><span class=\"line\">                    <span class=\"comment\">// 读取数据，然后丢弃</span></span><br><span class=\"line\">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 调用通道的read方法，从通道读取数据写入缓冲区，并返回读取到的数据</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> ((length = socketChannel.read(byteBuffer)) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        byteBuffer.flip();</span><br><span class=\"line\">                        System.out.println(<span class=\"keyword\">new</span> String(byteBuffer.array(), <span class=\"number\">0</span>, length));</span><br><span class=\"line\">                        byteBuffer.clear();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    socketChannel.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 移除选择键</span></span><br><span class=\"line\">                selectedKeys.remove();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\">        serverSocketChannel.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>客户端：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用NIO实现Discard客户端功能：</span></span><br><span class=\"line\"><span class=\"comment\"> *      客户端首先建立到服务器的连接，发送一些简单的数据，然后直接关闭连接。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioDiscardClient</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startClient</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        InetSocketAddress address = <span class=\"keyword\">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class=\"number\">5252</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        SocketChannel socketChannel = SocketChannel.open(address);</span><br><span class=\"line\">        <span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">        socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 不断自旋，等待连接完成</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!socketChannel.finishConnect()) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端连接成功\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 分配指定大小的缓冲区</span></span><br><span class=\"line\">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">        byteBuffer.put(<span class=\"string\">\"hello nio\"</span>.getBytes());</span><br><span class=\"line\">        byteBuffer.flip();</span><br><span class=\"line\">        <span class=\"comment\">// 发送到服务器</span></span><br><span class=\"line\">        socketChannel.write(byteBuffer);</span><br><span class=\"line\">        <span class=\"comment\">// 终止输出方法，向对方发送一个输出的结束标志</span></span><br><span class=\"line\">        socketChannel.shutdownOutput();</span><br><span class=\"line\">        <span class=\"comment\">// 关闭套接字连接</span></span><br><span class=\"line\">        socketChannel.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试：</strong></p>\n<p>​        先启动服务器，等到控制台出现“服务器启动成功”，再启动客户端，客户端连接成功后，发现服务器端出现“hello nio”则成功：</p>\n<p>服务器端：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">服务器启动成功</span><br></pre></td></tr></table></figure>\n\n<p>客户端：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端连接成功</span><br></pre></td></tr></table></figure>\n\n<p>服务器端：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">服务器启动成功</span></span><br><span class=\"line\"><span class=\"attr\">hello</span> <span class=\"string\">nio</span></span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java-NIO通信基础\"><a href=\"#Java-NIO通信基础\" class=\"headerlink\" title=\"Java NIO通信基础\"></a>Java NIO通信基础</h2><h3 id=\"一、NIO简介\"><a href=\"#一、NIO简介\" class=\"headerlink\" title=\"一、NIO简介\"></a>一、NIO简介</h3><blockquote>\n<p>在1.4版本之前，Java IO类库是阻塞IO；从1.4版本开始，为了支持非阻塞IO，引进了新的异步IO库，被称为Java New IO类库，简称为JAVA NIO。Java NIO属于 IO多路复用模型。</p>\n</blockquote>\n<p><strong>NIO和OIO（old IO）的区别：</strong></p>\n<ul>\n<li>OIO面向流（Stream Oriented），NIO面向缓冲区（BufferOriented）</li>\n<li>OIO的操作是阻塞的，NIO是非阻塞的。</li>\n<li>OIO没有选择器（Selector）概念，NIO的选择器，需要底层操作系统提供支持。</li>\n</ul>\n<p>Java NIO由以下三个核心组件组成：· Channel（通道）· Buffer（缓冲区）· Selector（选择器）</p>\n<h4 id=\"1-通道（Channel）\"><a href=\"#1-通道（Channel）\" class=\"headerlink\" title=\"1. 通道（Channel）\"></a>1. 通道（Channel）</h4><p>​        在OIO中，同一个网络连接会通过输入流（Input Stream）和输出流（Output Stream）不断地进行输入和输出的操作。在NIO中，同一个网络连接使用一个通道表示，所有的NIO的IO操作都是从通道开始的。一个通道类似于OIO中的两个流的结合体，既可以从通道读取，也可以向通道写入。</p>\n<h4 id=\"2-选择器（Selector）\"><a href=\"#2-选择器（Selector）\" class=\"headerlink\" title=\"2. 选择器（Selector）\"></a>2. 选择器（Selector）</h4><blockquote>\n<p>IO多路复用指的是一个进程/线程可以同时监视多个文件描述符（一个网络连接，操作系统底层使用一个文件描述符来表示），一旦其中的一个或者多个文件描述符可读或者可写，系统内核就通知该进程/线程。</p>\n</blockquote>\n<p>​        通过选择器，一个线程可以查询多个通道的IO事件的就绪状态，即监视多个文件描述符。具体的开发层面来说，首先把通道注册到选择器中，然后通过选择器内部的机制，可以查询（select）这些注册的通道是否有已经就绪的IO事件（例如可读、可写、网络连接完成等）。一个选择器只需要一个线程进行监控，系统不必为每一个网络连接（文件描述符）创建进程/线程，从而大大减小了系统的开销。</p>\n<h4 id=\"3-缓冲区（Buffer）\"><a href=\"#3-缓冲区（Buffer）\" class=\"headerlink\" title=\"3. 缓冲区（Buffer）\"></a>3. 缓冲区（Buffer）</h4><p>​        应用程序与通道（Channel）主要的交互操作，就是进行数据的read读取和write写入。通道的读取，就是将数据从通道读取到缓冲区中；通道的写入，就是将数据从缓冲区中写入到通道中。</p>\n<h3 id=\"二、Buffer类及其属性\"><a href=\"#二、Buffer类及其属性\" class=\"headerlink\" title=\"二、Buffer类及其属性\"></a>二、Buffer类及其属性</h3><blockquote>\n<p>Buffer（缓冲区）本质上是一个内存块（数组），既可以写入数据，也可以从中读取数据。</p>\n</blockquote>\n<h4 id=\"Buffer类\"><a href=\"#Buffer类\" class=\"headerlink\" title=\"Buffer类\"></a>Buffer类</h4><p>​        Buffer类是一个抽象类，位于java.nio包中，线程不安全。在NIO中有8种缓冲区类：ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer、MappedByteBuffer，其中MappedByteBuffer是专门用于内存映射的一种ByteBuffer类型。使用最多的是ByteBuffer。</p>\n<h4 id=\"Buffer类的重要属性\"><a href=\"#Buffer类的重要属性\" class=\"headerlink\" title=\"Buffer类的重要属性\"></a>Buffer类的重要属性</h4><p>​        为了记录读写的状态和位置，Buffer类提供了一些重要的属性：capacity（容量）、position（读写位置）、limit（读写的限制）、mark（标记）。</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gp33iz38e4j30kk05pt9v.jpg\" alt=\"image\"></p>\n<h4 id=\"Buffer类的重要方法\"><a href=\"#Buffer类的重要方法\" class=\"headerlink\" title=\"Buffer类的重要方法\"></a>Buffer类的重要方法</h4><ol>\n<li><p><strong>allocate()创建缓冲区</strong></p>\n<p> ​        为了获取一个Buffer实例对象，并不是使用子类的构造器new来创建一个实例对象，而是调用子类的allocate()方法，并分配内存空间（capacity）。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntBuffer intBuffer = intBuffer.allocate(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>put()写入到缓冲区</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intBuffer.put(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>flip()翻转</strong></p>\n<p> ​        向缓冲区写入数据之后，不能直接从缓冲区中读取数据，需要使用flip()将写入模式翻转成读取模式。flip()方法源码如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">flip</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    limit = position;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>;</span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 容量为10的intBuffer，在写入1个数据时，position=1，limit=10，capacity=10；在写完翻转后，position=0，limit=1，capacity=10；</p>\n<blockquote>\n<p>读取完成后，如何再一次将缓冲区切换成写入模式呢？可以调用Buffer.clear()清空或者Buffer.compact()压缩方法，它们可以将缓冲区转换为写模式。</p>\n</blockquote>\n<p> 缓冲区读写模式的转换如图：</p>\n<p> <img src=\"https://tvax1.sinaimg.cn/large/006YzKDNly1gp34tey3npj30g1071aay.jpg\" alt=\"image\"></p>\n</li>\n<li><p><strong>clear()清空</strong></p>\n<p> ​        清空缓冲区但不清除数据，数据将“被遗忘”，缓冲区切换为写入模式。源码如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>;</span><br><span class=\"line\">    limit = capacity;</span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>compact()压缩</strong></p>\n<p> ​        不覆盖未读的数据，将所有未读的数据拷贝到Buffer起始处，然后将position设到最后一个未读元素后面，limit设置为capacity，缓冲区切换为写入模式。源码如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ByteBuffer <span class=\"title\">compact</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.arraycopy(hb, ix(position()), hb, ix(<span class=\"number\">0</span>), remaining()); <span class=\"comment\">// 拷贝未读数据</span></span><br><span class=\"line\">    position(remaining()); <span class=\"comment\">// remaining()返回limit - position</span></span><br><span class=\"line\">    limit(capacity()); <span class=\"comment\">// limit设置为capacity</span></span><br><span class=\"line\">    discardMark(); <span class=\"comment\">// mark = -1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>get()从缓冲区读取</strong></p>\n<p> ​        翻转后可读，读操作会改变可读位置position的值，而limit值不会改变。如果position==limit，表示所有数据读取完成，position指向了一个没有数据的元素位置，此时再读，会抛出BufferUnderflowException异常。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byteBuffer.get();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>rewind()倒带</strong></p>\n<p> ​        已读完的数据，如果需要再读一遍，可以调用rewind()方法。rewind()也叫倒带。源码如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">rewind</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>; <span class=\"comment\">// 重置</span></span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>; <span class=\"comment\">// 清理标记</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>rewind()和flip()区别在于：rewind()不会影响limit；而flip()会重设limit属性值。</p>\n</blockquote>\n</li>\n<li><p><strong>mark( )和reset( )</strong></p>\n<p>​        Buffer.mark()和Buffer.reset()方法是配套使用的，比如读到第3个元素（i= =2时），调用mark()方法，把当前位置position的值保存到mark属性中，这时mark属性的值为2。接下来，就可以调用reset方法，将mark属性的值恢复到position中。然后可以从位置2（第三个元素）开始读。</p>\n</li>\n</ol>\n<p><strong>Buffer类的基本使用步骤</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntBuffer intBuffer = intBuffer.allocate(<span class=\"number\">10</span>);</span><br><span class=\"line\">intBuffer.put(<span class=\"number\">1</span>);</span><br><span class=\"line\">intBuffer.flip();</span><br><span class=\"line\">intBuffer.get();</span><br><span class=\"line\">intBuffer.clear();||intBuffer.compact();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、Channel类及其属性\"><a href=\"#二、Channel类及其属性\" class=\"headerlink\" title=\"二、Channel类及其属性\"></a>二、Channel类及其属性</h3><blockquote>\n<p>NIO中一个连接用一个Channel（通道）来表示，一个通道可以表示一个底层的文件描述符，例如硬件设备、文件、网络连接等。对于不同的网络传输协议类型，在Java中都有不同的NIO Channel（通道）实现。</p>\n</blockquote>\n<h4 id=\"Channel（通道）的主要类型\"><a href=\"#Channel（通道）的主要类型\" class=\"headerlink\" title=\"Channel（通道）的主要类型\"></a>Channel（通道）的主要类型</h4><ol>\n<li><p>FileChannel文件通道，用于文件的数据读写。</p>\n</li>\n<li><p>SocketChannel套接字通道，用于Socket套接字TCP连接的数据读写。</p>\n</li>\n<li><p>ServerSocketChannel服务器嵌套字通道（或服务器监听通道），允许我们监听TCP连接请求，为每个监听到的请求，创建一个SocketChannel套接字通道。</p>\n</li>\n<li><p>DatagramChannel数据报通道，用于UDP协议的数据读写。</p>\n</li>\n</ol>\n<h4 id=\"FileChannel的使用\"><a href=\"#FileChannel的使用\" class=\"headerlink\" title=\"FileChannel的使用\"></a>FileChannel的使用</h4><blockquote>\n<p>通过FileChannel，既可以从一个文件中读取数据，也可以将数据写入到文件中。FileChannel为<strong>阻塞模式</strong>，不能设置为非阻塞模式。</p>\n</blockquote>\n<ol>\n<li><strong>获取FileChannel通道</strong></li>\n</ol>\n<ul>\n<li><p>通过文件输入输出流获取：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建文件输入流</span></span><br><span class=\"line\">FileInputStream fis = <span class=\"keyword\">new</span> FileInputStream(srcFile);</span><br><span class=\"line\"><span class=\"comment\">// 获取文件流的通道</span></span><br><span class=\"line\">FileChannel inChannel = fis.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建文件输出流</span></span><br><span class=\"line\">FileOutputStream fos = <span class=\"keyword\">new</span> FileOutputStream(destFile);</span><br><span class=\"line\"><span class=\"comment\">// 获取文件流的通道</span></span><br><span class=\"line\">FileChannel outChannel = fis.getChannel();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过RandomAccessFile类获取：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建RandomAccessFile随机访问对象</span></span><br><span class=\"line\">RandomAccessFile rafile = <span class=\"keyword\">new</span> RandomAccessFile(srcFile, <span class=\"string\">\"rw\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 获取文件流的通道</span></span><br><span class=\"line\">FileChannel raFileChannel = rafile.getChannel();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p><strong>读取FileChannel通道</strong></p>\n<p> ​        调用<code>public abstract int read(ByteBuffer src) throws IOException</code>方法读取通道数据，写入ByteBuffer缓冲区，并返回数据。<strong>虽然对于通道来说是读取数据，但是对于ByteBuffer缓冲区来说是写入数据，这时，ByteBuffer缓冲区处于写入模式。</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> length = -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (-<span class=\"number\">1</span> != (length = raFileChannel.read(byteBuffer))) &#123;</span><br><span class=\"line\"><span class=\"comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>写入FileChannel通道</strong></p>\n<p> ​        调用<code>public abstract int write(ByteBuffer src) throws IOException</code>方法读取缓冲区数据写入通道，并返回写入的字节数。<strong>对于ByteBuffer缓冲区来说是读入数据，对通道来说是写入。</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 刚写完要翻转成读取模式</span></span><br><span class=\"line\">byteBuffer.flip();</span><br><span class=\"line\"><span class=\"keyword\">int</span> outlength = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"number\">0</span> != (outlength = raFileChannel.write(byteBuffer))) &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"写入字节数：\"</span> + outlength);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>关闭通道</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inChannel.close();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>强制刷新到磁盘</strong></p>\n<p> ​        在将缓冲区写入通道时，出于性能原因，操作系统不可能每次都实时将数据写入磁盘。如果需要保证写入通道的缓冲数据，最终都真正地写入磁盘，可以调用FileChannel的force()方法。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inChannel.force(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"SocketChannel和ServerSocketChannel的使用\"><a href=\"#SocketChannel和ServerSocketChannel的使用\" class=\"headerlink\" title=\"SocketChannel和ServerSocketChannel的使用\"></a>SocketChannel和ServerSocketChannel的使用</h4><blockquote>\n<p>在NIO中，涉及网络连接的通道有两个，一个是SocketChannel负责连接传输，另一个是ServerSocketChannel负责连接的监听。都<strong>支持阻塞和非阻塞两种模式</strong>。ServerSocketChannel应用于服务器端，而SocketChannel同时处于服务器端和客户端。对于一个连接，两端都有一个负责传输的SocketChannel传输通道。SocketChannel与OIO中的Socket类对应，ServerSocketChannel与OIO中的ServerSocket类对应。</p>\n</blockquote>\n<ol>\n<li><p><strong>获取SocketChannel传输通道</strong></p>\n<p> ​        在<strong>客户端</strong>，先通过SocketChannel静态方法open()获得一个套接字传输通道；然后，将socket套接字设置为非阻塞模式；最后，通过connect()实例方法，对服务器的IP和端口发起连接。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">SocketChannel socketChannel = SocketChannel.open();</span><br><span class=\"line\"><span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 对服务器的IP和端口发起连接</span></span><br><span class=\"line\">socketChannel.connect(<span class=\"keyword\">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class=\"number\">5252</span>));</span><br></pre></td></tr></table></figure>\n\n<p> ​        非阻塞情况下，与服务器的连接可能还没有真正建立，socketChannel.connect方法就返回了，因此需要不断地自旋，检查当前是否连接到了主机：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不断自旋，等待连接完成</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (!socketChannel.finishConnect()) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> ​        在<strong>服务器端</strong>，当新连接事件到来时，ServerSocketChannel能成功地查询，通过accept()方法，来获取新连接的套接字通道：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新连接事件到来,通过事件（后面会讲到key）获取服务器监听通道</span></span><br><span class=\"line\">ServerSocketChannel serverSocketChannel = （ServerSocketChannel）key.channel();</span><br><span class=\"line\"><span class=\"comment\">// 获取新连接的套接字通道</span></span><br><span class=\"line\">SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class=\"line\"><span class=\"comment\">// 切换为非阻塞模式</span></span><br><span class=\"line\">socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>读取SocketChannel传输通道</strong></p>\n<p> ​        与FileChannel一样</p>\n</li>\n<li><p><strong>写入SocketChannel传输通道</strong></p>\n<p> ​        与FileChannel一样</p>\n</li>\n<li><p><strong>关闭SocketChannel传输通道</strong></p>\n<p> ​        在关闭SocketChannel传输通道前，如果传输通道用来写入数据，则建议调用一次shutdownOutput()终止输出方法，向对方发送一个输出的结束标志（-1）。然后调用socketChannel.close()方法，关闭套接字连接。</p>\n <figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 终止输出方法，向对方发送一个输出的结束标志</span></span><br><span class=\"line\"><span class=\"selector-tag\">socketChannel</span><span class=\"selector-class\">.shutdownOutput</span>();</span><br><span class=\"line\"><span class=\"comment\">// 关闭套接字连接</span></span><br><span class=\"line\"><span class=\"selector-tag\">socketChannel</span><span class=\"selector-class\">.close</span>();</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"DatagramChannel的使用\"><a href=\"#DatagramChannel的使用\" class=\"headerlink\" title=\"DatagramChannel的使用\"></a>DatagramChannel的使用</h4><blockquote>\n<p>DatagramChannel数据报通道用来处理UDP协议的数据传输。和Socket套接字的TCP传输协议不同，UDP协议不是面向连接的协议。使用UDP协议时，只要知道服务器的IP和端口，就可以直接向对方发送数据。</p>\n</blockquote>\n<ol>\n<li><p><strong>获取DatagramChannel传输通道</strong></p>\n<p> ​        调用DatagramChannel静态方法open()获得通道，然后设置为非阻塞模式，绑定数据报的监听端口：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class=\"line\"><span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">datagramChannel.configureBlocking(<span class=\"keyword\">false</span>);\t\t</span><br><span class=\"line\"><span class=\"comment\">// 绑定监听IP和端口</span></span><br><span class=\"line\">datagramChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class=\"number\">5252</span>));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>读取DatagramChannel传输通道</strong></p>\n<p> ​        不是调用read方法，而是调用receive：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">SocketAddress clientAddr = datagramChannel.receive(byteBuffer);</span><br></pre></td></tr></table></figure>\n\n<p> ​        通道读取receive（ByteBuffer buf）方法的返回值，是SocketAddress类型，表示返回发送端的连接地址（包括IP和端口）。</p>\n</li>\n<li><p><strong>写入DatagramChannel传输通道</strong></p>\n<p> ​        不是调用write方法，而是调用send方法，由于UDP是面向非连接的协议，因此，在发送数据的时候，需要指定接收方的地址：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byteBuffer.flip();</span><br><span class=\"line\">datagramChannel.send(byteBuffer, <span class=\"keyword\">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class=\"number\">5252</span>));</span><br><span class=\"line\">byteBuffer.clear();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>关闭DatagramChannel传输通道</strong></p>\n<p> ​        与FileChannel一样，close()即可。</p>\n</li>\n</ol>\n<h3 id=\"三、Select类及其属性\"><a href=\"#三、Select类及其属性\" class=\"headerlink\" title=\"三、Select类及其属性\"></a>三、Select类及其属性</h3><blockquote>\n<p>非阻塞模式下，如何知道SocketChannel和DatagramChannel通道何时是可读的呢？这时就需要用到NIO的新组件——Selector通道选择器</p>\n<p>简单地说：<strong>选择器的使命是完成IO的多路复用</strong>。一个通道代表一条连接，通过选择器可以同时监控多个通道的IO（输入输出）状况。选择器和通道的关系，是监控和被监控的关系。</p>\n</blockquote>\n<h4 id=\"Selector-选择器及注册\"><a href=\"#Selector-选择器及注册\" class=\"headerlink\" title=\"Selector 选择器及注册\"></a>Selector 选择器及注册</h4><p>​        通道和选择器之间的关系，通过<code>Channel.register（Selector sel, int ops）</code>方法完成，需要传入待注册的选择器实例和待监控事件类型。</p>\n<p>可供选择器监控的<strong>通道IO事件类型</strong>（就绪状态），包括以下四种：</p>\n<ol>\n<li>可读：SelectionKey.OP_READ</li>\n<li>可写：SelectionKey.OP_WRITE</li>\n<li>连接：SelectionKey.OP_CONNECT</li>\n<li>接收：SelectionKey.OP_ACCEPT</li>\n</ol>\n<p>事件类型的定义在SelectionKey类中。如果选择器要监控通道的多种事件，可以用“按位或”运算符来实现。例如，同时监控可读和可写IO事件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> key = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SelectableChannel-可选择通道\"><a href=\"#SelectableChannel-可选择通道\" class=\"headerlink\" title=\"SelectableChannel(可选择通道)\"></a>SelectableChannel(可选择通道)</h4><p>​        一条通道若能被选择，必须继承SelectableChannel类。所有网络链接Socket套接字通道，都继承了SelectableChannel类，都是可选择的。而FileChannel文件通道，并没有继承SelectableChannel，因此不是可选择通道。</p>\n<h4 id=\"SelectionKey-选择键\"><a href=\"#SelectionKey-选择键\" class=\"headerlink\" title=\"SelectionKey(选择键)\"></a>SelectionKey(选择键)</h4><p>​        一旦在通道中发生了某些IO事件（就绪状态达成），并且在选择器中注册过，就会被选择器选中，并放入SelectionKey的集合中。SelectionKey可以获得通道的IO事件类型，比方说SelectionKey.OP_READ，还可以获得发生IO事件所在的通道及选择器实例。</p>\n<h4 id=\"选择器的使用\"><a href=\"#选择器的使用\" class=\"headerlink\" title=\"选择器的使用\"></a>选择器的使用</h4><ol>\n<li><p><strong>获取选择器实例</strong></p>\n<p> ​        通过调用静态工厂方法open()来获取：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>\n\n<p> <em>open()的内部，是向选择器SPI（SelectorProvider）发出请求，通过默认的SPI对象，获取一个新的选择器实例。SPI全称为（Service Provider Interface，服务提供者接口），是JDK的一种可以扩展的服务提供和发现机制。Java通过SPI的方式，提供选择器的默认实现版本。也就是说，其他的服务提供商可以通过SPI的方式，提供定制化版本的选择器的动态替换或者扩展。</em></p>\n</li>\n<li><p><strong>将通道注册到选择器中</strong></p>\n<p> ​        需要注意：注册到选择器的通道，必须处于非阻塞模式下，否则将抛出IllegalBlockingModeException异常。并且一个通道，并不一定支持所有的四种IO事件。例如服务器监听通道ServerSocketChannel，仅支持Accept（接收到新连接）IO事件；而SocketChannel传输通道，则不支持Accept（接收到新连接）IO事件。可以在注册之前，通过通道的validOps()方法，来获取该通道所有支持的IO事件集合。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\"><span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 绑定连接</span></span><br><span class=\"line\">serverSocketChannel.bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">5252</span>));</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"服务器启动成功\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 将通道注册的“接收新连接”IO事件注册到选择器上</span></span><br><span class=\"line\">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>选出感兴趣的IO就绪事件（选择键集合）</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 轮询感兴趣的IO就绪事件（选择键集合）</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (selector.select() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取选择键集合</span></span><br><span class=\"line\">    Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (selectedKeys.hasNext()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取单个的选择键并处理</span></span><br><span class=\"line\">        SelectionKey selectedKey = selectedKeys.next();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedKey.isAcceptable()) &#123;</span><br><span class=\"line\">     \t\t<span class=\"comment\">// 通道有新连接</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isConnectalbe()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通道连接成功</span></span><br><span class=\"line\">        &#125;  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isReadalbe()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通道可读</span></span><br><span class=\"line\">        &#125;  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isWritalbe()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通道可写</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 处理完后移除选择键</span></span><br><span class=\"line\">        selectedKeys.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> SelectionKey集合不能添加元素，如果试图向SelectionKey选择键集合中添加元素，则将抛出java.lang.UnsupportedOperationException异常。</p>\n<p> select()方法有三个重载的实现版本，具体如下：</p>\n<ol>\n<li><p>select()：阻塞调用，一直到至少有一个通道发生了注册的IO事件。</p>\n</li>\n<li><p>select(long timeout)：和select()一样，但最长阻塞时间为timeout指定的毫秒数。</p>\n</li>\n<li><p>selectNow()：非阻塞，不管有没有IO事件，都会立刻返回。</p>\n<p>select()方法返回的整数值，表示从上一次select到这一次select之间，有多少<strong>通道</strong>发生了注册的IO事件。强调一下，select()方法返回的数量，指的是通道数，而不是IO事件数。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"实践案例\"><a href=\"#实践案例\" class=\"headerlink\" title=\"实践案例\"></a>实践案例</h4><p>使用NIO实现Discard服务器，Discard服务器的功能很简单，读取客户端通道的输入数据，读取完成后直接关闭客户端通道；并且读取到的数据直接抛弃掉。</p>\n<p><strong>服务器端：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用NIO实现Discard服务器端功能：</span></span><br><span class=\"line\"><span class=\"comment\"> *      仅读取客户端通道的输入数据，读取完成后直接关闭客户端通道，并且读取到的数据直接抛弃掉。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioDiscardServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startServer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取选择器</span></span><br><span class=\"line\">        Selector selector = Selector.open();</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\">        <span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">        serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 绑定连接</span></span><br><span class=\"line\">        serverSocketChannel.bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">5252</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"服务器启动成功\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 将通道注册的“接收新连接”IO事件注册到选择器上</span></span><br><span class=\"line\">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 轮询感兴趣的IO就绪事件（选择键集合）</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (selector.select() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取选择键集合</span></span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (selectedKeys.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取单个的选择键并处理</span></span><br><span class=\"line\">                SelectionKey selectedKey = selectedKeys.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (selectedKey.isAcceptable()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 若选择键的IO事件是“连接就绪”，就获取客户端连接</span></span><br><span class=\"line\">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class=\"line\">                    <span class=\"comment\">// 切换为非阻塞模式</span></span><br><span class=\"line\">                    socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 将新连接的通道可读事件注册到选择器上</span></span><br><span class=\"line\">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isReadable()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 若选择键的IO事件是“可读”，就读取数据</span></span><br><span class=\"line\">                    SocketChannel socketChannel = (SocketChannel) selectedKey.channel();</span><br><span class=\"line\">                    <span class=\"comment\">// 读取数据，然后丢弃</span></span><br><span class=\"line\">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 调用通道的read方法，从通道读取数据写入缓冲区，并返回读取到的数据</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> ((length = socketChannel.read(byteBuffer)) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        byteBuffer.flip();</span><br><span class=\"line\">                        System.out.println(<span class=\"keyword\">new</span> String(byteBuffer.array(), <span class=\"number\">0</span>, length));</span><br><span class=\"line\">                        byteBuffer.clear();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    socketChannel.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 移除选择键</span></span><br><span class=\"line\">                selectedKeys.remove();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\">        serverSocketChannel.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>客户端：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用NIO实现Discard客户端功能：</span></span><br><span class=\"line\"><span class=\"comment\"> *      客户端首先建立到服务器的连接，发送一些简单的数据，然后直接关闭连接。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioDiscardClient</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startClient</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        InetSocketAddress address = <span class=\"keyword\">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class=\"number\">5252</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        SocketChannel socketChannel = SocketChannel.open(address);</span><br><span class=\"line\">        <span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">        socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 不断自旋，等待连接完成</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!socketChannel.finishConnect()) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端连接成功\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 分配指定大小的缓冲区</span></span><br><span class=\"line\">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">        byteBuffer.put(<span class=\"string\">\"hello nio\"</span>.getBytes());</span><br><span class=\"line\">        byteBuffer.flip();</span><br><span class=\"line\">        <span class=\"comment\">// 发送到服务器</span></span><br><span class=\"line\">        socketChannel.write(byteBuffer);</span><br><span class=\"line\">        <span class=\"comment\">// 终止输出方法，向对方发送一个输出的结束标志</span></span><br><span class=\"line\">        socketChannel.shutdownOutput();</span><br><span class=\"line\">        <span class=\"comment\">// 关闭套接字连接</span></span><br><span class=\"line\">        socketChannel.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试：</strong></p>\n<p>​        先启动服务器，等到控制台出现“服务器启动成功”，再启动客户端，客户端连接成功后，发现服务器端出现“hello nio”则成功：</p>\n<p>服务器端：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">服务器启动成功</span><br></pre></td></tr></table></figure>\n\n<p>客户端：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端连接成功</span><br></pre></td></tr></table></figure>\n\n<p>服务器端：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">服务器启动成功</span></span><br><span class=\"line\"><span class=\"attr\">hello</span> <span class=\"string\">nio</span></span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"数据结构与算法---二叉树","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":0,"abbrlink":"c608","date":"2020-12-20T16:00:00.000Z","subtitle":null,"_content":"### 数据结构与算法---平衡二叉树\n### 数据结构与算法---二叉查找树\n### 数据结构与算法---平衡二叉查找树\n#### AVL树\n#### 红黑树\n### 数据结构与算法---完全二叉树\n### 数据结构与算法---满二叉树\n","source":"_posts/algorithm-tree.md","raw":"---\ntitle: 数据结构与算法---二叉树\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop: 0\ntags:\n  - algorithm\ncategories:\n  - work\nabbrlink: c608\ndate: 2020-12-21 00:00:00\nsubtitle:\n---\n### 数据结构与算法---平衡二叉树\n### 数据结构与算法---二叉查找树\n### 数据结构与算法---平衡二叉查找树\n#### AVL树\n#### 红黑树\n### 数据结构与算法---完全二叉树\n### 数据结构与算法---满二叉树\n","slug":"algorithm-tree","published":1,"updated":"2021-12-10T09:05:27.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1az000qacbfesi5egem","content":"<h3 id=\"数据结构与算法—平衡二叉树\"><a href=\"#数据结构与算法—平衡二叉树\" class=\"headerlink\" title=\"数据结构与算法—平衡二叉树\"></a>数据结构与算法—平衡二叉树</h3><h3 id=\"数据结构与算法—二叉查找树\"><a href=\"#数据结构与算法—二叉查找树\" class=\"headerlink\" title=\"数据结构与算法—二叉查找树\"></a>数据结构与算法—二叉查找树</h3><h3 id=\"数据结构与算法—平衡二叉查找树\"><a href=\"#数据结构与算法—平衡二叉查找树\" class=\"headerlink\" title=\"数据结构与算法—平衡二叉查找树\"></a>数据结构与算法—平衡二叉查找树</h3><h4 id=\"AVL树\"><a href=\"#AVL树\" class=\"headerlink\" title=\"AVL树\"></a>AVL树</h4><h4 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h4><h3 id=\"数据结构与算法—完全二叉树\"><a href=\"#数据结构与算法—完全二叉树\" class=\"headerlink\" title=\"数据结构与算法—完全二叉树\"></a>数据结构与算法—完全二叉树</h3><h3 id=\"数据结构与算法—满二叉树\"><a href=\"#数据结构与算法—满二叉树\" class=\"headerlink\" title=\"数据结构与算法—满二叉树\"></a>数据结构与算法—满二叉树</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"数据结构与算法—平衡二叉树\"><a href=\"#数据结构与算法—平衡二叉树\" class=\"headerlink\" title=\"数据结构与算法—平衡二叉树\"></a>数据结构与算法—平衡二叉树</h3><h3 id=\"数据结构与算法—二叉查找树\"><a href=\"#数据结构与算法—二叉查找树\" class=\"headerlink\" title=\"数据结构与算法—二叉查找树\"></a>数据结构与算法—二叉查找树</h3><h3 id=\"数据结构与算法—平衡二叉查找树\"><a href=\"#数据结构与算法—平衡二叉查找树\" class=\"headerlink\" title=\"数据结构与算法—平衡二叉查找树\"></a>数据结构与算法—平衡二叉查找树</h3><h4 id=\"AVL树\"><a href=\"#AVL树\" class=\"headerlink\" title=\"AVL树\"></a>AVL树</h4><h4 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h4><h3 id=\"数据结构与算法—完全二叉树\"><a href=\"#数据结构与算法—完全二叉树\" class=\"headerlink\" title=\"数据结构与算法—完全二叉树\"></a>数据结构与算法—完全二叉树</h3><h3 id=\"数据结构与算法—满二叉树\"><a href=\"#数据结构与算法—满二叉树\" class=\"headerlink\" title=\"数据结构与算法—满二叉树\"></a>数据结构与算法—满二叉树</h3>"},{"title":"nginx127.0.0.1与localhost跨域问题","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":0,"abbrlink":"9f48","date":"2021-10-27T16:00:00.000Z","subtitle":null,"_content":"### nginx127.0.0.1与localhost跨域问题\n\n前端vue，后端springboot，本地联调为解决跨域问题使用nginx反向代理，nginx配置如下：\n\n```js\nserver {\n    listen 8090;\n    server_name localhost;\n    #前端根路由\n    location /aclui { \n    \tproxy_pass   http://127.0.0.1:8031/;\n    }\n    #接口根路由\n    location /aclrs {\n    \tproxy_pass   http://127.0.0.1:8032/;\n    }\n    ...\n}\n```\n\n本地工程启动后，访问`localhost:8090/aclui`，页面显示正常，但是后台接口调用全部失败，F12发现接口请求状态码返回200，但是response为：`this request has no response data`\n后端工程控制台报错如下：\n\n```java\n401 Unauthorized: [{\"code\":\"401\",\"content\": { \"unauthorized\":\"token is invalidate\"}}] \n```\n\nnginx error.log日志中有如下记录：\n\n```verilog\n2021/11/04 18:08:44 [error] 2540#8504: *7200 upstream prematurely closed connection while reading response header from upstream, client: 127.0.0.1, server: localhost, request: \"GET /aclrs/acl/option/set?option=2 HTTP/1.1\", upstream: \"http://127.0.0.1:8096//acl/option/set?option=2\", host: \"localhost:8090\", referrer: \"http://localhost:8090/aclui/view/acl/option/aclOptionCfg.html\n```\n\n由于nginx中配置的是`127.0.0.1`，实际访问的地址为`localhost`，这种情况也会存在跨域的问题，造成`this request has no response data`错误，将本地访问地址修改为`127.0.0.1:8090/aclui`即可解决。","source":"_posts/nginx-cors.md","raw":"---\ntitle: nginx127.0.0.1与localhost跨域问题\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop: 0\ntags:\n  - nginx\ncategories:\n  - work\nabbrlink: 9f48\ndate: 2021-10-28 00:00:00\nsubtitle:\n---\n### nginx127.0.0.1与localhost跨域问题\n\n前端vue，后端springboot，本地联调为解决跨域问题使用nginx反向代理，nginx配置如下：\n\n```js\nserver {\n    listen 8090;\n    server_name localhost;\n    #前端根路由\n    location /aclui { \n    \tproxy_pass   http://127.0.0.1:8031/;\n    }\n    #接口根路由\n    location /aclrs {\n    \tproxy_pass   http://127.0.0.1:8032/;\n    }\n    ...\n}\n```\n\n本地工程启动后，访问`localhost:8090/aclui`，页面显示正常，但是后台接口调用全部失败，F12发现接口请求状态码返回200，但是response为：`this request has no response data`\n后端工程控制台报错如下：\n\n```java\n401 Unauthorized: [{\"code\":\"401\",\"content\": { \"unauthorized\":\"token is invalidate\"}}] \n```\n\nnginx error.log日志中有如下记录：\n\n```verilog\n2021/11/04 18:08:44 [error] 2540#8504: *7200 upstream prematurely closed connection while reading response header from upstream, client: 127.0.0.1, server: localhost, request: \"GET /aclrs/acl/option/set?option=2 HTTP/1.1\", upstream: \"http://127.0.0.1:8096//acl/option/set?option=2\", host: \"localhost:8090\", referrer: \"http://localhost:8090/aclui/view/acl/option/aclOptionCfg.html\n```\n\n由于nginx中配置的是`127.0.0.1`，实际访问的地址为`localhost`，这种情况也会存在跨域的问题，造成`this request has no response data`错误，将本地访问地址修改为`127.0.0.1:8090/aclui`即可解决。","slug":"nginx-cors","published":1,"updated":"2021-12-10T09:05:27.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1b0000uacbf2fj0a0ev","content":"<h3 id=\"nginx127-0-0-1与localhost跨域问题\"><a href=\"#nginx127-0-0-1与localhost跨域问题\" class=\"headerlink\" title=\"nginx127.0.0.1与localhost跨域问题\"></a>nginx127.0.0.1与localhost跨域问题</h3><p>前端vue，后端springboot，本地联调为解决跨域问题使用nginx反向代理，nginx配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen <span class=\"number\">8090</span>;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\">    #前端根路由</span><br><span class=\"line\">    location /aclui &#123; </span><br><span class=\"line\">    \tproxy_pass   http:<span class=\"comment\">//127.0.0.1:8031/;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    #接口根路由</span><br><span class=\"line\">    location /aclrs &#123;</span><br><span class=\"line\">    \tproxy_pass   http:<span class=\"comment\">//127.0.0.1:8032/;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本地工程启动后，访问<code>localhost:8090/aclui</code>，页面显示正常，但是后台接口调用全部失败，F12发现接口请求状态码返回200，但是response为：<code>this request has no response data</code><br>后端工程控制台报错如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">401</span> Unauthorized: [&#123;<span class=\"string\">\"code\"</span>:<span class=\"string\">\"401\"</span>,<span class=\"string\">\"content\"</span>: &#123; <span class=\"string\">\"unauthorized\"</span>:<span class=\"string\">\"token is invalidate\"</span>&#125;&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>nginx error.log日志中有如下记录：</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2021</span>/<span class=\"number\">11</span>/<span class=\"number\">04</span> <span class=\"number\">18</span>:<span class=\"number\">08</span>:<span class=\"number\">44</span> [error] <span class=\"number\">2540</span>#<span class=\"number\">8504</span>: *<span class=\"number\">7200</span> upstream prematurely closed connection <span class=\"keyword\">while</span> reading response header from upstream, client: <span class=\"number\">127</span><span class=\"variable\">.0</span><span class=\"variable\">.0</span><span class=\"variable\">.1</span>, server: localhost, request: <span class=\"string\">\"GET /aclrs/acl/option/set?option=2 HTTP/1.1\"</span>, upstream: <span class=\"string\">\"http://127.0.0.1:8096//acl/option/set?option=2\"</span>, host: <span class=\"string\">\"localhost:8090\"</span>, referrer: <span class=\"string\">\"http://localhost:8090/aclui/view/acl/option/aclOptionCfg.html</span></span><br></pre></td></tr></table></figure>\n\n<p>由于nginx中配置的是<code>127.0.0.1</code>，实际访问的地址为<code>localhost</code>，这种情况也会存在跨域的问题，造成<code>this request has no response data</code>错误，将本地访问地址修改为<code>127.0.0.1:8090/aclui</code>即可解决。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"nginx127-0-0-1与localhost跨域问题\"><a href=\"#nginx127-0-0-1与localhost跨域问题\" class=\"headerlink\" title=\"nginx127.0.0.1与localhost跨域问题\"></a>nginx127.0.0.1与localhost跨域问题</h3><p>前端vue，后端springboot，本地联调为解决跨域问题使用nginx反向代理，nginx配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen <span class=\"number\">8090</span>;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\">    #前端根路由</span><br><span class=\"line\">    location /aclui &#123; </span><br><span class=\"line\">    \tproxy_pass   http:<span class=\"comment\">//127.0.0.1:8031/;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    #接口根路由</span><br><span class=\"line\">    location /aclrs &#123;</span><br><span class=\"line\">    \tproxy_pass   http:<span class=\"comment\">//127.0.0.1:8032/;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本地工程启动后，访问<code>localhost:8090/aclui</code>，页面显示正常，但是后台接口调用全部失败，F12发现接口请求状态码返回200，但是response为：<code>this request has no response data</code><br>后端工程控制台报错如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">401</span> Unauthorized: [&#123;<span class=\"string\">\"code\"</span>:<span class=\"string\">\"401\"</span>,<span class=\"string\">\"content\"</span>: &#123; <span class=\"string\">\"unauthorized\"</span>:<span class=\"string\">\"token is invalidate\"</span>&#125;&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>nginx error.log日志中有如下记录：</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2021</span>/<span class=\"number\">11</span>/<span class=\"number\">04</span> <span class=\"number\">18</span>:<span class=\"number\">08</span>:<span class=\"number\">44</span> [error] <span class=\"number\">2540</span>#<span class=\"number\">8504</span>: *<span class=\"number\">7200</span> upstream prematurely closed connection <span class=\"keyword\">while</span> reading response header from upstream, client: <span class=\"number\">127</span><span class=\"variable\">.0</span><span class=\"variable\">.0</span><span class=\"variable\">.1</span>, server: localhost, request: <span class=\"string\">\"GET /aclrs/acl/option/set?option=2 HTTP/1.1\"</span>, upstream: <span class=\"string\">\"http://127.0.0.1:8096//acl/option/set?option=2\"</span>, host: <span class=\"string\">\"localhost:8090\"</span>, referrer: <span class=\"string\">\"http://localhost:8090/aclui/view/acl/option/aclOptionCfg.html</span></span><br></pre></td></tr></table></figure>\n\n<p>由于nginx中配置的是<code>127.0.0.1</code>，实际访问的地址为<code>localhost</code>，这种情况也会存在跨域的问题，造成<code>this request has no response data</code>错误，将本地访问地址修改为<code>127.0.0.1:8090/aclui</code>即可解决。</p>\n"},{"title":"高并发利器Redis","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":null,"abbrlink":"a10a","date":"2021-04-14T16:00:00.000Z","subtitle":null,"_content":"\n\n\n### 一. 什么是Redis\n\n​\t\t官方简介：Redis是一个基于BSD**开源**的项目，是一个把**结构化**的数据放在**内存**中的一个存储系统，可以把它**作为数据库，缓存和消息中间件**来使用。同时支持**strings，lists，hashes，sets，sorted sets，**bitmaps，hyperloglogs、geospatial indexes和streams等**数据类型**。还内建了**复制、lua脚本、LRU、事务**、不同级别的**持久化**功能，通过redis sentinel实现**高可用**，通过redis cluster实现了**自动分片**，以及**发布/订阅**，**自动故障转移**等等特性。\n\n\n\n### 二. Redis能解决什么问题\n\n> **假如我们有个查询列表的API，用户抱怨说每次请求都要2秒左右才能返回结果，如何改善用户体验呢？**\n\n​\t\t**方案一、基于HTTP缓存**：\n\n​\t\t为API的响应头加上缓存控制 **cache-control**:max-age=600 ，即在浏览器缓存这个响应10分钟，简单粗暴。但是这个方法有两个缺点：第一个是在缓存生效的10分钟内，API消费者可能会得到旧的数据；第二个是如果客户端浏览器不使用缓存，方法直接无效。\n\n​\t\t**方案二、基于本机内存的缓存**\n\n​\t\t该API请求耗时操作主要在于使用SQL查询结果的过程中消耗了将近2秒的时间，于是，我们又想到了一个方案，把SQL查询的结果直接缓存在当前API服务器的内存中，比如使用JDK自带的**HashMap**和ConcurrentHashMap，或者**Guava Cache**、Spring Cache等本地缓存框架，设置缓存有效时间为10分钟，并且在修改和更新操作时同步修改缓存中的数据。这样后续10分钟内的请求直接读缓存，可以做到及时响应，不再花费2秒去执行SQL了。\n\n​\t\t结果其他API的小伙伴发现这是个好办法，于是很快我们就发现API服务器的内存要爆了...而且对于分布式架构，相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的。\n\n​\t\t**方案三、使用Redis做缓存**\n\n​\t\t要解决API服务器内存被缓存塞满及各服务间缓存无法共享的问题，最直接的办法就是把这些缓存部署在一台单独的服务器上，即使同一个相同的服务部署在再多机器上，也是使用的同一份缓存。于是我们需要为分布式缓存引入额外的服务，比如 Redis 或Memcached，而且要保证服务的高可用。\n\n#### Redis主要应用场景\n\n​\t\t缓存（数据查询、短连接、新闻内容、商品内容等）、分布式会话（Session）、任务队列（秒杀、抢购、12306等）、应用排行榜、访问统计、数据过期处理（可以精确到毫秒）。\n\n### 三. Redis 和 Memcached 的区别和共同点\n\n- **共同点** ：\n\n1. 都是基于内存的缓存。\n2. 都有过期策略。\n3. 两者的性能都非常高。\n\n- **区别** ：\n\n1. **Redis 支持更丰富的数据类型（支持更复杂的应用场景）**。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。\n2. **Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存之中。**\n3. **Redis 有灾难恢复机制。** 因为可以把缓存中的数据持久化到磁盘上。\n4. **Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。**\n5. **Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。**\n6. **Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。** （Redis 6.0 引入了多线程 IO ）\n7. **Redis 支持发布订阅模型、Lua脚本、事务等功能，而Memcached不支持。并且，Redis支持更多的编程语言。**\n\n\n\n### 四. 安装和配置\n\n#### 1. 安装：略\n\n#### 2. 主要配置：\n\n​\tLinux下配置文件为redis.conf，Windows下配置文件为redis.windows.conf\n\n- 开启持久化，配置文件装中添加如下内容：\n\n    ```\n    appendonly yes\n    ```\n\n- port：端口配置项，查看和设置Redis监听端口，默认端口为6379。\n- bind：主机地址配置项，查看和绑定的主机地址，默认地址的值为127.0.0.1。这个选项，在单网卡的机器上，一般不需要修改。\n\n- timeout：连接空闲多长要关闭连接，表示客户端闲置一段时间后，要关闭连接。如果指定为0，表示时长不限制。这个选项的默认值为0，表示默认不限制连接的空闲时长\n\n- dbfilename：指定保存缓存数据库的本地文件名，默认值为dump.rdb。\n\n- dir：指定保存缓存数据的本地文件所存放的目录，默认值为安装目录。\n\n- rdbcompression：指定存储至本地数据库时是否压缩数据，默认为yes,Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变得巨大。\n\n- save：指定在多长时间内，有多少次Key-Value更新操作，就将数据同步到本地数据库文件，可以设置多个条件。save配置项的格式为save<seconds><changes>:seconds表示时间段的长度，changes表示变化的次数。如设置为900秒（15分钟）内有1个更改，则同步到文件：\n\n    ```\n    127.0.0.1:6379> config set save \"900 1\"\n    OK\n    127.0.0.1:6379> config get save\n    1) \"save\"\n    2) \"900 1\"\n    ```\n\n- requirepass：设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认这个选项是关闭的。\n\n- slaveof：在主从复制的模式下，设置当前节点为slave（从）节点时，设置master（主）节点的IP地址及端口，在Redis启动时，它会自动从master（主）节点进行数据同步。如果已经是slave（从）服务器，则会丢掉旧数据集，从新的master主服务器同步缓存数据。格式为：\n\n    ```\n    slaveof<masterip><masterport>\n    ```\n\n- masterauth：在主从复制的模式下，当master（主）服务器节点设置了密码保护时，slave（从）服务器连接master（主）服务器的密码。格式为:\n\n    ```\n    masterauth<master-password>\n    ```\n\n- databases：设置缓存数据库的数量，默认数据库数量为16个。这16个数据库的id为0-15，默认使用的数据库是第0个。可以使用SELECT <dbid>命令在连接时通过数据库id来指定要使用的数据库。\n\n#### 3. Redis连接客户端命令：\n\n```\n#redis-cli -h host -p port -a password\n```\n\n本地连接：\n\n```\nroot@0912b31c4171# redis-cli\n```\n\n\n\n### 五. Redis的主要特点\n\n#### 1. 速度异常快 \n\n​\t\t采用多路 IO 复用模型，不需要等待磁盘的IO，在内存之间进行的数据存储和查询，速度非常快。官方数据显示每秒可执行大约 110000 次的设置(SET)操作，每秒大约可执行 81000 次的读取/获取(GET)操作。可以运行命令 `redis-benchmark -n 100000 -q` 来检测本地同时执行 10 万个请求时的性能：\n\n```\nroot@0912b31c4171:/data# redis-benchmark -n 100000 -q\nPING_INLINE: 31172.07 requests per second\nPING_BULK: 31615.55 requests per second\nSET: 30432.14 requests per second\nGET: 31289.11 requests per second\nINCR: 30441.40 requests per second\nLPUSH: 29550.83 requests per second\nRPUSH: 30184.12 requests per second\n```\n\n#### 2. 丰富的数据结构 \n\n​\t\t除了string之外，还有list、hash、set、sortedset、bitmaps、hyperloglogs、geospatial indexes和stream。其中**string(字符串)**、**list(列表)**、**hash(字典)**、**set(集合)** 和 **zset(有序集合)**这 5 种是 Redis 最基础、最重要的部分。\n\n#### 3. 单线程\n\n​\t\t避免了频繁的上下文切换。Redis 内部使用文件事件处理器 `file event handler`，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。\n\n文件事件处理器的结构包含 4 个部分：\n\n- 多个 socket\n\n- IO 多路复用程序\n\n- 文件事件分派器\n\n- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）\n\n    ​\t\t多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。\n\n    ***传统的并发模型，每个 I/O 流都有一个新的线程管理***\n\n     ***I/O 多路复用，只有单个线程，通过跟踪每个 I/O 流的状态，来管理多个 I/O 流。***\n\n#### 4. 可持久化 \n\n​\t\t支持RDB与AOF两种方式，将内存中的数据写入外部的物理存储设备。\n\n​\t\t**RDB**(Redis DataBase)：是最简单的 Redis 持久性模式。当满足特定条件时，它将生成数据集的时间点**快照**，例如，如果先前的快照是在2分钟前创建的，并且现在已经至少有 *100* 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 `.rdb` 文件生成。\n\n​\t\t**AOF** (Append Only File - 仅追加文件)：它的工作方式非常简单：每次执行 **修改内存** 中数据集的写操作时，都会 **记录** 该操作。假设 AOF 日志记录了自 Redis 实例创建以来 **所有的修改性指令序列**，那么就可以通过对一个空的 Redis 实例 **顺序执行所有的指令**，也就是 **「重放」**，来恢复 Redis 当前实例的内存数据结构的状态。\n\n​\t\t**RDB优势**\n\n- RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。\n\n- 生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。\n\n- RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。\n\n​\t\t**RDB劣势**\n\n- RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。\n\n​\t\t**AOF优势**\n\n- AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。（2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。\n\n- AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。\n\n- AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据\n\n​\t\t**AOF劣势**\n\n- 对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大\n\n- AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的\n\n- 以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。\n\n#### 5. 支持发布、订阅、管道。\n\n​\t\t**发布/ 订阅系统** 是 Web 系统中比较常用的一个功能。简单点说就是 **发布者发布消息，订阅者接受消息**，这有点类似于我们的报纸/ 杂志社之类的。我们可以使用redis的一个 `list` 列表结构结合 `lpush` 和 `rpop` 来实现消息队列的功能，但是似乎很难实现实现 **消息多播** 的功能：\n\n![image](https://tvax2.sinaimg.cn/large/006YzKDNly1gopdit62wmj30yg0ccgmp.jpg)\n\n​\t\t**Redis**为了消除`Publisher` 与 `Consumer` 的强关联，支持消息多播，引入了另一种概念：**频道** *(channel)*：\n\n![image](https://tvax1.sinaimg.cn/large/006YzKDNly1gopdjtvehij30yg0cbmy0.jpg)\n\n当 `Publisher` 往 `channel` 中发布消息时，关注了指定 `channel` 的 `Consumer` 就能够同时受到消息。但这里的 **问题** 是，消费者订阅一个频道是必须 **明确指定频道名称** 的，这意味着，如果我们想要 **订阅多个** 频道，那么就必须 **显式地关注多个** 名称。\n\n为了简化订阅的繁琐操作，**Redis** 提供了 **模式订阅** 的功能 **Pattern Subscribe**，这样就可以 **一次性关注多个频道** 了，即使生产者新增了同模式的频道，消费者也可以立即受到消息：\n\n![image](https://tvax2.sinaimg.cn/large/006YzKDNly1gopdkll7gtj30yg0cb0ul.jpg)\n\n例如上图中，**所有** 位于图片下方的 **`Consumer` 都能够受到消息**。\n\n`Publisher` 往 `wmyskxz.chat` 这个 `channel` 中发送了一条消息，不仅仅关注了这个频道的 `Consumer 1` 和 `Consumer 2` 能够受到消息，图片中的两个 `channel` 都和模式 `wmyskxz.*` 匹配，所以 **Redis** 此时会同样发送消息给订阅了 `wmyskxz.*` 这个模式的 `Consumer 3` 和关注了在这个模式下的另一个频道 `wmyskxz.log` 下的 `Consumer 4` 和 `Consumer 5`。\n\n另一方面，如果接收消息的频道是 `wmyskxz.chat`，那么 `Consumer 3` 也会受到消息。  \n\n##### *快速体验*\n\n在 **Redis** 中，**PubSub** 模块的使用非常简单，常用的命令也就下面这么几条：\n\n```bash\n# 订阅频道：\nSUBSCRIBE channel [channel ....]   # 订阅给定的一个或多个频道的信息\nPSUBSCRIBE pattern [pattern ....]  # 订阅一个或多个符合给定模式的频道\n# 发布频道：\nPUBLISH channel message  # 将消息发送到指定的频道\n# 退订频道：\nUNSUBSCRIBE [channel [channel ....]]   # 退订指定的频道\nPUNSUBSCRIBE [pattern [pattern ....]]  #退订所有给定模式的频道\n```\n\n我们可以在本地快速地来体验一下 **PubSub**：\n\n![](https://tvax2.sinaimg.cn/large/006YzKDNly1gopdlahl8sg30qq0cenpg.gif)\n\n具体步骤如下：\n\n1. 开启本地 Redis 服务，新建两个控制台窗口；\n2. 在其中一个窗口输入 `SUBSCRIBE wmyskxz.chat` 关注 `wmyskxz.chat` 频道，让这个窗口成为 **消费者**。\n3. 在另一个窗口输入 `PUBLISH wmyskxz.chat 'message'` 往这个频道发送消息，这个时候就会看到 **另一个窗口实时地出现** 了发送的测试消息。\n\n#### 6. 支持分布式锁 \n\n​\t\t在分布式系统中，如果不同的节点需要访同到一个资源，往往需要通过互斥机制来防止彼此干扰，并且保证数据的一致性。在这种情况下，需要使用到分布式锁。分布式锁和Java的锁用于实现不同线程之间的同步访问，原理上是类似的。\n\n#### 7.支持原子操作和事务\n\n​\t\tRedis事务是一组命令的集合。一个事务中的命令要么都执行，要么都不执行。如果命令在运行期间出现错误，不会自动回滚。\n\n#### 8.支持主-从（Master-Slave）复制与高可用（Redis Sentinel）集群\n\n​\t\t3.0版本以上功能\n\n\n\n### 六.常见数据结构及使用操作\n\n*一般情况下是这样设计 key 的： `表名:列名:主键名:主键值`*\n\n#### 1. string：\n\n> 值可以是任何种类的字符串（包括二进制数据），例如你可以在一个键下保存一张 `.jpeg` 图片，需要注意不要超过 512 MB 。\n\n- **设置和获取键值对**：\n\n```\n> SET key value\nOK\n> GET key\n\"value\"\n```\n\n当 key 存在时，`SET` 命令会覆盖掉你上一次设置的值：\n\n```\n> SET key newValue\nOK\n> GET key\n\"newValue\"\n```\n\n另外还可以使用 `EXISTS` 和 `DEL` 关键字来查询是否存在和删除键值对：\n\n```\n> EXISTS key\n(integer) 1\n> DEL key\n(integer) 1\n> GET key\n(nil)\n```\n\n- **批量设置键值对**\n\n```\n> SET key1 value1\nOK\n> SET key2 value2\nOK\n> MGET key1 key2 key3    # 返回一个列表\n1) \"value1\"\n2) \"value2\"\n3) (nil)\n> MSET key1 value1 key2 value2\n> MGET key1 key2\n1) \"value1\"\n2) \"value2\"\n```\n\n- **过期和 SET 命令扩展**\n\n可以对 key 设置过期时间，到时间会被自动删除，这个功能常用来控制缓存的失效时间。*(过期可以是任意数据结构)*\n\n```\n> SET key value1\n> GET key\n\"value1\"\n> EXPIRE name 5    # 5s 后过期\n...                # 等待 5s\n> GET key\n(nil)\n```\n\n等价于 `SET` + `EXPIRE` 的 `SETEX` 命令：\n\n```\n> SETEX key 5 value1\n...                # 等待 5s 后获取\n> GET key\n(nil)\n\n> SETNX key value1  # 如果 key 不存在则 SET 成功\n(integer) 1\n> SETNX key value1  # 如果 key 存在则 SET 失败\n(integer) 0\n> GET key\n\"value\"             # 没有改变 \n```\n\n- **计数**\n\n如果 value 是一个整数，还可以对它使用 `INCR` 命令进行 **原子性** 的自增操作，这意味着及时多个客户端对同一个 key 进行操作，也决不会导致竞争的情况：\n\n```\n> SET counter 100\n> INCR counter\n(integer) 101\n> INCRBY counter 50\n(integer) 151\n```\n\n#### 2. list\n\n> Redis 的列表相当于 Java 语言中的 **LinkedList**，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。\n\n**链表的基本操作**\n\n- `LPUSH` 和 `RPUSH` 分别可以向 list 的左边（头部）和右边（尾部）添加一个新元素；\n- `LRANGE` 命令可以从 list 中取出一定范围的元素；\n- `LINDEX` 命令可以从 list 中取出指定下表的元素，相当于 Java 链表操作中的 `get(int index)` 操作；\n\n示范：\n\n```console\n> rpush mylist A\n(integer) 1\n> rpush mylist B\n(integer) 2\n> lpush mylist first\n(integer) 3\n> lrange mylist 0 -1    # -1 表示倒数第一个元素, 这里表示从第一个元素到最后一个元素，即所有\n1) \"first\"\n2) \"A\"\n3) \"B\"\n```\n\n- list 实现队列\n\n队列是先进先出的数据结构，常用于消息排队和异步逻辑处理，它会确保元素的访问顺序：\n\n```console\n> RPUSH books python java golang\n(integer) 3\n> LPOP books\n\"python\"\n> LPOP books\n\"java\"\n> LPOP books\n\"golang\"\n> LPOP books\n(nil)\n```\n\n- list 实现栈\n\n栈是先进后出的数据结构，跟队列正好相反：\n\n```console\n> RPUSH books python java golang\n> RPOP books\n\"golang\"\n> RPOP books\n\"java\"\n> RPOP books\n\"python\"\n> RPOP books\n(nil)\n```\n\n- 使用场景举例：简单的消息队列、分页功能（lrange ）\n\n#### 3. hash\n\n> Redis 中的字典相当于 Java 中的 **HashMap**，内部实现也差不多类似，都是通过 **\"数组 + 链表\"** 的链地址法来解决部分 **哈希冲突**，同时这样的结构也吸收了两种不同数据结构的优点。\n\n- 基本操作：\n\n```\n> HSET books java \"think in java\"    # 命令行的字符串如果包含空格则需要使用引号包裹\n(integer) 1\n> HSET books python \"python cookbook\"\n(integer) 1\n> HGETALL books    # key 和 value 间隔出现\n1) \"java\"\n2) \"think in java\"\n3) \"python\"\n4) \"python cookbook\"\n> HGET books java\n\"think in java\"\n> HSET books java \"head first java\"  \n(integer) 0        # 因为是更新操作，所以返回 0\n> HMSET books java \"effetive  java\" python \"learning python\"    # 批量操作\nOK\n```\n\n- 使用场景举例：单点登录。存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果。\n\n#### 4. set\n\n> Redis 的集合相当于 Java 语言中的 **HashSet**，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。\n\n- 基本操作：\n\n```\n> SADD books java\n(integer) 1\n> SADD books java    # 重复\n(integer) 0\n> SADD books python golang\n(integer) 2\n> SMEMBERS books    # 注意顺序，set 是无序的 \n1) \"java\"\n2) \"python\"\n3) \"golang\"\n> SISMEMBER books java    # 查询某个 value 是否存在，相当于 contains\n(integer) 1\n> SCARD books    # 获取长度\n(integer) 3\n> SPOP books     # 弹出一个\n\"java\"\n```\n\n- 使用场景举例：全局去重、计算共同喜好等\n\n#### 5. zset\n\n> 这可能使 Redis 最具特色的一个数据结构了，它类似于 Java 中 **SortedSet** 和 **HashMap** 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。它的内部实现用的是一种叫做 **「跳跃表」** 的数据结构。\n\n- 基本操作\n\n```\n> ZADD books 9.0 \"think in java\"\n> ZADD books 8.9 \"java concurrency\"\n> ZADD books 8.6 \"java cookbook\"\n\n> ZRANGE books 0 -1     # 按 score 排序列出，参数区间为排名范围\n1) \"java cookbook\"\n2) \"java concurrency\"\n3) \"think in java\"\n\n> ZREVRANGE books 0 -1  # 按 score 逆序列出，参数区间为排名范围\n1) \"think in java\"\n2) \"java concurrency\"\n3) \"java cookbook\"\n\n> ZCARD books           # 相当于 count()\n(integer) 3\n\n> ZSCORE books \"java concurrency\"   # 获取指定 value 的 score\n\"8.9000000000000004\"                # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题\n\n> ZRANK books \"java concurrency\"    # 排名\n(integer) 1\n\n> ZRANGEBYSCORE books 0 8.91        # 根据分值区间遍历 zset\n1) \"java cookbook\"\n2) \"java concurrency\"\n\n> ZRANGEBYSCORE books -inf 8.91 withscores  # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite。\n1) \"java cookbook\"\n2) \"8.5999999999999996\"\n3) \"java concurrency\"\n4) \"8.9000000000000004\"\n\n> ZREM books \"java concurrency\"             # 删除 value\n(integer) 1\n> ZRANGE books 0 -1\n1) \"java cookbook\"\n2) \"think in java\"\n```\n\n- 使用场景举例：排行榜应用取 TOP N 、范围查找\n\n### 七. Redis常见问题及解决方法\n\n#### 1. 缓存与数据库双写不一致\n\n##### 什么是双写不一致？\n\n​\t\t一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是当要执行数据的更新操作的时候，数据库和缓存的数据就会出现不一致的情况。\n\n从理论上说，只要我们设置了**键的过期时间**，就能保证缓存和数据库的数据**最终一致**。\n\n##### 有哪些解决办法？\n\n- 先更新数据库，再删缓存。\n\n    如果在高并发的场景下，出现数据库与缓存数据不一致的**概率特别低**，也不是没有：\n\n    > 1、 缓存刚好失效\n    > 2、线程A查询数据库，得一个旧值\n    > 3、线程B将新值写入数据库\n    > 4、线程B删除缓存\n    > 5、线程A将查到的旧值写入缓存\n\n- 先删除缓存，再更新数据库。\n\n    并发场景下分析一下，还是有问题：\n\n    > 线程A删除了缓存\n    > 线程B查询，发现缓存已不存在\n    > 线程B去数据库查询得到旧值\n    > 线程B将旧值写入缓存\n    > 线程A将新值写入数据库\n\n- 将删除缓存、修改数据库、读取缓存等的操作积压到队列里边，实现串行化。\n\n这些方案从根本上来说，只能降低不一致发生的概率，无法完全避免。因此，**有强一致性要求的数据，不能放缓存。**\n\n#### 2. 缓存穿透\n\n##### 什么是缓存穿透？\n\n​\t\t缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：我们有一张数据库表，ID都是从1开始的，但是可能有黑客想把我们的数据库搞垮，每次请求的ID都是负数，导致缓存失去意义，请求都会去找数据库。\n\n##### 有哪些解决办法？\n\n1. 缓存无效 key\n\n    ​\t\t如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：`SET key value EX 10086`。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。如果用 Java 代码展示的话，差不多是下面这样的：\n\n```java\npublic Object getObjectInclNullById(Integer id) {\n    // 从缓存中获取数据\n    Object cacheValue = cache.get(id);\n    // 缓存为空\n    if (cacheValue == null) {\n        // 从数据库中获取\n        Object storageValue = storage.get(key);\n        // 缓存空对象\n        cache.set(key, storageValue);\n        // 如果存储数据为空，需要设置一个过期时间(300秒)\n        if (storageValue == null) {\n            // 必须设置过期时间，否则有被攻击的风险\n            cache.expire(key, 60 * 5);\n        }\n        return storageValue;\n    }\n    return cacheValue;\n}\n```\n\n2. 布隆过滤器\n\n    ​\t\t布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中，我们需要的就是判断 key 是否合法。\n\n    ​\t\t具体做法：内部维护一系列合法有效的 Key都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。\n\n    ​\t\t但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： **布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**\n\n    ****\n\n    ***布隆过滤器原理*：**  \n\n    **当一个元素加入布隆过滤器中的时候，会进行如下操作：**\n\n    1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。\n\n    2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。\n\n    **当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：**\n\n    1. 对给定元素再次进行相同的哈希计算；\n\n    2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。\n\n    然后，一定会出现这样一种情况：**不同的字符串可能哈希出来的位置相同。** （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）\n\n#### 3. 缓存雪崩\n\n##### 什么是缓存雪崩？\n\n​\t\t缓存雪崩描述的就是这样一个简单的场景：**缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。** 这就好比雪崩一样，数据库的压力可想而知，可能直接就挂了。\n\n​\t\t举个例子：系统的缓存模块出了问题比如宕机导致不可用，造成系统的所有访问，都要走数据库。\n\n​\t\t还有一种缓存雪崩的场景是：**有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。**\n\n​\t\t举个例子 ：秒杀开始12个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是12个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。\n\n##### 有哪些解决办法？\n\nRedis服务不可用：\n\n1. 采用Redis集群，避免单机出现问题整个缓存服务都没办法使用。\n2. 限流，避免同时处理大量的请求。\n\n热点缓存失效：\n\n1. 设置不同的失效时间，比如随机设置缓存的失效时间。\n2. 缓存永不失效。\n\n","source":"_posts/redis.md","raw":"---\ntitle: 高并发利器Redis\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop:\ntags:\n  - redis\ncategories:\n  - work\nabbrlink: a10a\ndate: 2021-04-15 00:00:00\nsubtitle:\n---\n\n\n\n### 一. 什么是Redis\n\n​\t\t官方简介：Redis是一个基于BSD**开源**的项目，是一个把**结构化**的数据放在**内存**中的一个存储系统，可以把它**作为数据库，缓存和消息中间件**来使用。同时支持**strings，lists，hashes，sets，sorted sets，**bitmaps，hyperloglogs、geospatial indexes和streams等**数据类型**。还内建了**复制、lua脚本、LRU、事务**、不同级别的**持久化**功能，通过redis sentinel实现**高可用**，通过redis cluster实现了**自动分片**，以及**发布/订阅**，**自动故障转移**等等特性。\n\n\n\n### 二. Redis能解决什么问题\n\n> **假如我们有个查询列表的API，用户抱怨说每次请求都要2秒左右才能返回结果，如何改善用户体验呢？**\n\n​\t\t**方案一、基于HTTP缓存**：\n\n​\t\t为API的响应头加上缓存控制 **cache-control**:max-age=600 ，即在浏览器缓存这个响应10分钟，简单粗暴。但是这个方法有两个缺点：第一个是在缓存生效的10分钟内，API消费者可能会得到旧的数据；第二个是如果客户端浏览器不使用缓存，方法直接无效。\n\n​\t\t**方案二、基于本机内存的缓存**\n\n​\t\t该API请求耗时操作主要在于使用SQL查询结果的过程中消耗了将近2秒的时间，于是，我们又想到了一个方案，把SQL查询的结果直接缓存在当前API服务器的内存中，比如使用JDK自带的**HashMap**和ConcurrentHashMap，或者**Guava Cache**、Spring Cache等本地缓存框架，设置缓存有效时间为10分钟，并且在修改和更新操作时同步修改缓存中的数据。这样后续10分钟内的请求直接读缓存，可以做到及时响应，不再花费2秒去执行SQL了。\n\n​\t\t结果其他API的小伙伴发现这是个好办法，于是很快我们就发现API服务器的内存要爆了...而且对于分布式架构，相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的。\n\n​\t\t**方案三、使用Redis做缓存**\n\n​\t\t要解决API服务器内存被缓存塞满及各服务间缓存无法共享的问题，最直接的办法就是把这些缓存部署在一台单独的服务器上，即使同一个相同的服务部署在再多机器上，也是使用的同一份缓存。于是我们需要为分布式缓存引入额外的服务，比如 Redis 或Memcached，而且要保证服务的高可用。\n\n#### Redis主要应用场景\n\n​\t\t缓存（数据查询、短连接、新闻内容、商品内容等）、分布式会话（Session）、任务队列（秒杀、抢购、12306等）、应用排行榜、访问统计、数据过期处理（可以精确到毫秒）。\n\n### 三. Redis 和 Memcached 的区别和共同点\n\n- **共同点** ：\n\n1. 都是基于内存的缓存。\n2. 都有过期策略。\n3. 两者的性能都非常高。\n\n- **区别** ：\n\n1. **Redis 支持更丰富的数据类型（支持更复杂的应用场景）**。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。\n2. **Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存之中。**\n3. **Redis 有灾难恢复机制。** 因为可以把缓存中的数据持久化到磁盘上。\n4. **Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。**\n5. **Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。**\n6. **Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。** （Redis 6.0 引入了多线程 IO ）\n7. **Redis 支持发布订阅模型、Lua脚本、事务等功能，而Memcached不支持。并且，Redis支持更多的编程语言。**\n\n\n\n### 四. 安装和配置\n\n#### 1. 安装：略\n\n#### 2. 主要配置：\n\n​\tLinux下配置文件为redis.conf，Windows下配置文件为redis.windows.conf\n\n- 开启持久化，配置文件装中添加如下内容：\n\n    ```\n    appendonly yes\n    ```\n\n- port：端口配置项，查看和设置Redis监听端口，默认端口为6379。\n- bind：主机地址配置项，查看和绑定的主机地址，默认地址的值为127.0.0.1。这个选项，在单网卡的机器上，一般不需要修改。\n\n- timeout：连接空闲多长要关闭连接，表示客户端闲置一段时间后，要关闭连接。如果指定为0，表示时长不限制。这个选项的默认值为0，表示默认不限制连接的空闲时长\n\n- dbfilename：指定保存缓存数据库的本地文件名，默认值为dump.rdb。\n\n- dir：指定保存缓存数据的本地文件所存放的目录，默认值为安装目录。\n\n- rdbcompression：指定存储至本地数据库时是否压缩数据，默认为yes,Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变得巨大。\n\n- save：指定在多长时间内，有多少次Key-Value更新操作，就将数据同步到本地数据库文件，可以设置多个条件。save配置项的格式为save<seconds><changes>:seconds表示时间段的长度，changes表示变化的次数。如设置为900秒（15分钟）内有1个更改，则同步到文件：\n\n    ```\n    127.0.0.1:6379> config set save \"900 1\"\n    OK\n    127.0.0.1:6379> config get save\n    1) \"save\"\n    2) \"900 1\"\n    ```\n\n- requirepass：设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认这个选项是关闭的。\n\n- slaveof：在主从复制的模式下，设置当前节点为slave（从）节点时，设置master（主）节点的IP地址及端口，在Redis启动时，它会自动从master（主）节点进行数据同步。如果已经是slave（从）服务器，则会丢掉旧数据集，从新的master主服务器同步缓存数据。格式为：\n\n    ```\n    slaveof<masterip><masterport>\n    ```\n\n- masterauth：在主从复制的模式下，当master（主）服务器节点设置了密码保护时，slave（从）服务器连接master（主）服务器的密码。格式为:\n\n    ```\n    masterauth<master-password>\n    ```\n\n- databases：设置缓存数据库的数量，默认数据库数量为16个。这16个数据库的id为0-15，默认使用的数据库是第0个。可以使用SELECT <dbid>命令在连接时通过数据库id来指定要使用的数据库。\n\n#### 3. Redis连接客户端命令：\n\n```\n#redis-cli -h host -p port -a password\n```\n\n本地连接：\n\n```\nroot@0912b31c4171# redis-cli\n```\n\n\n\n### 五. Redis的主要特点\n\n#### 1. 速度异常快 \n\n​\t\t采用多路 IO 复用模型，不需要等待磁盘的IO，在内存之间进行的数据存储和查询，速度非常快。官方数据显示每秒可执行大约 110000 次的设置(SET)操作，每秒大约可执行 81000 次的读取/获取(GET)操作。可以运行命令 `redis-benchmark -n 100000 -q` 来检测本地同时执行 10 万个请求时的性能：\n\n```\nroot@0912b31c4171:/data# redis-benchmark -n 100000 -q\nPING_INLINE: 31172.07 requests per second\nPING_BULK: 31615.55 requests per second\nSET: 30432.14 requests per second\nGET: 31289.11 requests per second\nINCR: 30441.40 requests per second\nLPUSH: 29550.83 requests per second\nRPUSH: 30184.12 requests per second\n```\n\n#### 2. 丰富的数据结构 \n\n​\t\t除了string之外，还有list、hash、set、sortedset、bitmaps、hyperloglogs、geospatial indexes和stream。其中**string(字符串)**、**list(列表)**、**hash(字典)**、**set(集合)** 和 **zset(有序集合)**这 5 种是 Redis 最基础、最重要的部分。\n\n#### 3. 单线程\n\n​\t\t避免了频繁的上下文切换。Redis 内部使用文件事件处理器 `file event handler`，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。\n\n文件事件处理器的结构包含 4 个部分：\n\n- 多个 socket\n\n- IO 多路复用程序\n\n- 文件事件分派器\n\n- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）\n\n    ​\t\t多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。\n\n    ***传统的并发模型，每个 I/O 流都有一个新的线程管理***\n\n     ***I/O 多路复用，只有单个线程，通过跟踪每个 I/O 流的状态，来管理多个 I/O 流。***\n\n#### 4. 可持久化 \n\n​\t\t支持RDB与AOF两种方式，将内存中的数据写入外部的物理存储设备。\n\n​\t\t**RDB**(Redis DataBase)：是最简单的 Redis 持久性模式。当满足特定条件时，它将生成数据集的时间点**快照**，例如，如果先前的快照是在2分钟前创建的，并且现在已经至少有 *100* 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 `.rdb` 文件生成。\n\n​\t\t**AOF** (Append Only File - 仅追加文件)：它的工作方式非常简单：每次执行 **修改内存** 中数据集的写操作时，都会 **记录** 该操作。假设 AOF 日志记录了自 Redis 实例创建以来 **所有的修改性指令序列**，那么就可以通过对一个空的 Redis 实例 **顺序执行所有的指令**，也就是 **「重放」**，来恢复 Redis 当前实例的内存数据结构的状态。\n\n​\t\t**RDB优势**\n\n- RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。\n\n- 生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。\n\n- RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。\n\n​\t\t**RDB劣势**\n\n- RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。\n\n​\t\t**AOF优势**\n\n- AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。（2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。\n\n- AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。\n\n- AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据\n\n​\t\t**AOF劣势**\n\n- 对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大\n\n- AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的\n\n- 以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。\n\n#### 5. 支持发布、订阅、管道。\n\n​\t\t**发布/ 订阅系统** 是 Web 系统中比较常用的一个功能。简单点说就是 **发布者发布消息，订阅者接受消息**，这有点类似于我们的报纸/ 杂志社之类的。我们可以使用redis的一个 `list` 列表结构结合 `lpush` 和 `rpop` 来实现消息队列的功能，但是似乎很难实现实现 **消息多播** 的功能：\n\n![image](https://tvax2.sinaimg.cn/large/006YzKDNly1gopdit62wmj30yg0ccgmp.jpg)\n\n​\t\t**Redis**为了消除`Publisher` 与 `Consumer` 的强关联，支持消息多播，引入了另一种概念：**频道** *(channel)*：\n\n![image](https://tvax1.sinaimg.cn/large/006YzKDNly1gopdjtvehij30yg0cbmy0.jpg)\n\n当 `Publisher` 往 `channel` 中发布消息时，关注了指定 `channel` 的 `Consumer` 就能够同时受到消息。但这里的 **问题** 是，消费者订阅一个频道是必须 **明确指定频道名称** 的，这意味着，如果我们想要 **订阅多个** 频道，那么就必须 **显式地关注多个** 名称。\n\n为了简化订阅的繁琐操作，**Redis** 提供了 **模式订阅** 的功能 **Pattern Subscribe**，这样就可以 **一次性关注多个频道** 了，即使生产者新增了同模式的频道，消费者也可以立即受到消息：\n\n![image](https://tvax2.sinaimg.cn/large/006YzKDNly1gopdkll7gtj30yg0cb0ul.jpg)\n\n例如上图中，**所有** 位于图片下方的 **`Consumer` 都能够受到消息**。\n\n`Publisher` 往 `wmyskxz.chat` 这个 `channel` 中发送了一条消息，不仅仅关注了这个频道的 `Consumer 1` 和 `Consumer 2` 能够受到消息，图片中的两个 `channel` 都和模式 `wmyskxz.*` 匹配，所以 **Redis** 此时会同样发送消息给订阅了 `wmyskxz.*` 这个模式的 `Consumer 3` 和关注了在这个模式下的另一个频道 `wmyskxz.log` 下的 `Consumer 4` 和 `Consumer 5`。\n\n另一方面，如果接收消息的频道是 `wmyskxz.chat`，那么 `Consumer 3` 也会受到消息。  \n\n##### *快速体验*\n\n在 **Redis** 中，**PubSub** 模块的使用非常简单，常用的命令也就下面这么几条：\n\n```bash\n# 订阅频道：\nSUBSCRIBE channel [channel ....]   # 订阅给定的一个或多个频道的信息\nPSUBSCRIBE pattern [pattern ....]  # 订阅一个或多个符合给定模式的频道\n# 发布频道：\nPUBLISH channel message  # 将消息发送到指定的频道\n# 退订频道：\nUNSUBSCRIBE [channel [channel ....]]   # 退订指定的频道\nPUNSUBSCRIBE [pattern [pattern ....]]  #退订所有给定模式的频道\n```\n\n我们可以在本地快速地来体验一下 **PubSub**：\n\n![](https://tvax2.sinaimg.cn/large/006YzKDNly1gopdlahl8sg30qq0cenpg.gif)\n\n具体步骤如下：\n\n1. 开启本地 Redis 服务，新建两个控制台窗口；\n2. 在其中一个窗口输入 `SUBSCRIBE wmyskxz.chat` 关注 `wmyskxz.chat` 频道，让这个窗口成为 **消费者**。\n3. 在另一个窗口输入 `PUBLISH wmyskxz.chat 'message'` 往这个频道发送消息，这个时候就会看到 **另一个窗口实时地出现** 了发送的测试消息。\n\n#### 6. 支持分布式锁 \n\n​\t\t在分布式系统中，如果不同的节点需要访同到一个资源，往往需要通过互斥机制来防止彼此干扰，并且保证数据的一致性。在这种情况下，需要使用到分布式锁。分布式锁和Java的锁用于实现不同线程之间的同步访问，原理上是类似的。\n\n#### 7.支持原子操作和事务\n\n​\t\tRedis事务是一组命令的集合。一个事务中的命令要么都执行，要么都不执行。如果命令在运行期间出现错误，不会自动回滚。\n\n#### 8.支持主-从（Master-Slave）复制与高可用（Redis Sentinel）集群\n\n​\t\t3.0版本以上功能\n\n\n\n### 六.常见数据结构及使用操作\n\n*一般情况下是这样设计 key 的： `表名:列名:主键名:主键值`*\n\n#### 1. string：\n\n> 值可以是任何种类的字符串（包括二进制数据），例如你可以在一个键下保存一张 `.jpeg` 图片，需要注意不要超过 512 MB 。\n\n- **设置和获取键值对**：\n\n```\n> SET key value\nOK\n> GET key\n\"value\"\n```\n\n当 key 存在时，`SET` 命令会覆盖掉你上一次设置的值：\n\n```\n> SET key newValue\nOK\n> GET key\n\"newValue\"\n```\n\n另外还可以使用 `EXISTS` 和 `DEL` 关键字来查询是否存在和删除键值对：\n\n```\n> EXISTS key\n(integer) 1\n> DEL key\n(integer) 1\n> GET key\n(nil)\n```\n\n- **批量设置键值对**\n\n```\n> SET key1 value1\nOK\n> SET key2 value2\nOK\n> MGET key1 key2 key3    # 返回一个列表\n1) \"value1\"\n2) \"value2\"\n3) (nil)\n> MSET key1 value1 key2 value2\n> MGET key1 key2\n1) \"value1\"\n2) \"value2\"\n```\n\n- **过期和 SET 命令扩展**\n\n可以对 key 设置过期时间，到时间会被自动删除，这个功能常用来控制缓存的失效时间。*(过期可以是任意数据结构)*\n\n```\n> SET key value1\n> GET key\n\"value1\"\n> EXPIRE name 5    # 5s 后过期\n...                # 等待 5s\n> GET key\n(nil)\n```\n\n等价于 `SET` + `EXPIRE` 的 `SETEX` 命令：\n\n```\n> SETEX key 5 value1\n...                # 等待 5s 后获取\n> GET key\n(nil)\n\n> SETNX key value1  # 如果 key 不存在则 SET 成功\n(integer) 1\n> SETNX key value1  # 如果 key 存在则 SET 失败\n(integer) 0\n> GET key\n\"value\"             # 没有改变 \n```\n\n- **计数**\n\n如果 value 是一个整数，还可以对它使用 `INCR` 命令进行 **原子性** 的自增操作，这意味着及时多个客户端对同一个 key 进行操作，也决不会导致竞争的情况：\n\n```\n> SET counter 100\n> INCR counter\n(integer) 101\n> INCRBY counter 50\n(integer) 151\n```\n\n#### 2. list\n\n> Redis 的列表相当于 Java 语言中的 **LinkedList**，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。\n\n**链表的基本操作**\n\n- `LPUSH` 和 `RPUSH` 分别可以向 list 的左边（头部）和右边（尾部）添加一个新元素；\n- `LRANGE` 命令可以从 list 中取出一定范围的元素；\n- `LINDEX` 命令可以从 list 中取出指定下表的元素，相当于 Java 链表操作中的 `get(int index)` 操作；\n\n示范：\n\n```console\n> rpush mylist A\n(integer) 1\n> rpush mylist B\n(integer) 2\n> lpush mylist first\n(integer) 3\n> lrange mylist 0 -1    # -1 表示倒数第一个元素, 这里表示从第一个元素到最后一个元素，即所有\n1) \"first\"\n2) \"A\"\n3) \"B\"\n```\n\n- list 实现队列\n\n队列是先进先出的数据结构，常用于消息排队和异步逻辑处理，它会确保元素的访问顺序：\n\n```console\n> RPUSH books python java golang\n(integer) 3\n> LPOP books\n\"python\"\n> LPOP books\n\"java\"\n> LPOP books\n\"golang\"\n> LPOP books\n(nil)\n```\n\n- list 实现栈\n\n栈是先进后出的数据结构，跟队列正好相反：\n\n```console\n> RPUSH books python java golang\n> RPOP books\n\"golang\"\n> RPOP books\n\"java\"\n> RPOP books\n\"python\"\n> RPOP books\n(nil)\n```\n\n- 使用场景举例：简单的消息队列、分页功能（lrange ）\n\n#### 3. hash\n\n> Redis 中的字典相当于 Java 中的 **HashMap**，内部实现也差不多类似，都是通过 **\"数组 + 链表\"** 的链地址法来解决部分 **哈希冲突**，同时这样的结构也吸收了两种不同数据结构的优点。\n\n- 基本操作：\n\n```\n> HSET books java \"think in java\"    # 命令行的字符串如果包含空格则需要使用引号包裹\n(integer) 1\n> HSET books python \"python cookbook\"\n(integer) 1\n> HGETALL books    # key 和 value 间隔出现\n1) \"java\"\n2) \"think in java\"\n3) \"python\"\n4) \"python cookbook\"\n> HGET books java\n\"think in java\"\n> HSET books java \"head first java\"  \n(integer) 0        # 因为是更新操作，所以返回 0\n> HMSET books java \"effetive  java\" python \"learning python\"    # 批量操作\nOK\n```\n\n- 使用场景举例：单点登录。存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果。\n\n#### 4. set\n\n> Redis 的集合相当于 Java 语言中的 **HashSet**，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。\n\n- 基本操作：\n\n```\n> SADD books java\n(integer) 1\n> SADD books java    # 重复\n(integer) 0\n> SADD books python golang\n(integer) 2\n> SMEMBERS books    # 注意顺序，set 是无序的 \n1) \"java\"\n2) \"python\"\n3) \"golang\"\n> SISMEMBER books java    # 查询某个 value 是否存在，相当于 contains\n(integer) 1\n> SCARD books    # 获取长度\n(integer) 3\n> SPOP books     # 弹出一个\n\"java\"\n```\n\n- 使用场景举例：全局去重、计算共同喜好等\n\n#### 5. zset\n\n> 这可能使 Redis 最具特色的一个数据结构了，它类似于 Java 中 **SortedSet** 和 **HashMap** 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。它的内部实现用的是一种叫做 **「跳跃表」** 的数据结构。\n\n- 基本操作\n\n```\n> ZADD books 9.0 \"think in java\"\n> ZADD books 8.9 \"java concurrency\"\n> ZADD books 8.6 \"java cookbook\"\n\n> ZRANGE books 0 -1     # 按 score 排序列出，参数区间为排名范围\n1) \"java cookbook\"\n2) \"java concurrency\"\n3) \"think in java\"\n\n> ZREVRANGE books 0 -1  # 按 score 逆序列出，参数区间为排名范围\n1) \"think in java\"\n2) \"java concurrency\"\n3) \"java cookbook\"\n\n> ZCARD books           # 相当于 count()\n(integer) 3\n\n> ZSCORE books \"java concurrency\"   # 获取指定 value 的 score\n\"8.9000000000000004\"                # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题\n\n> ZRANK books \"java concurrency\"    # 排名\n(integer) 1\n\n> ZRANGEBYSCORE books 0 8.91        # 根据分值区间遍历 zset\n1) \"java cookbook\"\n2) \"java concurrency\"\n\n> ZRANGEBYSCORE books -inf 8.91 withscores  # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite。\n1) \"java cookbook\"\n2) \"8.5999999999999996\"\n3) \"java concurrency\"\n4) \"8.9000000000000004\"\n\n> ZREM books \"java concurrency\"             # 删除 value\n(integer) 1\n> ZRANGE books 0 -1\n1) \"java cookbook\"\n2) \"think in java\"\n```\n\n- 使用场景举例：排行榜应用取 TOP N 、范围查找\n\n### 七. Redis常见问题及解决方法\n\n#### 1. 缓存与数据库双写不一致\n\n##### 什么是双写不一致？\n\n​\t\t一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是当要执行数据的更新操作的时候，数据库和缓存的数据就会出现不一致的情况。\n\n从理论上说，只要我们设置了**键的过期时间**，就能保证缓存和数据库的数据**最终一致**。\n\n##### 有哪些解决办法？\n\n- 先更新数据库，再删缓存。\n\n    如果在高并发的场景下，出现数据库与缓存数据不一致的**概率特别低**，也不是没有：\n\n    > 1、 缓存刚好失效\n    > 2、线程A查询数据库，得一个旧值\n    > 3、线程B将新值写入数据库\n    > 4、线程B删除缓存\n    > 5、线程A将查到的旧值写入缓存\n\n- 先删除缓存，再更新数据库。\n\n    并发场景下分析一下，还是有问题：\n\n    > 线程A删除了缓存\n    > 线程B查询，发现缓存已不存在\n    > 线程B去数据库查询得到旧值\n    > 线程B将旧值写入缓存\n    > 线程A将新值写入数据库\n\n- 将删除缓存、修改数据库、读取缓存等的操作积压到队列里边，实现串行化。\n\n这些方案从根本上来说，只能降低不一致发生的概率，无法完全避免。因此，**有强一致性要求的数据，不能放缓存。**\n\n#### 2. 缓存穿透\n\n##### 什么是缓存穿透？\n\n​\t\t缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：我们有一张数据库表，ID都是从1开始的，但是可能有黑客想把我们的数据库搞垮，每次请求的ID都是负数，导致缓存失去意义，请求都会去找数据库。\n\n##### 有哪些解决办法？\n\n1. 缓存无效 key\n\n    ​\t\t如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：`SET key value EX 10086`。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。如果用 Java 代码展示的话，差不多是下面这样的：\n\n```java\npublic Object getObjectInclNullById(Integer id) {\n    // 从缓存中获取数据\n    Object cacheValue = cache.get(id);\n    // 缓存为空\n    if (cacheValue == null) {\n        // 从数据库中获取\n        Object storageValue = storage.get(key);\n        // 缓存空对象\n        cache.set(key, storageValue);\n        // 如果存储数据为空，需要设置一个过期时间(300秒)\n        if (storageValue == null) {\n            // 必须设置过期时间，否则有被攻击的风险\n            cache.expire(key, 60 * 5);\n        }\n        return storageValue;\n    }\n    return cacheValue;\n}\n```\n\n2. 布隆过滤器\n\n    ​\t\t布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中，我们需要的就是判断 key 是否合法。\n\n    ​\t\t具体做法：内部维护一系列合法有效的 Key都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。\n\n    ​\t\t但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： **布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**\n\n    ****\n\n    ***布隆过滤器原理*：**  \n\n    **当一个元素加入布隆过滤器中的时候，会进行如下操作：**\n\n    1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。\n\n    2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。\n\n    **当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：**\n\n    1. 对给定元素再次进行相同的哈希计算；\n\n    2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。\n\n    然后，一定会出现这样一种情况：**不同的字符串可能哈希出来的位置相同。** （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）\n\n#### 3. 缓存雪崩\n\n##### 什么是缓存雪崩？\n\n​\t\t缓存雪崩描述的就是这样一个简单的场景：**缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。** 这就好比雪崩一样，数据库的压力可想而知，可能直接就挂了。\n\n​\t\t举个例子：系统的缓存模块出了问题比如宕机导致不可用，造成系统的所有访问，都要走数据库。\n\n​\t\t还有一种缓存雪崩的场景是：**有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。**\n\n​\t\t举个例子 ：秒杀开始12个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是12个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。\n\n##### 有哪些解决办法？\n\nRedis服务不可用：\n\n1. 采用Redis集群，避免单机出现问题整个缓存服务都没办法使用。\n2. 限流，避免同时处理大量的请求。\n\n热点缓存失效：\n\n1. 设置不同的失效时间，比如随机设置缓存的失效时间。\n2. 缓存永不失效。\n\n","slug":"redis","published":1,"updated":"2021-12-10T09:48:33.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1b1000xacbf6mwm4aid","content":"<h3 id=\"一-什么是Redis\"><a href=\"#一-什么是Redis\" class=\"headerlink\" title=\"一. 什么是Redis\"></a>一. 什么是Redis</h3><p>​        官方简介：Redis是一个基于BSD<strong>开源</strong>的项目，是一个把<strong>结构化</strong>的数据放在<strong>内存</strong>中的一个存储系统，可以把它<strong>作为数据库，缓存和消息中间件</strong>来使用。同时支持<strong>strings，lists，hashes，sets，sorted sets，</strong>bitmaps，hyperloglogs、geospatial indexes和streams等<strong>数据类型</strong>。还内建了<strong>复制、lua脚本、LRU、事务</strong>、不同级别的<strong>持久化</strong>功能，通过redis sentinel实现<strong>高可用</strong>，通过redis cluster实现了<strong>自动分片</strong>，以及<strong>发布/订阅</strong>，<strong>自动故障转移</strong>等等特性。</p>\n<h3 id=\"二-Redis能解决什么问题\"><a href=\"#二-Redis能解决什么问题\" class=\"headerlink\" title=\"二. Redis能解决什么问题\"></a>二. Redis能解决什么问题</h3><blockquote>\n<p><strong>假如我们有个查询列表的API，用户抱怨说每次请求都要2秒左右才能返回结果，如何改善用户体验呢？</strong></p>\n</blockquote>\n<p>​        <strong>方案一、基于HTTP缓存</strong>：</p>\n<p>​        为API的响应头加上缓存控制 <strong>cache-control</strong>:max-age=600 ，即在浏览器缓存这个响应10分钟，简单粗暴。但是这个方法有两个缺点：第一个是在缓存生效的10分钟内，API消费者可能会得到旧的数据；第二个是如果客户端浏览器不使用缓存，方法直接无效。</p>\n<p>​        <strong>方案二、基于本机内存的缓存</strong></p>\n<p>​        该API请求耗时操作主要在于使用SQL查询结果的过程中消耗了将近2秒的时间，于是，我们又想到了一个方案，把SQL查询的结果直接缓存在当前API服务器的内存中，比如使用JDK自带的<strong>HashMap</strong>和ConcurrentHashMap，或者<strong>Guava Cache</strong>、Spring Cache等本地缓存框架，设置缓存有效时间为10分钟，并且在修改和更新操作时同步修改缓存中的数据。这样后续10分钟内的请求直接读缓存，可以做到及时响应，不再花费2秒去执行SQL了。</p>\n<p>​        结果其他API的小伙伴发现这是个好办法，于是很快我们就发现API服务器的内存要爆了…而且对于分布式架构，相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的。</p>\n<p>​        <strong>方案三、使用Redis做缓存</strong></p>\n<p>​        要解决API服务器内存被缓存塞满及各服务间缓存无法共享的问题，最直接的办法就是把这些缓存部署在一台单独的服务器上，即使同一个相同的服务部署在再多机器上，也是使用的同一份缓存。于是我们需要为分布式缓存引入额外的服务，比如 Redis 或Memcached，而且要保证服务的高可用。</p>\n<h4 id=\"Redis主要应用场景\"><a href=\"#Redis主要应用场景\" class=\"headerlink\" title=\"Redis主要应用场景\"></a>Redis主要应用场景</h4><p>​        缓存（数据查询、短连接、新闻内容、商品内容等）、分布式会话（Session）、任务队列（秒杀、抢购、12306等）、应用排行榜、访问统计、数据过期处理（可以精确到毫秒）。</p>\n<h3 id=\"三-Redis-和-Memcached-的区别和共同点\"><a href=\"#三-Redis-和-Memcached-的区别和共同点\" class=\"headerlink\" title=\"三. Redis 和 Memcached 的区别和共同点\"></a>三. Redis 和 Memcached 的区别和共同点</h3><ul>\n<li><strong>共同点</strong> ：</li>\n</ul>\n<ol>\n<li>都是基于内存的缓存。</li>\n<li>都有过期策略。</li>\n<li>两者的性能都非常高。</li>\n</ol>\n<ul>\n<li><strong>区别</strong> ：</li>\n</ul>\n<ol>\n<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li>\n<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存之中。</strong></li>\n<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>\n<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>\n<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li>\n<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li>\n<li><strong>Redis 支持发布订阅模型、Lua脚本、事务等功能，而Memcached不支持。并且，Redis支持更多的编程语言。</strong></li>\n</ol>\n<h3 id=\"四-安装和配置\"><a href=\"#四-安装和配置\" class=\"headerlink\" title=\"四. 安装和配置\"></a>四. 安装和配置</h3><h4 id=\"1-安装：略\"><a href=\"#1-安装：略\" class=\"headerlink\" title=\"1. 安装：略\"></a>1. 安装：略</h4><h4 id=\"2-主要配置：\"><a href=\"#2-主要配置：\" class=\"headerlink\" title=\"2. 主要配置：\"></a>2. 主要配置：</h4><p>​    Linux下配置文件为redis.conf，Windows下配置文件为redis.windows.conf</p>\n<ul>\n<li><p>开启持久化，配置文件装中添加如下内容：</p>\n  <figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">appendonly</span> <span class=\"literal\">yes</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>port：端口配置项，查看和设置Redis监听端口，默认端口为6379。</p>\n</li>\n<li><p>bind：主机地址配置项，查看和绑定的主机地址，默认地址的值为127.0.0.1。这个选项，在单网卡的机器上，一般不需要修改。</p>\n</li>\n<li><p>timeout：连接空闲多长要关闭连接，表示客户端闲置一段时间后，要关闭连接。如果指定为0，表示时长不限制。这个选项的默认值为0，表示默认不限制连接的空闲时长</p>\n</li>\n<li><p>dbfilename：指定保存缓存数据库的本地文件名，默认值为dump.rdb。</p>\n</li>\n<li><p>dir：指定保存缓存数据的本地文件所存放的目录，默认值为安装目录。</p>\n</li>\n<li><p>rdbcompression：指定存储至本地数据库时是否压缩数据，默认为yes,Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变得巨大。</p>\n</li>\n<li><p>save：指定在多长时间内，有多少次Key-Value更新操作，就将数据同步到本地数据库文件，可以设置多个条件。save配置项的格式为save<seconds><changes>:seconds表示时间段的长度，changes表示变化的次数。如设置为900秒（15分钟）内有1个更改，则同步到文件：</p>\n  <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt;<span class=\"built_in\"> config </span><span class=\"builtin-name\">set</span> save <span class=\"string\">\"900 1\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt;<span class=\"built_in\"> config </span><span class=\"builtin-name\">get</span> save</span><br><span class=\"line\">1) <span class=\"string\">\"save\"</span></span><br><span class=\"line\">2) <span class=\"string\">\"900 1\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>requirepass：设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认这个选项是关闭的。</p>\n</li>\n<li><p>slaveof：在主从复制的模式下，设置当前节点为slave（从）节点时，设置master（主）节点的IP地址及端口，在Redis启动时，它会自动从master（主）节点进行数据同步。如果已经是slave（从）服务器，则会丢掉旧数据集，从新的master主服务器同步缓存数据。格式为：</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slaveof<span class=\"tag\">&lt;<span class=\"name\">masterip</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">masterport</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>masterauth：在主从复制的模式下，当master（主）服务器节点设置了密码保护时，slave（从）服务器连接master（主）服务器的密码。格式为:</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">masterauth<span class=\"tag\">&lt;<span class=\"name\">master-password</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>databases：设置缓存数据库的数量，默认数据库数量为16个。这16个数据库的id为0-15，默认使用的数据库是第0个。可以使用SELECT <dbid>命令在连接时通过数据库id来指定要使用的数据库。</p>\n</li>\n</ul>\n<h4 id=\"3-Redis连接客户端命令：\"><a href=\"#3-Redis连接客户端命令：\" class=\"headerlink\" title=\"3. Redis连接客户端命令：\"></a>3. Redis连接客户端命令：</h4><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#redis-cli</span> -h host -<span class=\"selector-tag\">p</span> port -<span class=\"selector-tag\">a</span> password</span><br></pre></td></tr></table></figure>\n\n<p>本地连接：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">root@</span><span class=\"number\">0912</span>b31c4171# redis-cli</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"五-Redis的主要特点\"><a href=\"#五-Redis的主要特点\" class=\"headerlink\" title=\"五. Redis的主要特点\"></a>五. Redis的主要特点</h3><h4 id=\"1-速度异常快\"><a href=\"#1-速度异常快\" class=\"headerlink\" title=\"1. 速度异常快\"></a>1. 速度异常快</h4><p>​        采用多路 IO 复用模型，不需要等待磁盘的IO，在内存之间进行的数据存储和查询，速度非常快。官方数据显示每秒可执行大约 110000 次的设置(SET)操作，每秒大约可执行 81000 次的读取/获取(GET)操作。可以运行命令 <code>redis-benchmark -n 100000 -q</code> 来检测本地同时执行 10 万个请求时的性能：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">root@0912b31c4171:/data#</span> <span class=\"string\">redis-benchmark</span> <span class=\"string\">-n</span> <span class=\"number\">100000</span> <span class=\"string\">-q</span></span><br><span class=\"line\"><span class=\"attr\">PING_INLINE:</span> <span class=\"number\">31172.07</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">PING_BULK:</span> <span class=\"number\">31615.55</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">SET:</span> <span class=\"number\">30432.14</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">GET:</span> <span class=\"number\">31289.11</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">INCR:</span> <span class=\"number\">30441.40</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">LPUSH:</span> <span class=\"number\">29550.83</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">RPUSH:</span> <span class=\"number\">30184.12</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-丰富的数据结构\"><a href=\"#2-丰富的数据结构\" class=\"headerlink\" title=\"2. 丰富的数据结构\"></a>2. 丰富的数据结构</h4><p>​        除了string之外，还有list、hash、set、sortedset、bitmaps、hyperloglogs、geospatial indexes和stream。其中<strong>string(字符串)</strong>、<strong>list(列表)</strong>、<strong>hash(字典)</strong>、<strong>set(集合)</strong> 和 <strong>zset(有序集合)</strong>这 5 种是 Redis 最基础、最重要的部分。</p>\n<h4 id=\"3-单线程\"><a href=\"#3-单线程\" class=\"headerlink\" title=\"3. 单线程\"></a>3. 单线程</h4><p>​        避免了频繁的上下文切换。Redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p>\n<p>文件事件处理器的结构包含 4 个部分：</p>\n<ul>\n<li><p>多个 socket</p>\n</li>\n<li><p>IO 多路复用程序</p>\n</li>\n<li><p>文件事件分派器</p>\n</li>\n<li><p>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</p>\n<p>  ​        多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>\n<p>  <strong><em>传统的并发模型，每个 I/O 流都有一个新的线程管理</em></strong></p>\n<p>   <strong><em>I/O 多路复用，只有单个线程，通过跟踪每个 I/O 流的状态，来管理多个 I/O 流。</em></strong></p>\n</li>\n</ul>\n<h4 id=\"4-可持久化\"><a href=\"#4-可持久化\" class=\"headerlink\" title=\"4. 可持久化\"></a>4. 可持久化</h4><p>​        支持RDB与AOF两种方式，将内存中的数据写入外部的物理存储设备。</p>\n<p>​        <strong>RDB</strong>(Redis DataBase)：是最简单的 Redis 持久性模式。当满足特定条件时，它将生成数据集的时间点<strong>快照</strong>，例如，如果先前的快照是在2分钟前创建的，并且现在已经至少有 <em>100</em> 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 <code>.rdb</code> 文件生成。</p>\n<p>​        <strong>AOF</strong> (Append Only File - 仅追加文件)：它的工作方式非常简单：每次执行 <strong>修改内存</strong> 中数据集的写操作时，都会 <strong>记录</strong> 该操作。假设 AOF 日志记录了自 Redis 实例创建以来 <strong>所有的修改性指令序列</strong>，那么就可以通过对一个空的 Redis 实例 <strong>顺序执行所有的指令</strong>，也就是 <strong>「重放」</strong>，来恢复 Redis 当前实例的内存数据结构的状态。</p>\n<p>​        <strong>RDB优势</strong></p>\n<ul>\n<li><p>RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</p>\n</li>\n<li><p>生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p>\n</li>\n<li><p>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p>\n</li>\n</ul>\n<p>​        <strong>RDB劣势</strong></p>\n<ul>\n<li>RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</li>\n</ul>\n<p>​        <strong>AOF优势</strong></p>\n<ul>\n<li><p>AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。（2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</p>\n</li>\n<li><p>AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</p>\n</li>\n<li><p>AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p>\n</li>\n</ul>\n<p>​        <strong>AOF劣势</strong></p>\n<ul>\n<li><p>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</p>\n</li>\n<li><p>AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</p>\n</li>\n<li><p>以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。</p>\n</li>\n</ul>\n<h4 id=\"5-支持发布、订阅、管道。\"><a href=\"#5-支持发布、订阅、管道。\" class=\"headerlink\" title=\"5. 支持发布、订阅、管道。\"></a>5. 支持发布、订阅、管道。</h4><p>​        <strong>发布/ 订阅系统</strong> 是 Web 系统中比较常用的一个功能。简单点说就是 <strong>发布者发布消息，订阅者接受消息</strong>，这有点类似于我们的报纸/ 杂志社之类的。我们可以使用redis的一个 <code>list</code> 列表结构结合 <code>lpush</code> 和 <code>rpop</code> 来实现消息队列的功能，但是似乎很难实现实现 <strong>消息多播</strong> 的功能：</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gopdit62wmj30yg0ccgmp.jpg\" alt=\"image\"></p>\n<p>​        <strong>Redis</strong>为了消除<code>Publisher</code> 与 <code>Consumer</code> 的强关联，支持消息多播，引入了另一种概念：<strong>频道</strong> <em>(channel)</em>：</p>\n<p><img src=\"https://tvax1.sinaimg.cn/large/006YzKDNly1gopdjtvehij30yg0cbmy0.jpg\" alt=\"image\"></p>\n<p>当 <code>Publisher</code> 往 <code>channel</code> 中发布消息时，关注了指定 <code>channel</code> 的 <code>Consumer</code> 就能够同时受到消息。但这里的 <strong>问题</strong> 是，消费者订阅一个频道是必须 <strong>明确指定频道名称</strong> 的，这意味着，如果我们想要 <strong>订阅多个</strong> 频道，那么就必须 <strong>显式地关注多个</strong> 名称。</p>\n<p>为了简化订阅的繁琐操作，<strong>Redis</strong> 提供了 <strong>模式订阅</strong> 的功能 <strong>Pattern Subscribe</strong>，这样就可以 <strong>一次性关注多个频道</strong> 了，即使生产者新增了同模式的频道，消费者也可以立即受到消息：</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gopdkll7gtj30yg0cb0ul.jpg\" alt=\"image\"></p>\n<p>例如上图中，<strong>所有</strong> 位于图片下方的 <strong><code>Consumer</code> 都能够受到消息</strong>。</p>\n<p><code>Publisher</code> 往 <code>wmyskxz.chat</code> 这个 <code>channel</code> 中发送了一条消息，不仅仅关注了这个频道的 <code>Consumer 1</code> 和 <code>Consumer 2</code> 能够受到消息，图片中的两个 <code>channel</code> 都和模式 <code>wmyskxz.*</code> 匹配，所以 <strong>Redis</strong> 此时会同样发送消息给订阅了 <code>wmyskxz.*</code> 这个模式的 <code>Consumer 3</code> 和关注了在这个模式下的另一个频道 <code>wmyskxz.log</code> 下的 <code>Consumer 4</code> 和 <code>Consumer 5</code>。</p>\n<p>另一方面，如果接收消息的频道是 <code>wmyskxz.chat</code>，那么 <code>Consumer 3</code> 也会受到消息。  </p>\n<h5 id=\"快速体验\"><a href=\"#快速体验\" class=\"headerlink\" title=\"快速体验\"></a><em>快速体验</em></h5><p>在 <strong>Redis</strong> 中，<strong>PubSub</strong> 模块的使用非常简单，常用的命令也就下面这么几条：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 订阅频道：</span></span><br><span class=\"line\">SUBSCRIBE channel [channel ....]   <span class=\"comment\"># 订阅给定的一个或多个频道的信息</span></span><br><span class=\"line\">PSUBSCRIBE pattern [pattern ....]  <span class=\"comment\"># 订阅一个或多个符合给定模式的频道</span></span><br><span class=\"line\"><span class=\"comment\"># 发布频道：</span></span><br><span class=\"line\">PUBLISH channel message  <span class=\"comment\"># 将消息发送到指定的频道</span></span><br><span class=\"line\"><span class=\"comment\"># 退订频道：</span></span><br><span class=\"line\">UNSUBSCRIBE [channel [channel ....]]   <span class=\"comment\"># 退订指定的频道</span></span><br><span class=\"line\">PUNSUBSCRIBE [pattern [pattern ....]]  <span class=\"comment\">#退订所有给定模式的频道</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以在本地快速地来体验一下 <strong>PubSub</strong>：</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gopdlahl8sg30qq0cenpg.gif\" alt=\"\"></p>\n<p>具体步骤如下：</p>\n<ol>\n<li>开启本地 Redis 服务，新建两个控制台窗口；</li>\n<li>在其中一个窗口输入 <code>SUBSCRIBE wmyskxz.chat</code> 关注 <code>wmyskxz.chat</code> 频道，让这个窗口成为 <strong>消费者</strong>。</li>\n<li>在另一个窗口输入 <code>PUBLISH wmyskxz.chat &#39;message&#39;</code> 往这个频道发送消息，这个时候就会看到 <strong>另一个窗口实时地出现</strong> 了发送的测试消息。</li>\n</ol>\n<h4 id=\"6-支持分布式锁\"><a href=\"#6-支持分布式锁\" class=\"headerlink\" title=\"6. 支持分布式锁\"></a>6. 支持分布式锁</h4><p>​        在分布式系统中，如果不同的节点需要访同到一个资源，往往需要通过互斥机制来防止彼此干扰，并且保证数据的一致性。在这种情况下，需要使用到分布式锁。分布式锁和Java的锁用于实现不同线程之间的同步访问，原理上是类似的。</p>\n<h4 id=\"7-支持原子操作和事务\"><a href=\"#7-支持原子操作和事务\" class=\"headerlink\" title=\"7.支持原子操作和事务\"></a>7.支持原子操作和事务</h4><p>​        Redis事务是一组命令的集合。一个事务中的命令要么都执行，要么都不执行。如果命令在运行期间出现错误，不会自动回滚。</p>\n<h4 id=\"8-支持主-从（Master-Slave）复制与高可用（Redis-Sentinel）集群\"><a href=\"#8-支持主-从（Master-Slave）复制与高可用（Redis-Sentinel）集群\" class=\"headerlink\" title=\"8.支持主-从（Master-Slave）复制与高可用（Redis Sentinel）集群\"></a>8.支持主-从（Master-Slave）复制与高可用（Redis Sentinel）集群</h4><p>​        3.0版本以上功能</p>\n<h3 id=\"六-常见数据结构及使用操作\"><a href=\"#六-常见数据结构及使用操作\" class=\"headerlink\" title=\"六.常见数据结构及使用操作\"></a>六.常见数据结构及使用操作</h3><p><em>一般情况下是这样设计 key 的： <code>表名:列名:主键名:主键值</code></em></p>\n<h4 id=\"1-string：\"><a href=\"#1-string：\" class=\"headerlink\" title=\"1. string：\"></a>1. string：</h4><blockquote>\n<p>值可以是任何种类的字符串（包括二进制数据），例如你可以在一个键下保存一张 <code>.jpeg</code> 图片，需要注意不要超过 512 MB 。</p>\n</blockquote>\n<ul>\n<li><strong>设置和获取键值对</strong>：</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"builtin-name\">SET</span> key value</span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; <span class=\"builtin-name\">GET</span> key</span><br><span class=\"line\"><span class=\"string\">\"value\"</span></span><br></pre></td></tr></table></figure>\n\n<p>当 key 存在时，<code>SET</code> 命令会覆盖掉你上一次设置的值：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"builtin-name\">SET</span> key newValue</span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; <span class=\"builtin-name\">GET</span> key</span><br><span class=\"line\"><span class=\"string\">\"newValue\"</span></span><br></pre></td></tr></table></figure>\n\n<p>另外还可以使用 <code>EXISTS</code> 和 <code>DEL</code> 关键字来查询是否存在和删除键值对：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; EXISTS <span class=\"type\">key</span></span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; DEL <span class=\"type\">key</span></span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; GET <span class=\"type\">key</span></span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>批量设置键值对</strong></li>\n</ul>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">SET</span> key1 <span class=\"comment\">value1</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; <span class=\"keyword\">SET</span> <span class=\"comment\">key2 value2</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; MGET <span class=\"comment\">key1 key2 key3    #</span> 返回一个列表</span><br><span class=\"line\">1) <span class=\"string\">\"value1\"</span></span><br><span class=\"line\">2) <span class=\"string\">\"value2\"</span></span><br><span class=\"line\">3) (nil)</span><br><span class=\"line\">&gt; MSET <span class=\"comment\">key1 value1 key2 value2</span></span><br><span class=\"line\">&gt; MGET <span class=\"comment\">key1 key2</span></span><br><span class=\"line\">1) <span class=\"string\">\"value1\"</span></span><br><span class=\"line\">2) <span class=\"string\">\"value2\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>过期和 SET 命令扩展</strong></li>\n</ul>\n<p>可以对 key 设置过期时间，到时间会被自动删除，这个功能常用来控制缓存的失效时间。<em>(过期可以是任意数据结构)</em></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"builtin-name\">SET</span> key value1</span><br><span class=\"line\">&gt; <span class=\"builtin-name\">GET</span> key</span><br><span class=\"line\"><span class=\"string\">\"value1\"</span></span><br><span class=\"line\">&gt; EXPIRE name 5    # 5s 后过期</span><br><span class=\"line\"><span class=\"built_in\">..</span>.                # 等待 5s</span><br><span class=\"line\">&gt; <span class=\"builtin-name\">GET</span> key</span><br><span class=\"line\">(<span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n\n<p>等价于 <code>SET</code> + <code>EXPIRE</code> 的 <code>SETEX</code> 命令：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SETEX <span class=\"type\">key</span> <span class=\"number\">5</span> value1</span><br><span class=\"line\">...                # 等待 <span class=\"number\">5</span>s 后获取</span><br><span class=\"line\">&gt; GET <span class=\"type\">key</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; SETNX <span class=\"type\">key</span> value1  # 如果 <span class=\"type\">key</span> 不存在则 SET 成功</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; SETNX <span class=\"type\">key</span> value1  # 如果 <span class=\"type\">key</span> 存在则 SET 失败</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">0</span></span><br><span class=\"line\">&gt; GET <span class=\"type\">key</span></span><br><span class=\"line\"><span class=\"string\">\"value\"</span>             # 没有改变</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>计数</strong></li>\n</ul>\n<p>如果 value 是一个整数，还可以对它使用 <code>INCR</code> 命令进行 <strong>原子性</strong> 的自增操作，这意味着及时多个客户端对同一个 key 进行操作，也决不会导致竞争的情况：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SET counter <span class=\"number\">100</span></span><br><span class=\"line\">&gt; INCR counter</span><br><span class=\"line\">(<span class=\"built_in\">int</span>eger) <span class=\"number\">101</span></span><br><span class=\"line\">&gt; INCRBY counter <span class=\"number\">50</span></span><br><span class=\"line\">(<span class=\"built_in\">int</span>eger) <span class=\"number\">151</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-list\"><a href=\"#2-list\" class=\"headerlink\" title=\"2. list\"></a>2. list</h4><blockquote>\n<p>Redis 的列表相当于 Java 语言中的 <strong>LinkedList</strong>，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。</p>\n</blockquote>\n<p><strong>链表的基本操作</strong></p>\n<ul>\n<li><code>LPUSH</code> 和 <code>RPUSH</code> 分别可以向 list 的左边（头部）和右边（尾部）添加一个新元素；</li>\n<li><code>LRANGE</code> 命令可以从 list 中取出一定范围的元素；</li>\n<li><code>LINDEX</code> 命令可以从 list 中取出指定下表的元素，相当于 Java 链表操作中的 <code>get(int index)</code> 操作；</li>\n</ul>\n<p>示范：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> rpush mylist A</span></span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> rpush mylist B</span></span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> lpush mylist first</span></span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> lrange mylist 0 -1    <span class=\"comment\"># -1 表示倒数第一个元素, 这里表示从第一个元素到最后一个元素，即所有</span></span></span><br><span class=\"line\">1) \"first\"</span><br><span class=\"line\">2) \"A\"</span><br><span class=\"line\">3) \"B\"</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>list 实现队列</li>\n</ul>\n<p>队列是先进先出的数据结构，常用于消息排队和异步逻辑处理，它会确保元素的访问顺序：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPUSH books python java golang</span></span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> LPOP books</span></span><br><span class=\"line\">\"python\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> LPOP books</span></span><br><span class=\"line\">\"java\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> LPOP books</span></span><br><span class=\"line\">\"golang\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> LPOP books</span></span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>list 实现栈</li>\n</ul>\n<p>栈是先进后出的数据结构，跟队列正好相反：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPUSH books python java golang</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPOP books</span></span><br><span class=\"line\">\"golang\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPOP books</span></span><br><span class=\"line\">\"java\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPOP books</span></span><br><span class=\"line\">\"python\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPOP books</span></span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用场景举例：简单的消息队列、分页功能（lrange ）</li>\n</ul>\n<h4 id=\"3-hash\"><a href=\"#3-hash\" class=\"headerlink\" title=\"3. hash\"></a>3. hash</h4><blockquote>\n<p>Redis 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，都是通过 <strong>“数组 + 链表”</strong> 的链地址法来解决部分 <strong>哈希冲突</strong>，同时这样的结构也吸收了两种不同数据结构的优点。</p>\n</blockquote>\n<ul>\n<li>基本操作：</li>\n</ul>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; HSET <span class=\"keyword\">books </span><span class=\"keyword\">java </span><span class=\"string\">\"think in java\"</span>    <span class=\"comment\"># 命令行的字符串如果包含空格则需要使用引号包裹</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; HSET <span class=\"keyword\">books </span>python <span class=\"string\">\"python cookbook\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; HGETALL <span class=\"keyword\">books </span>   <span class=\"comment\"># key 和 value 间隔出现</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"think in java\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"python\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"python cookbook\"</span></span><br><span class=\"line\">&gt; HGET <span class=\"keyword\">books </span><span class=\"keyword\">java</span></span><br><span class=\"line\"><span class=\"keyword\">\"think </span>in <span class=\"keyword\">java\"</span></span><br><span class=\"line\"><span class=\"keyword\">&gt; </span>HSET <span class=\"keyword\">books </span><span class=\"keyword\">java </span><span class=\"string\">\"head first java\"</span>  </span><br><span class=\"line\">(integer) <span class=\"number\">0</span>        <span class=\"comment\"># 因为是更新操作，所以返回 0</span></span><br><span class=\"line\">&gt; HMSET <span class=\"keyword\">books </span><span class=\"keyword\">java </span><span class=\"string\">\"effetive  java\"</span> python <span class=\"string\">\"learning python\"</span>    <span class=\"comment\"># 批量操作</span></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用场景举例：单点登录。存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果。</li>\n</ul>\n<h4 id=\"4-set\"><a href=\"#4-set\" class=\"headerlink\" title=\"4. set\"></a>4. set</h4><blockquote>\n<p>Redis 的集合相当于 Java 语言中的 <strong>HashSet</strong>，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。</p>\n</blockquote>\n<ul>\n<li>基本操作：</li>\n</ul>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SADD <span class=\"keyword\">books </span><span class=\"keyword\">java</span></span><br><span class=\"line\"><span class=\"keyword\">(integer) </span><span class=\"number\">1</span></span><br><span class=\"line\">&gt; SADD <span class=\"keyword\">books </span><span class=\"keyword\">java </span>   <span class=\"comment\"># 重复</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">&gt; SADD <span class=\"keyword\">books </span>python golang</span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">&gt; SMEMBERS <span class=\"keyword\">books </span>   <span class=\"comment\"># 注意顺序，set 是无序的 </span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"python\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"golang\"</span></span><br><span class=\"line\">&gt; SISMEMBER <span class=\"keyword\">books </span><span class=\"keyword\">java </span>   <span class=\"comment\"># 查询某个 value 是否存在，相当于 contains</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; <span class=\"keyword\">SCARD </span><span class=\"keyword\">books </span>   <span class=\"comment\"># 获取长度</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">&gt; SPOP <span class=\"keyword\">books </span>    <span class=\"comment\"># 弹出一个</span></span><br><span class=\"line\"><span class=\"string\">\"java\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用场景举例：全局去重、计算共同喜好等</li>\n</ul>\n<h4 id=\"5-zset\"><a href=\"#5-zset\" class=\"headerlink\" title=\"5. zset\"></a>5. zset</h4><blockquote>\n<p>这可能使 Redis 最具特色的一个数据结构了，它类似于 Java 中 <strong>SortedSet</strong> 和 <strong>HashMap</strong> 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。它的内部实现用的是一种叫做 <strong>「跳跃表」</strong> 的数据结构。</p>\n</blockquote>\n<ul>\n<li>基本操作</li>\n</ul>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ZADD books <span class=\"number\">9.0</span> <span class=\"string\">\"think in java\"</span></span><br><span class=\"line\">&gt; ZADD books <span class=\"number\">8.9</span> <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\">&gt; ZADD books <span class=\"number\">8.6</span> <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZRANGE books <span class=\"number\">0</span> <span class=\"number\">-1</span>     # 按 score 排序列出，参数区间为排名范围</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"think in java\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZREVRANGE books <span class=\"number\">0</span> <span class=\"number\">-1</span>  # 按 score 逆序列出，参数区间为排名范围</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"think in java\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZCARD books           # 相当于 count()</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZSCORE books <span class=\"string\">\"java concurrency\"</span>   # 获取指定 value 的 score</span><br><span class=\"line\"><span class=\"string\">\"8.9000000000000004\"</span>                # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZRANK books <span class=\"string\">\"java concurrency\"</span>    # 排名</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZRANGEBYSCORE books <span class=\"number\">0</span> <span class=\"number\">8.91</span>        # 根据分值区间遍历 zset</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZRANGEBYSCORE books -inf <span class=\"number\">8.91</span> withscores  # 根据分值区间 (-∞, <span class=\"number\">8.91</span>] 遍历 zset，同时返回分值。inf 代表 infinite。</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"8.5999999999999996\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"8.9000000000000004\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZREM books <span class=\"string\">\"java concurrency\"</span>             # 删除 value</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; ZRANGE books <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"think in java\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用场景举例：排行榜应用取 TOP N 、范围查找</li>\n</ul>\n<h3 id=\"七-Redis常见问题及解决方法\"><a href=\"#七-Redis常见问题及解决方法\" class=\"headerlink\" title=\"七. Redis常见问题及解决方法\"></a>七. Redis常见问题及解决方法</h3><h4 id=\"1-缓存与数据库双写不一致\"><a href=\"#1-缓存与数据库双写不一致\" class=\"headerlink\" title=\"1. 缓存与数据库双写不一致\"></a>1. 缓存与数据库双写不一致</h4><h5 id=\"什么是双写不一致？\"><a href=\"#什么是双写不一致？\" class=\"headerlink\" title=\"什么是双写不一致？\"></a>什么是双写不一致？</h5><p>​        一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是当要执行数据的更新操作的时候，数据库和缓存的数据就会出现不一致的情况。</p>\n<p>从理论上说，只要我们设置了<strong>键的过期时间</strong>，就能保证缓存和数据库的数据<strong>最终一致</strong>。</p>\n<h5 id=\"有哪些解决办法？\"><a href=\"#有哪些解决办法？\" class=\"headerlink\" title=\"有哪些解决办法？\"></a>有哪些解决办法？</h5><ul>\n<li><p>先更新数据库，再删缓存。</p>\n<p>  如果在高并发的场景下，出现数据库与缓存数据不一致的<strong>概率特别低</strong>，也不是没有：</p>\n<blockquote>\n<p>1、 缓存刚好失效<br>2、线程A查询数据库，得一个旧值<br>3、线程B将新值写入数据库<br>4、线程B删除缓存<br>5、线程A将查到的旧值写入缓存</p>\n</blockquote>\n</li>\n<li><p>先删除缓存，再更新数据库。</p>\n<p>  并发场景下分析一下，还是有问题：</p>\n<blockquote>\n<p>线程A删除了缓存<br>线程B查询，发现缓存已不存在<br>线程B去数据库查询得到旧值<br>线程B将旧值写入缓存<br>线程A将新值写入数据库</p>\n</blockquote>\n</li>\n<li><p>将删除缓存、修改数据库、读取缓存等的操作积压到队列里边，实现串行化。</p>\n</li>\n</ul>\n<p>这些方案从根本上来说，只能降低不一致发生的概率，无法完全避免。因此，<strong>有强一致性要求的数据，不能放缓存。</strong></p>\n<h4 id=\"2-缓存穿透\"><a href=\"#2-缓存穿透\" class=\"headerlink\" title=\"2. 缓存穿透\"></a>2. 缓存穿透</h4><h5 id=\"什么是缓存穿透？\"><a href=\"#什么是缓存穿透？\" class=\"headerlink\" title=\"什么是缓存穿透？\"></a>什么是缓存穿透？</h5><p>​        缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：我们有一张数据库表，ID都是从1开始的，但是可能有黑客想把我们的数据库搞垮，每次请求的ID都是负数，导致缓存失去意义，请求都会去找数据库。</p>\n<h5 id=\"有哪些解决办法？-1\"><a href=\"#有哪些解决办法？-1\" class=\"headerlink\" title=\"有哪些解决办法？\"></a>有哪些解决办法？</h5><ol>\n<li><p>缓存无效 key</p>\n<p> ​        如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code>。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。如果用 Java 代码展示的话，差不多是下面这样的：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObjectInclNullById</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从缓存中获取数据</span></span><br><span class=\"line\">    Object cacheValue = cache.get(id);</span><br><span class=\"line\">    <span class=\"comment\">// 缓存为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheValue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从数据库中获取</span></span><br><span class=\"line\">        Object storageValue = storage.get(key);</span><br><span class=\"line\">        <span class=\"comment\">// 缓存空对象</span></span><br><span class=\"line\">        cache.set(key, storageValue);</span><br><span class=\"line\">        <span class=\"comment\">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (storageValue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class=\"line\">            cache.expire(key, <span class=\"number\">60</span> * <span class=\"number\">5</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> storageValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cacheValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>布隆过滤器</p>\n<p> ​        布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中，我们需要的就是判断 key 是否合法。</p>\n<p> ​        具体做法：内部维护一系列合法有效的 Key都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>\n<p> ​        但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>\n<hr>\n<p> <strong><em>布隆过滤器原理</em>：</strong>  </p>\n<p> <strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>\n<ol>\n<li><p>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</p>\n</li>\n<li><p>根据得到的哈希值，在位数组中把对应下标的值置为 1。</p>\n</li>\n</ol>\n<p> <strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p>\n<ol>\n<li><p>对给定元素再次进行相同的哈希计算；</p>\n</li>\n<li><p>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>\n<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-缓存雪崩\"><a href=\"#3-缓存雪崩\" class=\"headerlink\" title=\"3. 缓存雪崩\"></a>3. 缓存雪崩</h4><h5 id=\"什么是缓存雪崩？\"><a href=\"#什么是缓存雪崩？\" class=\"headerlink\" title=\"什么是缓存雪崩？\"></a>什么是缓存雪崩？</h5><p>​        缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，数据库的压力可想而知，可能直接就挂了。</p>\n<p>​        举个例子：系统的缓存模块出了问题比如宕机导致不可用，造成系统的所有访问，都要走数据库。</p>\n<p>​        还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong></p>\n<p>​        举个例子 ：秒杀开始12个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是12个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p>\n<h5 id=\"有哪些解决办法？-2\"><a href=\"#有哪些解决办法？-2\" class=\"headerlink\" title=\"有哪些解决办法？\"></a>有哪些解决办法？</h5><p>Redis服务不可用：</p>\n<ol>\n<li>采用Redis集群，避免单机出现问题整个缓存服务都没办法使用。</li>\n<li>限流，避免同时处理大量的请求。</li>\n</ol>\n<p>热点缓存失效：</p>\n<ol>\n<li>设置不同的失效时间，比如随机设置缓存的失效时间。</li>\n<li>缓存永不失效。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一-什么是Redis\"><a href=\"#一-什么是Redis\" class=\"headerlink\" title=\"一. 什么是Redis\"></a>一. 什么是Redis</h3><p>​        官方简介：Redis是一个基于BSD<strong>开源</strong>的项目，是一个把<strong>结构化</strong>的数据放在<strong>内存</strong>中的一个存储系统，可以把它<strong>作为数据库，缓存和消息中间件</strong>来使用。同时支持<strong>strings，lists，hashes，sets，sorted sets，</strong>bitmaps，hyperloglogs、geospatial indexes和streams等<strong>数据类型</strong>。还内建了<strong>复制、lua脚本、LRU、事务</strong>、不同级别的<strong>持久化</strong>功能，通过redis sentinel实现<strong>高可用</strong>，通过redis cluster实现了<strong>自动分片</strong>，以及<strong>发布/订阅</strong>，<strong>自动故障转移</strong>等等特性。</p>\n<h3 id=\"二-Redis能解决什么问题\"><a href=\"#二-Redis能解决什么问题\" class=\"headerlink\" title=\"二. Redis能解决什么问题\"></a>二. Redis能解决什么问题</h3><blockquote>\n<p><strong>假如我们有个查询列表的API，用户抱怨说每次请求都要2秒左右才能返回结果，如何改善用户体验呢？</strong></p>\n</blockquote>\n<p>​        <strong>方案一、基于HTTP缓存</strong>：</p>\n<p>​        为API的响应头加上缓存控制 <strong>cache-control</strong>:max-age=600 ，即在浏览器缓存这个响应10分钟，简单粗暴。但是这个方法有两个缺点：第一个是在缓存生效的10分钟内，API消费者可能会得到旧的数据；第二个是如果客户端浏览器不使用缓存，方法直接无效。</p>\n<p>​        <strong>方案二、基于本机内存的缓存</strong></p>\n<p>​        该API请求耗时操作主要在于使用SQL查询结果的过程中消耗了将近2秒的时间，于是，我们又想到了一个方案，把SQL查询的结果直接缓存在当前API服务器的内存中，比如使用JDK自带的<strong>HashMap</strong>和ConcurrentHashMap，或者<strong>Guava Cache</strong>、Spring Cache等本地缓存框架，设置缓存有效时间为10分钟，并且在修改和更新操作时同步修改缓存中的数据。这样后续10分钟内的请求直接读缓存，可以做到及时响应，不再花费2秒去执行SQL了。</p>\n<p>​        结果其他API的小伙伴发现这是个好办法，于是很快我们就发现API服务器的内存要爆了…而且对于分布式架构，相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的。</p>\n<p>​        <strong>方案三、使用Redis做缓存</strong></p>\n<p>​        要解决API服务器内存被缓存塞满及各服务间缓存无法共享的问题，最直接的办法就是把这些缓存部署在一台单独的服务器上，即使同一个相同的服务部署在再多机器上，也是使用的同一份缓存。于是我们需要为分布式缓存引入额外的服务，比如 Redis 或Memcached，而且要保证服务的高可用。</p>\n<h4 id=\"Redis主要应用场景\"><a href=\"#Redis主要应用场景\" class=\"headerlink\" title=\"Redis主要应用场景\"></a>Redis主要应用场景</h4><p>​        缓存（数据查询、短连接、新闻内容、商品内容等）、分布式会话（Session）、任务队列（秒杀、抢购、12306等）、应用排行榜、访问统计、数据过期处理（可以精确到毫秒）。</p>\n<h3 id=\"三-Redis-和-Memcached-的区别和共同点\"><a href=\"#三-Redis-和-Memcached-的区别和共同点\" class=\"headerlink\" title=\"三. Redis 和 Memcached 的区别和共同点\"></a>三. Redis 和 Memcached 的区别和共同点</h3><ul>\n<li><strong>共同点</strong> ：</li>\n</ul>\n<ol>\n<li>都是基于内存的缓存。</li>\n<li>都有过期策略。</li>\n<li>两者的性能都非常高。</li>\n</ol>\n<ul>\n<li><strong>区别</strong> ：</li>\n</ul>\n<ol>\n<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li>\n<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存之中。</strong></li>\n<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>\n<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>\n<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li>\n<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li>\n<li><strong>Redis 支持发布订阅模型、Lua脚本、事务等功能，而Memcached不支持。并且，Redis支持更多的编程语言。</strong></li>\n</ol>\n<h3 id=\"四-安装和配置\"><a href=\"#四-安装和配置\" class=\"headerlink\" title=\"四. 安装和配置\"></a>四. 安装和配置</h3><h4 id=\"1-安装：略\"><a href=\"#1-安装：略\" class=\"headerlink\" title=\"1. 安装：略\"></a>1. 安装：略</h4><h4 id=\"2-主要配置：\"><a href=\"#2-主要配置：\" class=\"headerlink\" title=\"2. 主要配置：\"></a>2. 主要配置：</h4><p>​    Linux下配置文件为redis.conf，Windows下配置文件为redis.windows.conf</p>\n<ul>\n<li><p>开启持久化，配置文件装中添加如下内容：</p>\n  <figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">appendonly</span> <span class=\"literal\">yes</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>port：端口配置项，查看和设置Redis监听端口，默认端口为6379。</p>\n</li>\n<li><p>bind：主机地址配置项，查看和绑定的主机地址，默认地址的值为127.0.0.1。这个选项，在单网卡的机器上，一般不需要修改。</p>\n</li>\n<li><p>timeout：连接空闲多长要关闭连接，表示客户端闲置一段时间后，要关闭连接。如果指定为0，表示时长不限制。这个选项的默认值为0，表示默认不限制连接的空闲时长</p>\n</li>\n<li><p>dbfilename：指定保存缓存数据库的本地文件名，默认值为dump.rdb。</p>\n</li>\n<li><p>dir：指定保存缓存数据的本地文件所存放的目录，默认值为安装目录。</p>\n</li>\n<li><p>rdbcompression：指定存储至本地数据库时是否压缩数据，默认为yes,Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变得巨大。</p>\n</li>\n<li><p>save：指定在多长时间内，有多少次Key-Value更新操作，就将数据同步到本地数据库文件，可以设置多个条件。save配置项的格式为save<seconds><changes>:seconds表示时间段的长度，changes表示变化的次数。如设置为900秒（15分钟）内有1个更改，则同步到文件：</p>\n  <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt;<span class=\"built_in\"> config </span><span class=\"builtin-name\">set</span> save <span class=\"string\">\"900 1\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt;<span class=\"built_in\"> config </span><span class=\"builtin-name\">get</span> save</span><br><span class=\"line\">1) <span class=\"string\">\"save\"</span></span><br><span class=\"line\">2) <span class=\"string\">\"900 1\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>requirepass：设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认这个选项是关闭的。</p>\n</li>\n<li><p>slaveof：在主从复制的模式下，设置当前节点为slave（从）节点时，设置master（主）节点的IP地址及端口，在Redis启动时，它会自动从master（主）节点进行数据同步。如果已经是slave（从）服务器，则会丢掉旧数据集，从新的master主服务器同步缓存数据。格式为：</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slaveof<span class=\"tag\">&lt;<span class=\"name\">masterip</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">masterport</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>masterauth：在主从复制的模式下，当master（主）服务器节点设置了密码保护时，slave（从）服务器连接master（主）服务器的密码。格式为:</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">masterauth<span class=\"tag\">&lt;<span class=\"name\">master-password</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>databases：设置缓存数据库的数量，默认数据库数量为16个。这16个数据库的id为0-15，默认使用的数据库是第0个。可以使用SELECT <dbid>命令在连接时通过数据库id来指定要使用的数据库。</p>\n</li>\n</ul>\n<h4 id=\"3-Redis连接客户端命令：\"><a href=\"#3-Redis连接客户端命令：\" class=\"headerlink\" title=\"3. Redis连接客户端命令：\"></a>3. Redis连接客户端命令：</h4><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#redis-cli</span> -h host -<span class=\"selector-tag\">p</span> port -<span class=\"selector-tag\">a</span> password</span><br></pre></td></tr></table></figure>\n\n<p>本地连接：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">root@</span><span class=\"number\">0912</span>b31c4171# redis-cli</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"五-Redis的主要特点\"><a href=\"#五-Redis的主要特点\" class=\"headerlink\" title=\"五. Redis的主要特点\"></a>五. Redis的主要特点</h3><h4 id=\"1-速度异常快\"><a href=\"#1-速度异常快\" class=\"headerlink\" title=\"1. 速度异常快\"></a>1. 速度异常快</h4><p>​        采用多路 IO 复用模型，不需要等待磁盘的IO，在内存之间进行的数据存储和查询，速度非常快。官方数据显示每秒可执行大约 110000 次的设置(SET)操作，每秒大约可执行 81000 次的读取/获取(GET)操作。可以运行命令 <code>redis-benchmark -n 100000 -q</code> 来检测本地同时执行 10 万个请求时的性能：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">root@0912b31c4171:/data#</span> <span class=\"string\">redis-benchmark</span> <span class=\"string\">-n</span> <span class=\"number\">100000</span> <span class=\"string\">-q</span></span><br><span class=\"line\"><span class=\"attr\">PING_INLINE:</span> <span class=\"number\">31172.07</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">PING_BULK:</span> <span class=\"number\">31615.55</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">SET:</span> <span class=\"number\">30432.14</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">GET:</span> <span class=\"number\">31289.11</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">INCR:</span> <span class=\"number\">30441.40</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">LPUSH:</span> <span class=\"number\">29550.83</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br><span class=\"line\"><span class=\"attr\">RPUSH:</span> <span class=\"number\">30184.12</span> <span class=\"string\">requests</span> <span class=\"string\">per</span> <span class=\"string\">second</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-丰富的数据结构\"><a href=\"#2-丰富的数据结构\" class=\"headerlink\" title=\"2. 丰富的数据结构\"></a>2. 丰富的数据结构</h4><p>​        除了string之外，还有list、hash、set、sortedset、bitmaps、hyperloglogs、geospatial indexes和stream。其中<strong>string(字符串)</strong>、<strong>list(列表)</strong>、<strong>hash(字典)</strong>、<strong>set(集合)</strong> 和 <strong>zset(有序集合)</strong>这 5 种是 Redis 最基础、最重要的部分。</p>\n<h4 id=\"3-单线程\"><a href=\"#3-单线程\" class=\"headerlink\" title=\"3. 单线程\"></a>3. 单线程</h4><p>​        避免了频繁的上下文切换。Redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p>\n<p>文件事件处理器的结构包含 4 个部分：</p>\n<ul>\n<li><p>多个 socket</p>\n</li>\n<li><p>IO 多路复用程序</p>\n</li>\n<li><p>文件事件分派器</p>\n</li>\n<li><p>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</p>\n<p>  ​        多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>\n<p>  <strong><em>传统的并发模型，每个 I/O 流都有一个新的线程管理</em></strong></p>\n<p>   <strong><em>I/O 多路复用，只有单个线程，通过跟踪每个 I/O 流的状态，来管理多个 I/O 流。</em></strong></p>\n</li>\n</ul>\n<h4 id=\"4-可持久化\"><a href=\"#4-可持久化\" class=\"headerlink\" title=\"4. 可持久化\"></a>4. 可持久化</h4><p>​        支持RDB与AOF两种方式，将内存中的数据写入外部的物理存储设备。</p>\n<p>​        <strong>RDB</strong>(Redis DataBase)：是最简单的 Redis 持久性模式。当满足特定条件时，它将生成数据集的时间点<strong>快照</strong>，例如，如果先前的快照是在2分钟前创建的，并且现在已经至少有 <em>100</em> 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 <code>.rdb</code> 文件生成。</p>\n<p>​        <strong>AOF</strong> (Append Only File - 仅追加文件)：它的工作方式非常简单：每次执行 <strong>修改内存</strong> 中数据集的写操作时，都会 <strong>记录</strong> 该操作。假设 AOF 日志记录了自 Redis 实例创建以来 <strong>所有的修改性指令序列</strong>，那么就可以通过对一个空的 Redis 实例 <strong>顺序执行所有的指令</strong>，也就是 <strong>「重放」</strong>，来恢复 Redis 当前实例的内存数据结构的状态。</p>\n<p>​        <strong>RDB优势</strong></p>\n<ul>\n<li><p>RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</p>\n</li>\n<li><p>生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p>\n</li>\n<li><p>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p>\n</li>\n</ul>\n<p>​        <strong>RDB劣势</strong></p>\n<ul>\n<li>RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</li>\n</ul>\n<p>​        <strong>AOF优势</strong></p>\n<ul>\n<li><p>AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。（2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</p>\n</li>\n<li><p>AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</p>\n</li>\n<li><p>AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p>\n</li>\n</ul>\n<p>​        <strong>AOF劣势</strong></p>\n<ul>\n<li><p>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</p>\n</li>\n<li><p>AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</p>\n</li>\n<li><p>以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。</p>\n</li>\n</ul>\n<h4 id=\"5-支持发布、订阅、管道。\"><a href=\"#5-支持发布、订阅、管道。\" class=\"headerlink\" title=\"5. 支持发布、订阅、管道。\"></a>5. 支持发布、订阅、管道。</h4><p>​        <strong>发布/ 订阅系统</strong> 是 Web 系统中比较常用的一个功能。简单点说就是 <strong>发布者发布消息，订阅者接受消息</strong>，这有点类似于我们的报纸/ 杂志社之类的。我们可以使用redis的一个 <code>list</code> 列表结构结合 <code>lpush</code> 和 <code>rpop</code> 来实现消息队列的功能，但是似乎很难实现实现 <strong>消息多播</strong> 的功能：</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gopdit62wmj30yg0ccgmp.jpg\" alt=\"image\"></p>\n<p>​        <strong>Redis</strong>为了消除<code>Publisher</code> 与 <code>Consumer</code> 的强关联，支持消息多播，引入了另一种概念：<strong>频道</strong> <em>(channel)</em>：</p>\n<p><img src=\"https://tvax1.sinaimg.cn/large/006YzKDNly1gopdjtvehij30yg0cbmy0.jpg\" alt=\"image\"></p>\n<p>当 <code>Publisher</code> 往 <code>channel</code> 中发布消息时，关注了指定 <code>channel</code> 的 <code>Consumer</code> 就能够同时受到消息。但这里的 <strong>问题</strong> 是，消费者订阅一个频道是必须 <strong>明确指定频道名称</strong> 的，这意味着，如果我们想要 <strong>订阅多个</strong> 频道，那么就必须 <strong>显式地关注多个</strong> 名称。</p>\n<p>为了简化订阅的繁琐操作，<strong>Redis</strong> 提供了 <strong>模式订阅</strong> 的功能 <strong>Pattern Subscribe</strong>，这样就可以 <strong>一次性关注多个频道</strong> 了，即使生产者新增了同模式的频道，消费者也可以立即受到消息：</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gopdkll7gtj30yg0cb0ul.jpg\" alt=\"image\"></p>\n<p>例如上图中，<strong>所有</strong> 位于图片下方的 <strong><code>Consumer</code> 都能够受到消息</strong>。</p>\n<p><code>Publisher</code> 往 <code>wmyskxz.chat</code> 这个 <code>channel</code> 中发送了一条消息，不仅仅关注了这个频道的 <code>Consumer 1</code> 和 <code>Consumer 2</code> 能够受到消息，图片中的两个 <code>channel</code> 都和模式 <code>wmyskxz.*</code> 匹配，所以 <strong>Redis</strong> 此时会同样发送消息给订阅了 <code>wmyskxz.*</code> 这个模式的 <code>Consumer 3</code> 和关注了在这个模式下的另一个频道 <code>wmyskxz.log</code> 下的 <code>Consumer 4</code> 和 <code>Consumer 5</code>。</p>\n<p>另一方面，如果接收消息的频道是 <code>wmyskxz.chat</code>，那么 <code>Consumer 3</code> 也会受到消息。  </p>\n<h5 id=\"快速体验\"><a href=\"#快速体验\" class=\"headerlink\" title=\"快速体验\"></a><em>快速体验</em></h5><p>在 <strong>Redis</strong> 中，<strong>PubSub</strong> 模块的使用非常简单，常用的命令也就下面这么几条：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 订阅频道：</span></span><br><span class=\"line\">SUBSCRIBE channel [channel ....]   <span class=\"comment\"># 订阅给定的一个或多个频道的信息</span></span><br><span class=\"line\">PSUBSCRIBE pattern [pattern ....]  <span class=\"comment\"># 订阅一个或多个符合给定模式的频道</span></span><br><span class=\"line\"><span class=\"comment\"># 发布频道：</span></span><br><span class=\"line\">PUBLISH channel message  <span class=\"comment\"># 将消息发送到指定的频道</span></span><br><span class=\"line\"><span class=\"comment\"># 退订频道：</span></span><br><span class=\"line\">UNSUBSCRIBE [channel [channel ....]]   <span class=\"comment\"># 退订指定的频道</span></span><br><span class=\"line\">PUNSUBSCRIBE [pattern [pattern ....]]  <span class=\"comment\">#退订所有给定模式的频道</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以在本地快速地来体验一下 <strong>PubSub</strong>：</p>\n<p><img src=\"https://tvax2.sinaimg.cn/large/006YzKDNly1gopdlahl8sg30qq0cenpg.gif\" alt=\"\"></p>\n<p>具体步骤如下：</p>\n<ol>\n<li>开启本地 Redis 服务，新建两个控制台窗口；</li>\n<li>在其中一个窗口输入 <code>SUBSCRIBE wmyskxz.chat</code> 关注 <code>wmyskxz.chat</code> 频道，让这个窗口成为 <strong>消费者</strong>。</li>\n<li>在另一个窗口输入 <code>PUBLISH wmyskxz.chat &#39;message&#39;</code> 往这个频道发送消息，这个时候就会看到 <strong>另一个窗口实时地出现</strong> 了发送的测试消息。</li>\n</ol>\n<h4 id=\"6-支持分布式锁\"><a href=\"#6-支持分布式锁\" class=\"headerlink\" title=\"6. 支持分布式锁\"></a>6. 支持分布式锁</h4><p>​        在分布式系统中，如果不同的节点需要访同到一个资源，往往需要通过互斥机制来防止彼此干扰，并且保证数据的一致性。在这种情况下，需要使用到分布式锁。分布式锁和Java的锁用于实现不同线程之间的同步访问，原理上是类似的。</p>\n<h4 id=\"7-支持原子操作和事务\"><a href=\"#7-支持原子操作和事务\" class=\"headerlink\" title=\"7.支持原子操作和事务\"></a>7.支持原子操作和事务</h4><p>​        Redis事务是一组命令的集合。一个事务中的命令要么都执行，要么都不执行。如果命令在运行期间出现错误，不会自动回滚。</p>\n<h4 id=\"8-支持主-从（Master-Slave）复制与高可用（Redis-Sentinel）集群\"><a href=\"#8-支持主-从（Master-Slave）复制与高可用（Redis-Sentinel）集群\" class=\"headerlink\" title=\"8.支持主-从（Master-Slave）复制与高可用（Redis Sentinel）集群\"></a>8.支持主-从（Master-Slave）复制与高可用（Redis Sentinel）集群</h4><p>​        3.0版本以上功能</p>\n<h3 id=\"六-常见数据结构及使用操作\"><a href=\"#六-常见数据结构及使用操作\" class=\"headerlink\" title=\"六.常见数据结构及使用操作\"></a>六.常见数据结构及使用操作</h3><p><em>一般情况下是这样设计 key 的： <code>表名:列名:主键名:主键值</code></em></p>\n<h4 id=\"1-string：\"><a href=\"#1-string：\" class=\"headerlink\" title=\"1. string：\"></a>1. string：</h4><blockquote>\n<p>值可以是任何种类的字符串（包括二进制数据），例如你可以在一个键下保存一张 <code>.jpeg</code> 图片，需要注意不要超过 512 MB 。</p>\n</blockquote>\n<ul>\n<li><strong>设置和获取键值对</strong>：</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"builtin-name\">SET</span> key value</span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; <span class=\"builtin-name\">GET</span> key</span><br><span class=\"line\"><span class=\"string\">\"value\"</span></span><br></pre></td></tr></table></figure>\n\n<p>当 key 存在时，<code>SET</code> 命令会覆盖掉你上一次设置的值：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"builtin-name\">SET</span> key newValue</span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; <span class=\"builtin-name\">GET</span> key</span><br><span class=\"line\"><span class=\"string\">\"newValue\"</span></span><br></pre></td></tr></table></figure>\n\n<p>另外还可以使用 <code>EXISTS</code> 和 <code>DEL</code> 关键字来查询是否存在和删除键值对：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; EXISTS <span class=\"type\">key</span></span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; DEL <span class=\"type\">key</span></span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; GET <span class=\"type\">key</span></span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>批量设置键值对</strong></li>\n</ul>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">SET</span> key1 <span class=\"comment\">value1</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; <span class=\"keyword\">SET</span> <span class=\"comment\">key2 value2</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; MGET <span class=\"comment\">key1 key2 key3    #</span> 返回一个列表</span><br><span class=\"line\">1) <span class=\"string\">\"value1\"</span></span><br><span class=\"line\">2) <span class=\"string\">\"value2\"</span></span><br><span class=\"line\">3) (nil)</span><br><span class=\"line\">&gt; MSET <span class=\"comment\">key1 value1 key2 value2</span></span><br><span class=\"line\">&gt; MGET <span class=\"comment\">key1 key2</span></span><br><span class=\"line\">1) <span class=\"string\">\"value1\"</span></span><br><span class=\"line\">2) <span class=\"string\">\"value2\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>过期和 SET 命令扩展</strong></li>\n</ul>\n<p>可以对 key 设置过期时间，到时间会被自动删除，这个功能常用来控制缓存的失效时间。<em>(过期可以是任意数据结构)</em></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"builtin-name\">SET</span> key value1</span><br><span class=\"line\">&gt; <span class=\"builtin-name\">GET</span> key</span><br><span class=\"line\"><span class=\"string\">\"value1\"</span></span><br><span class=\"line\">&gt; EXPIRE name 5    # 5s 后过期</span><br><span class=\"line\"><span class=\"built_in\">..</span>.                # 等待 5s</span><br><span class=\"line\">&gt; <span class=\"builtin-name\">GET</span> key</span><br><span class=\"line\">(<span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n\n<p>等价于 <code>SET</code> + <code>EXPIRE</code> 的 <code>SETEX</code> 命令：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SETEX <span class=\"type\">key</span> <span class=\"number\">5</span> value1</span><br><span class=\"line\">...                # 等待 <span class=\"number\">5</span>s 后获取</span><br><span class=\"line\">&gt; GET <span class=\"type\">key</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; SETNX <span class=\"type\">key</span> value1  # 如果 <span class=\"type\">key</span> 不存在则 SET 成功</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; SETNX <span class=\"type\">key</span> value1  # 如果 <span class=\"type\">key</span> 存在则 SET 失败</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">0</span></span><br><span class=\"line\">&gt; GET <span class=\"type\">key</span></span><br><span class=\"line\"><span class=\"string\">\"value\"</span>             # 没有改变</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>计数</strong></li>\n</ul>\n<p>如果 value 是一个整数，还可以对它使用 <code>INCR</code> 命令进行 <strong>原子性</strong> 的自增操作，这意味着及时多个客户端对同一个 key 进行操作，也决不会导致竞争的情况：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SET counter <span class=\"number\">100</span></span><br><span class=\"line\">&gt; INCR counter</span><br><span class=\"line\">(<span class=\"built_in\">int</span>eger) <span class=\"number\">101</span></span><br><span class=\"line\">&gt; INCRBY counter <span class=\"number\">50</span></span><br><span class=\"line\">(<span class=\"built_in\">int</span>eger) <span class=\"number\">151</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-list\"><a href=\"#2-list\" class=\"headerlink\" title=\"2. list\"></a>2. list</h4><blockquote>\n<p>Redis 的列表相当于 Java 语言中的 <strong>LinkedList</strong>，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。</p>\n</blockquote>\n<p><strong>链表的基本操作</strong></p>\n<ul>\n<li><code>LPUSH</code> 和 <code>RPUSH</code> 分别可以向 list 的左边（头部）和右边（尾部）添加一个新元素；</li>\n<li><code>LRANGE</code> 命令可以从 list 中取出一定范围的元素；</li>\n<li><code>LINDEX</code> 命令可以从 list 中取出指定下表的元素，相当于 Java 链表操作中的 <code>get(int index)</code> 操作；</li>\n</ul>\n<p>示范：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> rpush mylist A</span></span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> rpush mylist B</span></span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> lpush mylist first</span></span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> lrange mylist 0 -1    <span class=\"comment\"># -1 表示倒数第一个元素, 这里表示从第一个元素到最后一个元素，即所有</span></span></span><br><span class=\"line\">1) \"first\"</span><br><span class=\"line\">2) \"A\"</span><br><span class=\"line\">3) \"B\"</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>list 实现队列</li>\n</ul>\n<p>队列是先进先出的数据结构，常用于消息排队和异步逻辑处理，它会确保元素的访问顺序：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPUSH books python java golang</span></span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> LPOP books</span></span><br><span class=\"line\">\"python\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> LPOP books</span></span><br><span class=\"line\">\"java\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> LPOP books</span></span><br><span class=\"line\">\"golang\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> LPOP books</span></span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>list 实现栈</li>\n</ul>\n<p>栈是先进后出的数据结构，跟队列正好相反：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPUSH books python java golang</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPOP books</span></span><br><span class=\"line\">\"golang\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPOP books</span></span><br><span class=\"line\">\"java\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPOP books</span></span><br><span class=\"line\">\"python\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> RPOP books</span></span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用场景举例：简单的消息队列、分页功能（lrange ）</li>\n</ul>\n<h4 id=\"3-hash\"><a href=\"#3-hash\" class=\"headerlink\" title=\"3. hash\"></a>3. hash</h4><blockquote>\n<p>Redis 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，都是通过 <strong>“数组 + 链表”</strong> 的链地址法来解决部分 <strong>哈希冲突</strong>，同时这样的结构也吸收了两种不同数据结构的优点。</p>\n</blockquote>\n<ul>\n<li>基本操作：</li>\n</ul>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; HSET <span class=\"keyword\">books </span><span class=\"keyword\">java </span><span class=\"string\">\"think in java\"</span>    <span class=\"comment\"># 命令行的字符串如果包含空格则需要使用引号包裹</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; HSET <span class=\"keyword\">books </span>python <span class=\"string\">\"python cookbook\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; HGETALL <span class=\"keyword\">books </span>   <span class=\"comment\"># key 和 value 间隔出现</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"think in java\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"python\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"python cookbook\"</span></span><br><span class=\"line\">&gt; HGET <span class=\"keyword\">books </span><span class=\"keyword\">java</span></span><br><span class=\"line\"><span class=\"keyword\">\"think </span>in <span class=\"keyword\">java\"</span></span><br><span class=\"line\"><span class=\"keyword\">&gt; </span>HSET <span class=\"keyword\">books </span><span class=\"keyword\">java </span><span class=\"string\">\"head first java\"</span>  </span><br><span class=\"line\">(integer) <span class=\"number\">0</span>        <span class=\"comment\"># 因为是更新操作，所以返回 0</span></span><br><span class=\"line\">&gt; HMSET <span class=\"keyword\">books </span><span class=\"keyword\">java </span><span class=\"string\">\"effetive  java\"</span> python <span class=\"string\">\"learning python\"</span>    <span class=\"comment\"># 批量操作</span></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用场景举例：单点登录。存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果。</li>\n</ul>\n<h4 id=\"4-set\"><a href=\"#4-set\" class=\"headerlink\" title=\"4. set\"></a>4. set</h4><blockquote>\n<p>Redis 的集合相当于 Java 语言中的 <strong>HashSet</strong>，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。</p>\n</blockquote>\n<ul>\n<li>基本操作：</li>\n</ul>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; SADD <span class=\"keyword\">books </span><span class=\"keyword\">java</span></span><br><span class=\"line\"><span class=\"keyword\">(integer) </span><span class=\"number\">1</span></span><br><span class=\"line\">&gt; SADD <span class=\"keyword\">books </span><span class=\"keyword\">java </span>   <span class=\"comment\"># 重复</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">&gt; SADD <span class=\"keyword\">books </span>python golang</span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">&gt; SMEMBERS <span class=\"keyword\">books </span>   <span class=\"comment\"># 注意顺序，set 是无序的 </span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"python\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"golang\"</span></span><br><span class=\"line\">&gt; SISMEMBER <span class=\"keyword\">books </span><span class=\"keyword\">java </span>   <span class=\"comment\"># 查询某个 value 是否存在，相当于 contains</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; <span class=\"keyword\">SCARD </span><span class=\"keyword\">books </span>   <span class=\"comment\"># 获取长度</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">&gt; SPOP <span class=\"keyword\">books </span>    <span class=\"comment\"># 弹出一个</span></span><br><span class=\"line\"><span class=\"string\">\"java\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用场景举例：全局去重、计算共同喜好等</li>\n</ul>\n<h4 id=\"5-zset\"><a href=\"#5-zset\" class=\"headerlink\" title=\"5. zset\"></a>5. zset</h4><blockquote>\n<p>这可能使 Redis 最具特色的一个数据结构了，它类似于 Java 中 <strong>SortedSet</strong> 和 <strong>HashMap</strong> 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。它的内部实现用的是一种叫做 <strong>「跳跃表」</strong> 的数据结构。</p>\n</blockquote>\n<ul>\n<li>基本操作</li>\n</ul>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ZADD books <span class=\"number\">9.0</span> <span class=\"string\">\"think in java\"</span></span><br><span class=\"line\">&gt; ZADD books <span class=\"number\">8.9</span> <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\">&gt; ZADD books <span class=\"number\">8.6</span> <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZRANGE books <span class=\"number\">0</span> <span class=\"number\">-1</span>     # 按 score 排序列出，参数区间为排名范围</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"think in java\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZREVRANGE books <span class=\"number\">0</span> <span class=\"number\">-1</span>  # 按 score 逆序列出，参数区间为排名范围</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"think in java\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZCARD books           # 相当于 count()</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZSCORE books <span class=\"string\">\"java concurrency\"</span>   # 获取指定 value 的 score</span><br><span class=\"line\"><span class=\"string\">\"8.9000000000000004\"</span>                # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZRANK books <span class=\"string\">\"java concurrency\"</span>    # 排名</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZRANGEBYSCORE books <span class=\"number\">0</span> <span class=\"number\">8.91</span>        # 根据分值区间遍历 zset</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZRANGEBYSCORE books -inf <span class=\"number\">8.91</span> withscores  # 根据分值区间 (-∞, <span class=\"number\">8.91</span>] 遍历 zset，同时返回分值。inf 代表 infinite。</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"8.5999999999999996\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"java concurrency\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"8.9000000000000004\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ZREM books <span class=\"string\">\"java concurrency\"</span>             # 删除 value</span><br><span class=\"line\">(<span class=\"type\">integer</span>) <span class=\"number\">1</span></span><br><span class=\"line\">&gt; ZRANGE books <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"java cookbook\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"think in java\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用场景举例：排行榜应用取 TOP N 、范围查找</li>\n</ul>\n<h3 id=\"七-Redis常见问题及解决方法\"><a href=\"#七-Redis常见问题及解决方法\" class=\"headerlink\" title=\"七. Redis常见问题及解决方法\"></a>七. Redis常见问题及解决方法</h3><h4 id=\"1-缓存与数据库双写不一致\"><a href=\"#1-缓存与数据库双写不一致\" class=\"headerlink\" title=\"1. 缓存与数据库双写不一致\"></a>1. 缓存与数据库双写不一致</h4><h5 id=\"什么是双写不一致？\"><a href=\"#什么是双写不一致？\" class=\"headerlink\" title=\"什么是双写不一致？\"></a>什么是双写不一致？</h5><p>​        一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是当要执行数据的更新操作的时候，数据库和缓存的数据就会出现不一致的情况。</p>\n<p>从理论上说，只要我们设置了<strong>键的过期时间</strong>，就能保证缓存和数据库的数据<strong>最终一致</strong>。</p>\n<h5 id=\"有哪些解决办法？\"><a href=\"#有哪些解决办法？\" class=\"headerlink\" title=\"有哪些解决办法？\"></a>有哪些解决办法？</h5><ul>\n<li><p>先更新数据库，再删缓存。</p>\n<p>  如果在高并发的场景下，出现数据库与缓存数据不一致的<strong>概率特别低</strong>，也不是没有：</p>\n<blockquote>\n<p>1、 缓存刚好失效<br>2、线程A查询数据库，得一个旧值<br>3、线程B将新值写入数据库<br>4、线程B删除缓存<br>5、线程A将查到的旧值写入缓存</p>\n</blockquote>\n</li>\n<li><p>先删除缓存，再更新数据库。</p>\n<p>  并发场景下分析一下，还是有问题：</p>\n<blockquote>\n<p>线程A删除了缓存<br>线程B查询，发现缓存已不存在<br>线程B去数据库查询得到旧值<br>线程B将旧值写入缓存<br>线程A将新值写入数据库</p>\n</blockquote>\n</li>\n<li><p>将删除缓存、修改数据库、读取缓存等的操作积压到队列里边，实现串行化。</p>\n</li>\n</ul>\n<p>这些方案从根本上来说，只能降低不一致发生的概率，无法完全避免。因此，<strong>有强一致性要求的数据，不能放缓存。</strong></p>\n<h4 id=\"2-缓存穿透\"><a href=\"#2-缓存穿透\" class=\"headerlink\" title=\"2. 缓存穿透\"></a>2. 缓存穿透</h4><h5 id=\"什么是缓存穿透？\"><a href=\"#什么是缓存穿透？\" class=\"headerlink\" title=\"什么是缓存穿透？\"></a>什么是缓存穿透？</h5><p>​        缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：我们有一张数据库表，ID都是从1开始的，但是可能有黑客想把我们的数据库搞垮，每次请求的ID都是负数，导致缓存失去意义，请求都会去找数据库。</p>\n<h5 id=\"有哪些解决办法？-1\"><a href=\"#有哪些解决办法？-1\" class=\"headerlink\" title=\"有哪些解决办法？\"></a>有哪些解决办法？</h5><ol>\n<li><p>缓存无效 key</p>\n<p> ​        如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code>。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。如果用 Java 代码展示的话，差不多是下面这样的：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObjectInclNullById</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从缓存中获取数据</span></span><br><span class=\"line\">    Object cacheValue = cache.get(id);</span><br><span class=\"line\">    <span class=\"comment\">// 缓存为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheValue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从数据库中获取</span></span><br><span class=\"line\">        Object storageValue = storage.get(key);</span><br><span class=\"line\">        <span class=\"comment\">// 缓存空对象</span></span><br><span class=\"line\">        cache.set(key, storageValue);</span><br><span class=\"line\">        <span class=\"comment\">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (storageValue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class=\"line\">            cache.expire(key, <span class=\"number\">60</span> * <span class=\"number\">5</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> storageValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cacheValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>布隆过滤器</p>\n<p> ​        布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中，我们需要的就是判断 key 是否合法。</p>\n<p> ​        具体做法：内部维护一系列合法有效的 Key都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>\n<p> ​        但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>\n<hr>\n<p> <strong><em>布隆过滤器原理</em>：</strong>  </p>\n<p> <strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>\n<ol>\n<li><p>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</p>\n</li>\n<li><p>根据得到的哈希值，在位数组中把对应下标的值置为 1。</p>\n</li>\n</ol>\n<p> <strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p>\n<ol>\n<li><p>对给定元素再次进行相同的哈希计算；</p>\n</li>\n<li><p>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>\n<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-缓存雪崩\"><a href=\"#3-缓存雪崩\" class=\"headerlink\" title=\"3. 缓存雪崩\"></a>3. 缓存雪崩</h4><h5 id=\"什么是缓存雪崩？\"><a href=\"#什么是缓存雪崩？\" class=\"headerlink\" title=\"什么是缓存雪崩？\"></a>什么是缓存雪崩？</h5><p>​        缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，数据库的压力可想而知，可能直接就挂了。</p>\n<p>​        举个例子：系统的缓存模块出了问题比如宕机导致不可用，造成系统的所有访问，都要走数据库。</p>\n<p>​        还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong></p>\n<p>​        举个例子 ：秒杀开始12个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是12个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p>\n<h5 id=\"有哪些解决办法？-2\"><a href=\"#有哪些解决办法？-2\" class=\"headerlink\" title=\"有哪些解决办法？\"></a>有哪些解决办法？</h5><p>Redis服务不可用：</p>\n<ol>\n<li>采用Redis集群，避免单机出现问题整个缓存服务都没办法使用。</li>\n<li>限流，避免同时处理大量的请求。</li>\n</ol>\n<p>热点缓存失效：</p>\n<ol>\n<li>设置不同的失效时间，比如随机设置缓存的失效时间。</li>\n<li>缓存永不失效。</li>\n</ol>\n"},{"title":"滚雪球","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":null,"abbrlink":"c15d","date":"2020-12-19T16:00:00.000Z","subtitle":null,"_content":"\n### 滚雪球","source":"_posts/read-test2.md","raw":"---\ntitle: 滚雪球\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop:\ntags:\n  - finance\ncategories:\n  - life\nabbrlink: c15d\ndate: 2020-12-20 00:00:00\nsubtitle:\n---\n\n### 滚雪球","slug":"read-test2","published":1,"updated":"2021-12-10T09:05:27.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1b30011acbf5a2sf56i","content":"<h3 id=\"滚雪球\"><a href=\"#滚雪球\" class=\"headerlink\" title=\"滚雪球\"></a>滚雪球</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"滚雪球\"><a href=\"#滚雪球\" class=\"headerlink\" title=\"滚雪球\"></a>滚雪球</h3>"},{"title":"Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":null,"abbrlink":"9f70","date":"2021-06-03T16:00:00.000Z","_content":"\n#### git push错误\n\nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\n\n#### 解决方案：\n\n1. ###### 登录github → Settings → Developer settings → Personal access tokens → Generate new token\n\n2. ###### 复制新生成的token（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），执行：\n\n    ```\n    git remote set-url origin https://$new-token@github.com/$username/$repo-name.git\n    ```\n\n3. ###### 重新push即可","source":"_posts/git-push-error.md","raw":"---\ntitle: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop: \ntags:\n  - git\ncategories:\n  - work\nabbrlink: 9f70\ndate: 2021-06-04 00:00:00\n---\n\n#### git push错误\n\nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\n\n#### 解决方案：\n\n1. ###### 登录github → Settings → Developer settings → Personal access tokens → Generate new token\n\n2. ###### 复制新生成的token（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），执行：\n\n    ```\n    git remote set-url origin https://$new-token@github.com/$username/$repo-name.git\n    ```\n\n3. ###### 重新push即可","slug":"git-push-error","published":1,"updated":"2021-12-10T09:49:12.892Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1b40014acbfb0yjfuzw","content":"<h4 id=\"git-push错误\"><a href=\"#git-push错误\" class=\"headerlink\" title=\"git push错误\"></a>git push错误</h4><p>remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</p>\n<h4 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h4><ol>\n<li><h6 id=\"登录github-→-Settings-→-Developer-settings-→-Personal-access-tokens-→-Generate-new-token\"><a href=\"#登录github-→-Settings-→-Developer-settings-→-Personal-access-tokens-→-Generate-new-token\" class=\"headerlink\" title=\"登录github → Settings → Developer settings → Personal access tokens → Generate new token\"></a>登录github → Settings → Developer settings → Personal access tokens → Generate new token</h6></li>\n<li><h6 id=\"复制新生成的token（ghp-YVupNqZjSNU0wB1xu61jqOjAOEHcs826HsTK），执行：\"><a href=\"#复制新生成的token（ghp-YVupNqZjSNU0wB1xu61jqOjAOEHcs826HsTK），执行：\" class=\"headerlink\" title=\"复制新生成的token（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），执行：\"></a>复制新生成的token（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），执行：</h6> <figure class=\"highlight dsconfig\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">git </span><span class=\"string\">remote </span><span class=\"built_in\">set-url</span> <span class=\"string\">origin </span><span class=\"string\">https:</span>//$<span class=\"string\">new-token@</span><span class=\"string\">github.</span><span class=\"string\">com/</span>$<span class=\"string\">username/</span>$<span class=\"string\">repo-name.</span><span class=\"string\">git</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><h6 id=\"重新push即可\"><a href=\"#重新push即可\" class=\"headerlink\" title=\"重新push即可\"></a>重新push即可</h6></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"git-push错误\"><a href=\"#git-push错误\" class=\"headerlink\" title=\"git push错误\"></a>git push错误</h4><p>remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</p>\n<h4 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h4><ol>\n<li><h6 id=\"登录github-→-Settings-→-Developer-settings-→-Personal-access-tokens-→-Generate-new-token\"><a href=\"#登录github-→-Settings-→-Developer-settings-→-Personal-access-tokens-→-Generate-new-token\" class=\"headerlink\" title=\"登录github → Settings → Developer settings → Personal access tokens → Generate new token\"></a>登录github → Settings → Developer settings → Personal access tokens → Generate new token</h6></li>\n<li><h6 id=\"复制新生成的token（ghp-YVupNqZjSNU0wB1xu61jqOjAOEHcs826HsTK），执行：\"><a href=\"#复制新生成的token（ghp-YVupNqZjSNU0wB1xu61jqOjAOEHcs826HsTK），执行：\" class=\"headerlink\" title=\"复制新生成的token（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），执行：\"></a>复制新生成的token（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），执行：</h6> <figure class=\"highlight dsconfig\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">git </span><span class=\"string\">remote </span><span class=\"built_in\">set-url</span> <span class=\"string\">origin </span><span class=\"string\">https:</span>//$<span class=\"string\">new-token@</span><span class=\"string\">github.</span><span class=\"string\">com/</span>$<span class=\"string\">username/</span>$<span class=\"string\">repo-name.</span><span class=\"string\">git</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><h6 id=\"重新push即可\"><a href=\"#重新push即可\" class=\"headerlink\" title=\"重新push即可\"></a>重新push即可</h6></li>\n</ol>\n"},{"title":"读源码的实用技巧","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"abbrlink":"6fff","date":"2021-11-09T16:00:00.000Z","top":null,"subtitle":null,"_content":"\n## 读源码的实用技巧\n\n### 1. 查看Java native方法源码\n\n   Java底层的native方法可以在OpenJDK中通过`类名_方法名`（方法名首字母要大写）的形式找到该方法对应的源码实现\n\n   eg：分配直接内存的方法`ByteBuffer.allocateDirect(1024)`源码跟下去会发现核心代码实现是Unsafe.class中的如下方法：\n\n   ```java\nprivate native long allocateMemory0(long var1);\n   ```\n\n   想要查看 Unsafe::allocateMemory0(long var1)的源码，可以在OpenJDK中搜索Unsafe_AllocateMemory0，如下：\n\n   ```c\nUNSAFE_ENTRY(jlong, Unsafe_AllocateMemory0(JNIEnv *env, jobject unsafe, jlong size)) {\n  size_t sz = (size_t)size;\n\n  assert(is_aligned(sz, HeapWordSize), \"sz not aligned\");\n\n  void* x = os::malloc(sz, mtOther);\n\n  return addr_to_java(x);\n} UNSAFE_END\n   ```\n\n### 2. 查看操作系统方法介绍\n\n   上述`Unsafe_AllocateMemory0`方法中核心实现方法为`os::malloc(sz, mtOther)`，`malloc`是操作系统的原生方法，此类方法可以借助Linux系统命令`man $方法名 `来查看方法对应的手册条目介绍，如下（不同操作系统可能有略微差别）：\n\n   ```\n☁  ~  man malloc\n   ```\n\n   ```\nMALLOC(3)                BSD Library Functions Manual                MALLOC(3)\n\nNAME\n     calloc, free, malloc, realloc, reallocf, valloc, aligned_alloc -- memory allocation\n\nSYNOPSIS\n     #include <stdlib.h>\n\n     void *\n     calloc(size_t count, size_t size);\n\n     void\n     free(void *ptr);\n\n     void *\n     malloc(size_t size);\n        \n        ...\n\nDESCRIPTION\n     The malloc(), calloc(), valloc(), realloc(), and reallocf() functions\n     allocate memory.  The allocated memory is aligned such that it can be\n     used for any data type, including AltiVec- and SSE-related types.  The\n     aligned_alloc() function allocates memory with the requested alignment.\n     The free() function frees allocations that were created via the preceding\n     allocation functions.\n\n     The malloc() function allocates size bytes of memory and returns a\n     pointer to the allocated memory.\n     ......\n   ```\n### 3. TODO 持续更新\n\n   ","source":"_posts/source-code.md","raw":"---\ntitle: 读源码的实用技巧\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntags:\n  - source code\ncategories:\n  - work\nabbrlink: 6fff\ndate: 2021-11-10 00:00:00\ntop:\nsubtitle:\n---\n\n## 读源码的实用技巧\n\n### 1. 查看Java native方法源码\n\n   Java底层的native方法可以在OpenJDK中通过`类名_方法名`（方法名首字母要大写）的形式找到该方法对应的源码实现\n\n   eg：分配直接内存的方法`ByteBuffer.allocateDirect(1024)`源码跟下去会发现核心代码实现是Unsafe.class中的如下方法：\n\n   ```java\nprivate native long allocateMemory0(long var1);\n   ```\n\n   想要查看 Unsafe::allocateMemory0(long var1)的源码，可以在OpenJDK中搜索Unsafe_AllocateMemory0，如下：\n\n   ```c\nUNSAFE_ENTRY(jlong, Unsafe_AllocateMemory0(JNIEnv *env, jobject unsafe, jlong size)) {\n  size_t sz = (size_t)size;\n\n  assert(is_aligned(sz, HeapWordSize), \"sz not aligned\");\n\n  void* x = os::malloc(sz, mtOther);\n\n  return addr_to_java(x);\n} UNSAFE_END\n   ```\n\n### 2. 查看操作系统方法介绍\n\n   上述`Unsafe_AllocateMemory0`方法中核心实现方法为`os::malloc(sz, mtOther)`，`malloc`是操作系统的原生方法，此类方法可以借助Linux系统命令`man $方法名 `来查看方法对应的手册条目介绍，如下（不同操作系统可能有略微差别）：\n\n   ```\n☁  ~  man malloc\n   ```\n\n   ```\nMALLOC(3)                BSD Library Functions Manual                MALLOC(3)\n\nNAME\n     calloc, free, malloc, realloc, reallocf, valloc, aligned_alloc -- memory allocation\n\nSYNOPSIS\n     #include <stdlib.h>\n\n     void *\n     calloc(size_t count, size_t size);\n\n     void\n     free(void *ptr);\n\n     void *\n     malloc(size_t size);\n        \n        ...\n\nDESCRIPTION\n     The malloc(), calloc(), valloc(), realloc(), and reallocf() functions\n     allocate memory.  The allocated memory is aligned such that it can be\n     used for any data type, including AltiVec- and SSE-related types.  The\n     aligned_alloc() function allocates memory with the requested alignment.\n     The free() function frees allocations that were created via the preceding\n     allocation functions.\n\n     The malloc() function allocates size bytes of memory and returns a\n     pointer to the allocated memory.\n     ......\n   ```\n### 3. TODO 持续更新\n\n   ","slug":"source-code","published":1,"updated":"2021-12-10T09:48:33.325Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1bp001tacbf1wwe1omc","content":"<h2 id=\"读源码的实用技巧\"><a href=\"#读源码的实用技巧\" class=\"headerlink\" title=\"读源码的实用技巧\"></a>读源码的实用技巧</h2><h3 id=\"1-查看Java-native方法源码\"><a href=\"#1-查看Java-native方法源码\" class=\"headerlink\" title=\"1. 查看Java native方法源码\"></a>1. 查看Java native方法源码</h3><p>   Java底层的native方法可以在OpenJDK中通过<code>类名_方法名</code>（方法名首字母要大写）的形式找到该方法对应的源码实现</p>\n<p>   eg：分配直接内存的方法<code>ByteBuffer.allocateDirect(1024)</code>源码跟下去会发现核心代码实现是Unsafe.class中的如下方法：</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">native</span> <span class=\"keyword\">long</span> <span class=\"title\">allocateMemory0</span><span class=\"params\">(<span class=\"keyword\">long</span> var1)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>   想要查看 Unsafe::allocateMemory0(long var1)的源码，可以在OpenJDK中搜索Unsafe_AllocateMemory0，如下：</p>\n   <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory0(JNIEnv *env, jobject unsafe, jlong <span class=\"built_in\">size</span>)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> sz = (<span class=\"keyword\">size_t</span>)<span class=\"built_in\">size</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  assert(is_aligned(sz, HeapWordSize), <span class=\"string\">\"sz not aligned\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span>* x = os::<span class=\"built_in\">malloc</span>(sz, mtOther);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> addr_to_java(x);</span><br><span class=\"line\">&#125; UNSAFE_END</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-查看操作系统方法介绍\"><a href=\"#2-查看操作系统方法介绍\" class=\"headerlink\" title=\"2. 查看操作系统方法介绍\"></a>2. 查看操作系统方法介绍</h3><p>   上述<code>Unsafe_AllocateMemory0</code>方法中核心实现方法为<code>os::malloc(sz, mtOther)</code>，<code>malloc</code>是操作系统的原生方法，此类方法可以借助Linux系统命令<code>man $方法名</code>来查看方法对应的手册条目介绍，如下（不同操作系统可能有略微差别）：</p>\n   <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">☁  ~  man <span class=\"built_in\">malloc</span></span><br></pre></td></tr></table></figure>\n\n   <figure class=\"highlight irpf90\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MALLOC(<span class=\"number\">3</span>)                BSD Library Functions Manual                MALLOC(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">NAME</span></span><br><span class=\"line\">     calloc, <span class=\"keyword\">free</span>, malloc, realloc, reallocf, valloc, aligned_alloc -- memory allocation</span><br><span class=\"line\"></span><br><span class=\"line\">SYNOPSIS</span><br><span class=\"line\">     #<span class=\"keyword\">include</span> &lt;stdlib.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">     void *</span><br><span class=\"line\">     calloc(size_t <span class=\"built_in\">count</span>, size_t <span class=\"built_in\">size</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">     void</span><br><span class=\"line\">     <span class=\"keyword\">free</span>(void *ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">     void *</span><br><span class=\"line\">     malloc(size_t <span class=\"built_in\">size</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">DESCRIPTION</span><br><span class=\"line\">     The malloc(), calloc(), valloc(), realloc(), and reallocf() functions</span><br><span class=\"line\">     <span class=\"built_in\">allocate</span> memory.  The <span class=\"built_in\">allocated</span> memory is aligned such that it can be</span><br><span class=\"line\">     used for <span class=\"built_in\">any</span> <span class=\"keyword\">data</span> <span class=\"keyword\">type</span>, including AltiVec- and SSE-related types.  The</span><br><span class=\"line\">     aligned_alloc() <span class=\"function\"><span class=\"keyword\">function</span></span> allocates memory with the requested alignment.</span><br><span class=\"line\">     The <span class=\"keyword\">free</span>() <span class=\"function\"><span class=\"keyword\">function</span></span> frees allocations that were created via the preceding</span><br><span class=\"line\">     allocation functions.</span><br><span class=\"line\"></span><br><span class=\"line\">     The malloc() <span class=\"function\"><span class=\"keyword\">function</span></span> allocates <span class=\"built_in\">size</span> bytes of memory and returns a</span><br><span class=\"line\">     <span class=\"keyword\">pointer</span> to the <span class=\"built_in\">allocated</span> memory.</span><br><span class=\"line\">     ......</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-TODO-持续更新\"><a href=\"#3-TODO-持续更新\" class=\"headerlink\" title=\"3. TODO 持续更新\"></a>3. TODO 持续更新</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"读源码的实用技巧\"><a href=\"#读源码的实用技巧\" class=\"headerlink\" title=\"读源码的实用技巧\"></a>读源码的实用技巧</h2><h3 id=\"1-查看Java-native方法源码\"><a href=\"#1-查看Java-native方法源码\" class=\"headerlink\" title=\"1. 查看Java native方法源码\"></a>1. 查看Java native方法源码</h3><p>   Java底层的native方法可以在OpenJDK中通过<code>类名_方法名</code>（方法名首字母要大写）的形式找到该方法对应的源码实现</p>\n<p>   eg：分配直接内存的方法<code>ByteBuffer.allocateDirect(1024)</code>源码跟下去会发现核心代码实现是Unsafe.class中的如下方法：</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">native</span> <span class=\"keyword\">long</span> <span class=\"title\">allocateMemory0</span><span class=\"params\">(<span class=\"keyword\">long</span> var1)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>   想要查看 Unsafe::allocateMemory0(long var1)的源码，可以在OpenJDK中搜索Unsafe_AllocateMemory0，如下：</p>\n   <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory0(JNIEnv *env, jobject unsafe, jlong <span class=\"built_in\">size</span>)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> sz = (<span class=\"keyword\">size_t</span>)<span class=\"built_in\">size</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  assert(is_aligned(sz, HeapWordSize), <span class=\"string\">\"sz not aligned\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span>* x = os::<span class=\"built_in\">malloc</span>(sz, mtOther);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> addr_to_java(x);</span><br><span class=\"line\">&#125; UNSAFE_END</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-查看操作系统方法介绍\"><a href=\"#2-查看操作系统方法介绍\" class=\"headerlink\" title=\"2. 查看操作系统方法介绍\"></a>2. 查看操作系统方法介绍</h3><p>   上述<code>Unsafe_AllocateMemory0</code>方法中核心实现方法为<code>os::malloc(sz, mtOther)</code>，<code>malloc</code>是操作系统的原生方法，此类方法可以借助Linux系统命令<code>man $方法名</code>来查看方法对应的手册条目介绍，如下（不同操作系统可能有略微差别）：</p>\n   <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">☁  ~  man <span class=\"built_in\">malloc</span></span><br></pre></td></tr></table></figure>\n\n   <figure class=\"highlight irpf90\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MALLOC(<span class=\"number\">3</span>)                BSD Library Functions Manual                MALLOC(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">NAME</span></span><br><span class=\"line\">     calloc, <span class=\"keyword\">free</span>, malloc, realloc, reallocf, valloc, aligned_alloc -- memory allocation</span><br><span class=\"line\"></span><br><span class=\"line\">SYNOPSIS</span><br><span class=\"line\">     #<span class=\"keyword\">include</span> &lt;stdlib.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">     void *</span><br><span class=\"line\">     calloc(size_t <span class=\"built_in\">count</span>, size_t <span class=\"built_in\">size</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">     void</span><br><span class=\"line\">     <span class=\"keyword\">free</span>(void *ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">     void *</span><br><span class=\"line\">     malloc(size_t <span class=\"built_in\">size</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">DESCRIPTION</span><br><span class=\"line\">     The malloc(), calloc(), valloc(), realloc(), and reallocf() functions</span><br><span class=\"line\">     <span class=\"built_in\">allocate</span> memory.  The <span class=\"built_in\">allocated</span> memory is aligned such that it can be</span><br><span class=\"line\">     used for <span class=\"built_in\">any</span> <span class=\"keyword\">data</span> <span class=\"keyword\">type</span>, including AltiVec- and SSE-related types.  The</span><br><span class=\"line\">     aligned_alloc() <span class=\"function\"><span class=\"keyword\">function</span></span> allocates memory with the requested alignment.</span><br><span class=\"line\">     The <span class=\"keyword\">free</span>() <span class=\"function\"><span class=\"keyword\">function</span></span> frees allocations that were created via the preceding</span><br><span class=\"line\">     allocation functions.</span><br><span class=\"line\"></span><br><span class=\"line\">     The malloc() <span class=\"function\"><span class=\"keyword\">function</span></span> allocates <span class=\"built_in\">size</span> bytes of memory and returns a</span><br><span class=\"line\">     <span class=\"keyword\">pointer</span> to the <span class=\"built_in\">allocated</span> memory.</span><br><span class=\"line\">     ......</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-TODO-持续更新\"><a href=\"#3-TODO-持续更新\" class=\"headerlink\" title=\"3. TODO 持续更新\"></a>3. TODO 持续更新</h3>"},{"title":"JAVA知识点汇总","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":1,"abbrlink":"2de3","date":"2020-10-15T12:50:34.000Z","subtitle":null,"_content":"\n## JVM内存模型\n\n### 程序计数器（线程私有）\n\n> 对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。\n\n- 当前线程的行号指示器\n- 唯一一个不会抛出OutOfMemory的内存区域\n\n### Java虚拟机栈（线程私有）\n\n> 栈描述的是Java方法执行的内存模型。\n>\n> 每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。\n>\n> 局部变量表所需要的内存空间在编译期完成分配，当进入一个方法时，这个方法在栈中需要分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表大小。\n\n- 每个栈帧存放内容：\n    1. 局部变量表（主要）： 方法参数、局部变量、编译器已知的数据类型\n    2. 操作数栈\n    3. 动态链接\n    4. 方法返回地址\n- 可能出现两种异常：\n    1. 线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverflowError。\n    2. 虚拟机栈空间可以动态扩展，当动态扩展是无法申请到足够的空间时，抛出OutOfMemory异常。\n\n### 本地方法栈（线程私有）\n\n- 本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++\n\n### 堆（线程共享）\n\n> 标量替换\n>\n> 1、标量是指不可分割的量，如java中基本数据类型和reference类型，相对的一个数据可以继续分解，称为聚合量；\n>\n> 2、如果把一个对象拆散，将其成员变量恢复到基本类型来访问就叫做标量替换；\n>\n> 3、如果逃逸分析发现一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是在栈上创建若干个成员变量；\n\n- 存放对象实例及数组， 但随着JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对(标量替换)\n- 大小可固定也可扩展，如果堆中没有内存完成实例分配，而且堆无法扩展将报OOM错误(OutOfMemoryError)\n\n### 方法区（线程共享）\n\n- 用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。\n\n## 垃圾回收\n\n### 判断对象是否存活算法\n\n- 引用计数法\n    - 原理：通过在对象头中分配一个空间来保存该对象被引用的次数。如果该对象被其它对象引用，则它的引用计数+1，如果删除对该对象的引用，那么它的引用计数就-1，当该对象的引用计数为0时，那么该对象就会被回收。\n    - 缺点：循环引用问题---如果有两个对象相互引用，那么这两个对象就不能被回收，因为它们的引用计数始终为1。这也就是我们常说的“内存泄漏”问题。\n- 可达性分析法（主流）\n    - 原理：从GCroot结点开始向下搜索，路径称为引用链，当对象没有任何一条引用链链接的时候，就认为这个对象是垃圾，并进行回收。\n    - 可作为GCroot的对象（GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收）：\n        1. 虚拟机栈（局部变量表）---局部变量或参数\n        2. 方法区中的类静态属性引用的对象\n        3. 方法区中的常量引用的对象\n        4. 本地方法栈中JNI（native方法）引用的对象\n\n### 如何回收---三大垃圾收集算法\n\n- 1. 标记-清除法\n\n      - 概念：\n        1. mutator：应用程序本身，负责NEW(分配内存)、READ(从内存中读取内容)、WRITE(将内容写入内存)\n        2. collector：垃圾收集器，回收不再使用的内存，供mutator进行NEW操作\n      - 算法原理：标记阶段和清除阶段\n        - 标记阶段：collector从mutator根对象开始进行遍历，对从mutator根对象可以访问到的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象。\n        - 清除阶段：collector对堆内存(heap memory)从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象-通过读取对象的header信息，则就将其回收。\n        - Tips：Collector在进行标记和清除阶段时会将整个应用程序暂停(mutator)，等待标记清除结束后才会恢复应用程序的运行，这也是Stop-The-World这个单词的来历。\n      - 缺点：垃圾收集后有可能会造成大量的内存碎片，假设一个方格代表1个单位的内存，如果有一个对象需要占用3个内存单位的话，那么就会导致Mutator一直处于暂停状态，而Collector一直在尝试进行垃圾收集，直到Out of Memory。\n\n- 2.复制算法\n\n    - 算法原理： 将堆内存对半分为两个半区，只用其中一个半区来进行对象内存的分配，如果在这个半区内存不够给新的对象分配了，那么就开始进行垃圾收集，将这个半区中的所有可达对象都拷贝到另外一个半区中去，然后继续在另外那个半区进行新对象的内存分配。\n    - 优点：解决内存碎片问题\n    - 缺点：可用堆内存减少了一半\n    - 适用场景：回收小的、存活期短的对象，主要针对新生代内存收集方法\n\n- 3.标记-整理算法\n\n    - 算法原理： 标记和整理阶段。\n\n        - 标记阶段与标记清除算法一样\n        - 整理阶段：移动所有的可达对象到堆内存的同一个区域中，使他们紧凑的排列在一起，从而将所有非可达对象释放出来的空闲内存都集中在一起，通过这样的方式来达到减少内存碎片的目的。\n\n    - 优点：解决内存碎片问题\n\n    - 缺点：引用额外空间来保存迁移地址，需要遍历多次堆内存\n\n    - 使用场景：主要针对的是老年代内存收集方法\n\n        > 新生代和老年代大小分配： > 响应时间和吞吐量优先的应用，尽可能设置大的新生代和小的老年代\n\n- 分代收集算法\n\n    - 算法原理：根据对象存活的生命周期将内存划分为若干个不同的区域。对不同区域采用不同的回收算法\n    - 新生代\n        - 新生代包括：\n            1. Eden 伊甸园\n            2. Survivor 存活区\n            3. Tenured Gen 养老区\n        - 采取**复制算法**，每次垃圾回收都要回收大部分对象，复制操作较少。一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。\n    - 老年代\n        - 采取**标记整理算法**，每次回收都只回收少量对象\n\n### 如何回收---常见垃圾回收器\n\n- Serial/Serial Old\n\n    - 特点：\n        1. 最古老的的垃圾收集器。\n        2. 单线程垃圾收集器，在它进行垃圾收集时，必须暂停所有用户线程。\n        3. Serial主要针对新生代，采用复制算法。Serial Old针对老年代，采用标记整理算法\n    - 优点：简单高效\n    - 缺点：停顿\n\n- ParNew\n\n    - 特点：\n\n        ​\tSerial的多线程版本\n\n- Parallel Scavenge\n\n    - 特点：\n        1. 并行收集器，不需要暂停\n        2. 新生代，采用复制算法\n\n- Parallel Old\n\n    - 特点：\n        1. Parallel Scavenge老年代版本，并行\n        2. 老年代，标记整理算法\n\n- CMS（Concurrent Mark Sweep）\n\n    - 特点：\n        1. 并发收集\n        2. 采用标记-清除算法\n    - 优点：快\n    - 缺点：\n        1. 占用CPU\n        2. 浮动垃圾\n        3. 出现ConcurrentMode Failure\n        4. 空间碎片\n\n- G1\n\n    - 特点\n        1. 当今最前沿的收集器，面向服务端应用\n        2. 并行与并发收集器，能建立可预测的停顿时间模型。\n\n按代分类\n\n- 年轻代收集器\n    - Serial、ParNew、Parallel Scavenge\n- 老年代收集器\n    - Serial Old、Parallel Old、CMS收集器\n- 特殊收集器\n    - G1收集器[新型，不在年轻、老年代范畴内]\n\n## 类加载\n\n### 加载过程：\n\n- 加载\n\n    1. 通过全类名获取定义此类的二进制字节流\n    2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构\n    3. 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口\n    4. Tips：一个非数组类的加载阶段（获取类的二进制字节流）是可控性最强的阶段，这一步我们可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。\n\n- 验证\n\n    - 目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全。 主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证。\n\n        ![image20210918170036312](https://i.loli.net/2021/09/18/F1BQWefNcAYUEDy.png)\n\n- 准备\n\n    - 为类变量（static修饰的字段变量）分配内存并且设置该类变量的初始值，（如static int i = 5 这里只是将 i 赋值为0，在初始化的阶段再把 i 赋值为5)，这里不包含final修饰的static ，因为final在编译的时候就已经分配了。这里不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象分配到Java堆中。\n\n- 解析\n\n    - 主要的任务是把常量池中的符号引用替换成直接引用，也就是得到类或者字段、方法在内存中的指针或者偏移量。\n\n- 初始化\n\n    - 如果该类具有父类就对父类进行初始化，执行其静态初始化器（静态代码块）和静态初始化成员变量。（前面已经对static 初始化了默认值，这里我们对它进行赋值，成员变量也将被初始化）\n\n        ![image20210918170449021](https://i.loli.net/2021/09/18/RLuVIpE7OWAx4Mz.png)\n\n### 类与类加载器\n\n- 一旦一个类被加载到JVM中，同一个类就不会被再次载入了。\n- 在JVM中，一个类用其全类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。\n- JVM预定义有三种类加载器\n    - 1.根类加载器\n        - 加载 Java 的核心类（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class），由C++实现，不是ClassLoader子类\n    - 2.扩展类加载器\n        - 它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。\n    - 3.系统类加载器\n        - 它负责在JVM启动时加载CLASSPATH环境变量所指定的JAR包和类路径。通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。用户自定义的类加载器默认以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。\n\n### 类加载机制\n\n- 1.全盘负责\n\n    - 当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入。\n\n- 2.双亲委派\n\n    - 如果一个类加载器收到了类加载请求，不会自己直接加载，而是把请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。\n\n        ![image20210918170625728](https://i.loli.net/2021/09/18/tJyd5oZ3aBS1pm9.png)\n\n    - 优势\n\n        - 1.避免类的重复加载。当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。\n        - 2.防止核心API库被随意篡改。假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现该类已被加载，则直接返回已加载过的Integer.class。\n\n- 3.缓存机制\n\n    - 该机制保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为什么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。\n\n### forName和loaderClass区别\n\n- Class.forName()得到的class是已经初始化完成的。\n- Classloader.loaderClass得到的class是还没有链接（验证，准备，解析三个过程被称为链接）的。\n\n### 对象创建过程\n\n- 在准备实例化一个类的对象前，首先准备实例化该类的父类，依次递归直到递归到Object类。此时，首先实例化Object类，再依次对以下各类进行实例化，直到完成对目标类的实例化。具体而言，在实例化每个类时，都遵循如下顺序：先依次执行实例变量初始化和实例代码块初始化，再执行构造函数初始化。也就是说，编译器会将实例变量初始化和实例代码块初始化相关代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后，构造函数本身的代码之前。\n\n### 对象的内存布局\n\n- 对象头（markword）\n\n    - 32位系统下，对象头8字节，64位则是16个字节\n\n    - 不同状态下存放数据\n\n        ![image20210918171629651](https://i.loli.net/2021/09/18/5UlmYsTDcFwKuX9.png)\n\n- 实例数据\n\n    - 存放对象程序中各种类型的字段类型，不管是从父类中继承下来的还是在子类中定义的。\n    - 分配策略:相同宽度的字段总是放在一起，比如double和long\n\n- 对齐填充\n\n    - 仅起到占位符的作用满足JVM要求。\n    - 由于HotSpot规定对象的大小必须是8的整数倍，对象头刚好是整数倍，如果实例数据不是的话，就需要占位符对齐填充。\n\n## synchronized\n\n### 具有可见性和原子性\n\n### JMM关于synchronized的两条规定：\n\n- 线程解锁前，必须把共享变量的最新值刷新到主内存中\n- 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时，需要从主内存中重新读取最新的值\n\n### 线程执行互斥代码的过程：\n\n1. 获得互斥锁\n2. 清空工作内存\n3. 从主内存拷贝变量的最新副本到工作的内存\n4. 执行代码\n5. 将更改后的共享变量的值刷新到主内存\n6. 释放互斥锁\n\n### 锁升级\n\n1. 检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁\n2. 如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1\n3. 如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。\n4. 当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁\n5. 如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。\n6. 如果自旋成功则依然处于轻量级状态。\n7. 如果自旋失败，则升级为重量级锁。\n\n### synchronized 能防止指令重排序吗？\n\n- synchronized不能防止指令重排序，但是能保证有序性，这和volatile实现有序性的方式不同，synchronized是通过互斥锁来保证有序性，即在单线程中无论指令如何重排序，其产生的结果对于其他线程来说是一致的。而volatile是通过内存屏障实现的有序性，即防止指令重排序来保证有序性。\n\n### 死锁\n\n- 两个线程都在等待对方先完成，造成程序的停滞。\n\n- 例如，现在张三想要李四的画，李四想要张三的书，张三对李四说“把你的画给我，我就给你书”，李四也对张三说“把你的书给我，我就给你画”两个人互相等对方先行动，就这么干等没有结果，这实际上就是死锁的概念。示例代码如下：\n\n    ```java\n    // 定义张三类\n    class Zhangsan {\n        public void say() {\n            System.out.println(\"张三对李四说：“你给我画，我就把书给你。”\");\n        }\n    \n        public void get() {\n            System.out.println(\"张三得到画了。\");\n        }\n    }\n    \n    // 定义李四类\n    class Lisi {\n        public void say() {\n            System.out.println(\"李四对张三说：“你给我书，我就把画给你”\");\n        }\n    \n        public void get() {\n            System.out.println(\"李四得到书了。\");\n        }\n    \n    }\n    \n    public class ThreadDeadLock implements Runnable {\n    \n        private static Zhangsan zs = new Zhangsan();    // 实例化static型对象\n    \n        private static Lisi ls = new Lisi();    // 实例化static型对象\n    \n        private boolean flag = false; // 声明标志位，判断那个先说话\n    \n        public void run() { // 覆写run()方法\n            if (flag) {\n                synchronized (zs) {  // 同步张三\n                    zs.say();\n                    try {\n                        Thread.sleep(500);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    synchronized (ls) {\n                        zs.get();\n                    }\n                }\n            } else {\n                synchronized (ls) {\n                    ls.say();\n                    try {\n                        Thread.sleep(500);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    synchronized (zs) {\n                        ls.get();\n                    }\n                }\n            }\n        }\n    \n        public static void main(String args[]) {\n            ThreadDeadLock t1 = new ThreadDeadLock();   // 控制张三\n            ThreadDeadLock t2 = new ThreadDeadLock();   // 控制李四\n            t1.flag = true;\n            t2.flag = false;\n            Thread thA = new Thread(t1);\n            Thread thB = new Thread(t2);\n            thA.start();\n            thB.start();\n        }\n    }\n    // 程序运行结果： 李四对张三说：“你给我书，我就把画给你” 张三对李四说：“你给我画，我就把书给你。\n    ```\n\n- 避免死锁\n\n    - 加锁顺序（线程按照一定的顺序加锁）\n    - 加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）\n    - 死锁检测\n\n## JUC\n\n### volatile\n\n- JMM模型\n\n    ![image20210918171727328](https://i.loli.net/2021/09/18/F23tz5UOqCEwJbA.png)\n\n- 可见性\n\n    - 修改了变量后，新值对其他线程立即可见（基于内存屏障禁止指令重排实现可见性）：\n        1. 对volatile变量执行写操作时，会在写操作后加入一条store屏障指令\n        2. 对volatile变量执行读操作时，会在读操作前加入一条load屏障指令\n    - 线程写volatile变量的过程：\n        1. 改变线程工作内存中volatile变量副本的值\n        2. 将改变后的副本的值从工作内存刷新到主内存\n    - 线程读volatile变量的过程：\n        1. 从主内存中读取volatile变量的最新值到线程的工作内存中\n        2. 从工作内存中读取volatile变量的副本\n\n- 不具备原子性\n\n    - 如 i++， 不是一个原子性操作，在实际执行时需要三步操作“读-改-写”，在操作未完成前其他线程修改了变量值的话，此操作就无效了\n    - 解决方案：\n        1. synchronized\n        2. ReentrantLock\n        3. AtomicInterger\n\n- 适用场合\n\n    - 对变量的写入操作不依赖当前值，如n = n + 1， n ++\n    - 该变量没有包含在具有其他变量的不变式中, 如 n < m\n\n- 和synchronizedvolatile的区别\n\n    - volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；\n    - 从内存可见性角度，volatile读相当于加锁，volatile写相当于解锁；\n    - synchronized既能够保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。\n\n- double check单例是否需要对实例使用volatile修饰？\n\n    ```java\n    public class SingletonClass {\n    \n        private static SingletonClass instance = null;\n        //private static volatile SingletonClass instance = null;\n    \n        public static SingletonClass getInstance() {\n            if (instance == null) {\n                synchronized (SingletonClass.class) {\n                    if (instance == null) {\n                        instance = new SingletonClass();\n                    }\n                }\n            }\n            return instance;\n        }\n    }\n    ```\n\n    - 答案是需要，因为**new操作是非原子性的,一般来说包含三个步骤：1.给对象分配内存，2.初始化对象，3.将对象内存地址赋值给引用**，正常来说是1->2->3这么个步骤，但是在指令重排序优化下，由于2、3不存在依赖性，可能会产生1->3>2这样的顺序，即给引用赋值的操作先于初始化操作，那么在多线程环境下，一个线程执行重排序后的指令，刚好执行完给引用赋值这一步，并未进行初始化，另一个线程恰好执行到第一个if语句，此时引用非空，但是实例并没初始化完成，直接返回后，调用实例方法则会发生空指针异常。所以必须依靠volatile来防止重排序，这个时候使用volatile实际上是保证了第一个if读的时候的有序性，对volatile变量的写happen-before读，从而禁止了newSingletonClass()时的重排序。\n\n### Atomic包（CAS）\n\n- 常用类：\n    1. AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReference（ 原子引用（声明引用类型的原子类））\n    2. AtomicIntegerArray 、AtomicLongArray 3.AtomicStampedReference（原子时间戳引用（根据版本号解决ABA问题））\n- 核心方法：\n    - boolean compareAndSet(expectedValue, updateValue) 使用CAS思想，依靠Unsafe类的CPU指令原语保证原子性\n\n### Locks包（AQS）\n\n- ReentrantLock（重入锁）\n    - 什么是可重入锁：同一线程外层函数获得锁之后，进入内层方法会自动获得锁，即线程可以进入任何一个已经拥有的锁所同步着的代码块\n    - ReentrantLock/Synchorized 典型的可重入锁，可重入锁作用：避免死锁\n    - lock可重复加，但是加几次就要释放几次，否则会阻塞\n- ReadWriteLock（读写锁）\n\n### 并发容器（Collections）\n\n- Queue\n    - ConcurrentLinkedQueue\n    - BlockingQueue\n    - Deque\n- CopyOnWriteArraySet\n- CopyOnWriteArrayList\n- ConcurrentSkipListSet\n- ConcurrentMap\n    - ConcurrentHashMap\n    - ConcurrentNavigableMap\n        - ConcurrentSkipListMap\n\n### 执行框架与线程池（Executor）\n\n- Future\n    - RunnableFuture\n        - RunnableScheduledFuture\n        - FutureTask\n    - ScheduledFuture\n- Callable\n- Executor\n    - ExecutorService\n        - ScheduledExecutorService\n            - ScheduledThreadPoolExecutor\n        - ThreadPoolExecutor\n- CompletionService\n    - ExecutorCompletionService\n- RejectedExecutionHandler\n    - ThreadPoolExecutor.DiscardPolicy\n    - ThreadPoolExecutor.DiscardOldestPolicy\n    - ThreadPoolExecutor.CallerRunsPolicy\n    - ThreadPoolExecutor.AbortPolicy\n- TimeUnit\n\n### 并发工具类（Tools）\n\n- CountDownLatch\n- CyclicBarrier\n- Semaphore\n- Executors\n- Exchanger\n\n## 集合（TODO 扩容机制）\n\n### Map\n\n- HashMap\n\n    > // 每个数组元素Entery（由key，value，next组成）存储一个链表的头结点Node。 // 当准备添加一个key-value对时，首先通过hash(key)方法计算hash值，然后通过indexFor(hash,length)求该key-value对的存储位置， // 计算方法是先用hash&0x7FFFFFFF(16进制最大正整数按位与)后，再对length取模，这就保证每一个key-value对都能存入HashMap中。 // 没有产生hash冲突前，Node的next是null。当计算出的位置相同时，1.8之前将新的Node插入链表头部，1.8之后，这个链表只让挂7个元素， // 超过七个就会转成一个红黑树进行处理，当红黑树下挂的节点小于等于6的时候，系统会把红黑树转成链表，新的Node插入链表的尾部。\n\n    - 数组+链表(1.8优化成数组+链表+红黑树)的组合实现，数组存储数据，链表解决冲突\n    - 线程不安全，继承自AbstractMap类，key可有一个为null，value可有多个null。默认容量为16。\n    - jdk1.7和1.8的区别： 1) 1.7使用hash+单链表（头插法），1.8使用hash+链表+红黑树（尾插法，链表长度>7时转成红黑树）。避免出现逆序和链表死循环问题 2) 计算hashcode的方法不同，1.7经过4次位移运算5次异或运算，1.8经过1次位移1次异或 3)扩容时重新计算元素位置的方法不同，1.7重新计算，1.8要么在原位置，要么原位置+扩容大小\n    - 扩容为什么是2倍： 只有2的n次幂时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞（最后return的是h&(length-1)，若尾数为0，那么0001、1001、1101等尾数为1的位置就永远不可能被entry占用）\n\n- Hashtable\n\n    > // HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。 // 因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法，可能会进入阻塞或轮询状态。 // 如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。\n\n    - Hashtable线程安全，继承自Dictionary类。key和value都不能为null。默认容量为11。\n\n- ConcurrentHashMap\n\n    > // ConcurrentHashMap线程安全，采用分段锁达到高效并发，继承自AbstractMap类。ConcurrentHashMap包含两个静态内部类 HashEntry 和 Segment。 > // HashEntry 用来封装映射表的键 / 值对;Segment 用来充当锁的角色。 > // 一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组，若干个 HashEntry 对象链接起来的链表组成桶。 > // 每个Segment守护着一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 > // put、get不需要跨段，有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。 > // 这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的， > // 但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。\n\n    - ConcurrentHashMap线程安全，采用分段锁达到高效并发，继承自AbstractMap类\n\n- LinkedHashMap\n\n    - LinkedHashMap继承自HashMap，所以它的底层仍然是基于拉链式散列结构，在数组+链表/红黑树的结构上，维护了一条双向链表，保持遍历顺序和插入顺序一致的问题。\n    - 线程不安全，增删快。允许有null值null键。\n\n- TreeMap\n\n    - TreeMap实现了SortedMap接口，保证了有序性。线程不安全。不允许有null值null键。\n    - 默认的排序是根据key值进行升序排序，也可以重写comparator方法来根据value进行排序具体取决于使用的构造方法。\n    - 基于红黑树（Red-Black tree）实现，基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n)。\n\n### List\n\n- ArrayList\n    - ArrayList底层结构为数组，线程不安全。查找快，增删慢(除了头尾)。\n- Vector\n    - Vector底层结构为数组，线程安全(synchronized)。查找慢，增删快。\n- LinkedList\n    - LinkedList底层结构为双向链表，线程不安全。查找慢，增删快(除了头尾)。\n\n### Set\n\n- HashSet\n    - HashSet底层结构为Hash表。无序，无重复值。\n- LinkedHashSet\n    - LinkedHashSet底层结构为双向链表。有序，无重复值。\n    - 继承于HashSet、又基于LinkedHashMap 来实现的\n- TreeSet\n    - TreeSet底层结构为红黑树。有序，无重复值。效率低。可自定义排序。\n\n### 红黑树\n\n> TreeMap、TreeSet及java8HashMap使用\n\n- 特点：\n    1. 自平衡二叉树\n    2. 根节点为黑色\n    3. 红色节点的两个子节点都是黑色\n    4. 任一节点到每个叶子的所有路径都包含相同数目的黑节点\n- 插入或删除节点时，规则可能被打破，这时需要动态调整，维持规则（特点3和4）：\n    1. 变色\n    2. 旋转：左旋、右旋\n\n## spring\n\n### IoC与DI\n\n- IoC：控制反转 反转对象的创建方式，由自己创建反转给程序创建\n- DI：依赖注入 不自己定义需要的类，直接向spring容器索取。IoC需要DI支持\n- 优点：\n    1. 降低组件耦合度\n    2. 提供服务，如事务管理，消息处理等。不需要手工控制事务处理复杂的事务传播\n    3. 减少代码量\n\n### AOP\n\n### spring工作流\n\n- 解析过程：读xml配置，扫描类文件，从配置或注解中获取bean的定义信息，注册一些扩展功能\n\n- 加载过程：通过解析完的定义信息获取bean实例 获取完整定义 -> 实例化 -> 依赖注入 -> 初始化 -> 类型转换。\n\n    - 1.获取BeanName：对传入的name进行解析，转化为可以从Map中获取到BeanDefinition的bean name\n\n        - 解析完配置后创建的 Map，使用的是 beanName 作为 key，BeanFactory.getBean 中传入的 name，有可能是这几种情况：\n            1. bean name，可以直接获取到定义 BeanDefinition。\n            2. alias name，别名，需要转化。在解析阶段，alias name 和 bean name 的映射关系被注册到 SimpleAliasRegistry 中。从该注册器中取到 beanName。\n            3. factorybean name, 带 & 前缀，通过它获取 BeanDefinition 的时候需要去除 & 前缀。\n\n    - 2.合并 BeanDefinition：对父类的定义进行合并和覆盖，如果父类还有父类，会进行递归合并，以获取完整的 Bean 定义信息。\n\n        - 从配置文件读取到的 BeanDefinition 是 GenericBeanDefinition,在后续实例化 Bean 的时候，使用的是 RootBeanDefinition,如果存在继承关系，GenericBeanDefinition 存储的是 增量信息 而不是 全量信息。在判断 parentName 存在的情况下，说明存在父类定义，启动合并。如果父类还有父类怎么办？递归调用，继续合并。合并完父类定义后，都会调用 RootBeanDefinition.overrideFrom 对父类的定义进行覆盖，获取到当前类能够正确实例化的 全量信息\n\n    - 3.实例化：使用构造或者工厂方法创建 Bean 实例（动态代理+ 反射）。\n\n        - 获取到完整的 RootBeanDefintion 后，就可以拿这份定义信息来实例具体的 Bean。具体实例创建见 AbstractAutowireCapableBeanFactory.createBeanInstance ，返回 Bean 的包装类 BeanWrapper，一共有三种策略：\n\n            1. 使用工厂方法创建，instantiateUsingFactoryMethod 。\n            2. 使用有参构造函数创建，autowireConstructor。\n            3. 使用无参构造函数创建，instantiateBean。\n\n            三个实例化方式，最后都会走 getInstantiationStrategy().instantiate() 虽然拿到了构造函数，并没有立即实例化。因为用户使用了 replace 和 lookup 的配置方法，用到了动态代理加入对应的逻辑。如果没有的话，直接使用反射来创建实例。 创建实例后，就可以开始注入属性和初始化等操作。\n\n        - 实例化时的**循环依赖问题**，分两种：\n\n            1. 构造器循环依赖。依赖的对象是通过构造器传入的，发生在实例化 Bean 的时候。\n            2. 设值循环依赖。依赖的对象是通过 setter 方法传入的，对象已经实例化，发生属性填充和依赖注入的时候。 如果是构造器循环依赖，本质上是无法解决的。比如我们准调用 A 的构造器，发现依赖 B，于是去调用 B 的构造器进行实例化，发现又依赖 C，于是调用 C 的构造器去初始化，结果依赖 A，整个形成一个死结，导致 A 无法创建。\n\n            - 如果是设值循环依赖，Spring 框架只支持单例下的设值循环依赖。Spring 通过对还在创建过程中的单例，缓存并提前暴露该单例，使得其他实例可以引用该依赖。\n\n            - 原型模式的任何循环依赖都不支持 单例模式下，构造函数的循环依赖无法解决，但设值循环依赖是可以解决的（提前暴露创建中的单例）。 为了能够实现单例的提前暴露。Spring 使用了三级缓存，见 DefaultSingletonBeanRegistry 这三个缓存的区别如下：\n\n                1. singletonObjects，单例缓存，存储已经实例化完成的单例。\n\n                2. singletonFactories，生产单例的工厂的缓存，存储工厂。\n\n                3. earlySingletonObjects，提前暴露的单例缓存，这时候的单例刚刚创建完，但还会注入依赖 先尝试从 singletonObjects 和 singletonFactory 读取，没有数据，然后尝试 singletonFactories 读取 singletonFactory，执行 getEarlyBeanReference 获取到引用后，存储到 earlySingletonObjects 中。 这个 earlySingletonObjects 的好处是，如果此时又有其他地方尝试获取未初始化的单例，可以从 earlySingletonObjects 直接取出而不需要再调用 getEarlyBeanReference。 实际上注入 C 的 A 实例，还在填充属性阶段，并没有完全地初始化。等递归回溯回去，A 顺利拿到依赖 B，才会真实地完成 A 的加载。\n\n                    ```java\n                    /** Cache of singleton objects: bean name --> bean instance */\n                    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);\n                    \n                    /** Cache of singleton factories: bean name --> ObjectFactory */\n                    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);\n                    \n                    /** Cache of early singleton objects: bean name --> bean instance */\n                    private final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);\n                    ```\n\n    - 4.属性填充：寻找并且注入依赖，依赖的 Bean 还会递归调用 getBean 方法获取。\n\n        - 主要的处理环节有：\n            1. 应用 InstantiationAwareBeanPostProcessor 处理器，在属性注入前后进行处理。假设我们使用了 @Autowire 注解，这里会调用到 AutowiredAnnotationBeanPostProcessor 来对依赖的实例进行检索和注入的，它是 InstantiationAwareBeanPostProcessor 的子类。\n            2. 根据名称或者类型进行自动注入，存储结果到 PropertyValues 中。\n            3. 应用 PropertyValues，填充到 BeanWrapper。这里在检索依赖实例的引用的时候，会递归调用 BeanFactory.getBean 来获得。\n\n    - 5.初始化：调用自定义的初始化方法。\n\n        1. 触发Aware Spring 在初始化阶段，如果判断 Bean 实现了几个Aware接口之一，会往 Bean 中注入它关心的资源。\n        2. 触发 BeanPostProcessor（连接IOC和AOP的桥梁） 在 Bean 的初始化前或者初始化后，我们如果需要进行一些增强操作（AOP比如打日志、做校验、属性修改、耗时检测）\n        3. 触发自定义 init 自定义初始化有两种方式可以：\n            1. 实现 InitializingBean。提供了一个很好的机会，在属性设置完成后再加入自己的初始化逻辑。\n            2. 定义 init 方法。自定义的初始化逻辑。\n\n    - 6.获取最终的 Bean：如果是 FactoryBean 需要调用 getObject 方法，如果需要类型转换调用 TypeConverter 进行转化。\n\n### Bean的生命周期\n\n- ![image20210918174436691](https://i.loli.net/2021/09/18/162nF7qvMfN8iKy.png)\n- 生命周期过程:\n    1. Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化\n    2. Bean实例化后将Bean的引入和值注入到Bean的属性中\n    3. 如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法\n    4. 如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入\n    5. 如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。\n    6. 如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。\n    7. 如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用\n    8. 如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。\n    9. 此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。\n    10. 如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。\n\n### 事务\n\n- 事务管理方式\n\n    - 编程式事务管理： 代码中调用commit()、rollback()等事务管理方法\n    - 声明式事务管理：\n        1. 修改spring配置文件，添加事务管理器和事务代理类。\n        2. 基于Transactional注解\n\n- 事务特性\n\n    1. 原子性：事务操作要么全部成功，要么全部失败\n    2. 一致性：事务执行前后一致，如转账不管转几次，账户总和不变\n    3. 隔离性：多个并发事务之间互相隔离\n    4. 持久性：事务一旦提交，数据改变是永久性的\n\n- 隔离级别：\n\n    1. 读未提交：事务A读取到事务B未提交的记录，之后B回滚，造成A读取到的数据不是有效的，这种情况称为脏读\n    2. 读已提交：事务只能读取到已提交的记录。可避免脏读，但会发生不可重复读。如A两次读取同一条记录的过程中，B修改并提交了该记录，造成A两次结果不一致\n    3. 可重复读(mysql默认)：多次从数据库读取某条记录，结果一致。如果多条数据可能会出现幻读。如A读取多条数据，重复两次相同操作，过程中B插进了一条数据，造成A两次读取结果不一致\n    4. 串行化：事务执行时会在所有级别上加锁（read、write都加锁），仿佛事务以串行方式进行，性能会大幅下降\n\n- 并发问题\n\n    - 脏读\n        - 事务A读取到事务B未提交的记录，之后B回滚，造成A读取到的数据不是有效的\n    - 不可重复读\n        - 范围在同一条记录。如A两次读取同一条记录的过程中，B修改并提交了该记录，造成A两次结果不一致\n    - 幻读\n        - 范围在多条记录。如A读取多条数据，重复两次相同操作，过程中B插进了一条数据，造成A两次读取结果不一致\n\n- 传播行为（Propagation）\n\n    ​\t// 保证在同一个事务中：\n\n    - 默认Propagation.REQUIRED:支持当前事务，假设当前没有事务。就新建一个事务。\n\n    - SUPPORTS:支持当前事务，假设当前没有事务，就以非事务方式运行。\n\n    - MANDATORY:支持当前事务，假设当前没有事务，就抛出异常。\n\n        // 保证在不同事务中\n\n    - REQUIRES_NEW:新建事务，假设当前存在事务。把当前事务挂起。\n\n    - NOT_SUPPORTED:以非事务方式运行操作。假设当前存在事务，就把当前事务挂起。\n\n    - NEVER:以非事务方式运行，假设当前存在事务，则抛出异常。\n\n    - NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。\n\n## mysql\n\n### MyISAM与InnoDB的区别\n\n1. InnoDB支持事务，MyISAM不支持\n2. InnoDB支持外键，MyISAM不支持\n3. InnoDB是聚集索引，MyISAM是非聚集索引。 聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。\n4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快\n5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一\n\n### 二叉搜索树\n\n特点:\n\n1. 所有非叶子结点至多有两个儿子\n2. 所有结点存储一个关键字\n3. 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树\n\n### B-树\n\n- 多路搜索树\n\n- 特性：\n\n    1. 所有非叶子结点最多只有M个儿子，M>2\n    2. 根节点儿子数为【2， M】\n    3. 除根结点外的非叶子结点儿子数为【M/2，M】\n    4. 每个结点存放【M/2-1，M-1】个关键字（至少2个）\n    5. 非叶子结点的关键字个数=指向儿子的指针个数-1；\n    6. 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；\n    7. 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；\n    8. 所有叶子结点位于同一层；\n\n    ![image-20210918191232742](https://i.loli.net/2021/09/18/GU86gywBaA7cIiQ.png)\n\n- 总结：\n\n    1. 关键字集合分布在整颗树中；\n    2. 任何一个关键字出现且只出现在一个结点中；\n    3. 搜索有可能在非叶子结点结束；\n    4. 其搜索性能等价于在关键字全集内做一次二分查找；\n    5. 自动层次控制；\n\n### B+树\n\n- B+树是B-树的变体，也是一种多路搜索树：\n\n    ![image-20210918191302660](https://i.loli.net/2021/09/18/mV5WLp2BusgXeqr.png)\n\n- 特性：\n\n    1. 非叶子结点的子树指针与关键字个数相同；\n    2. 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；\n    3. 为所有叶子结点增加一个链指针；\n    4. 所有关键字都在叶子结点出现；\n\n### 三种树对比\n\n- B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；\n- B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；\n- B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；\n\n## HTTP\n\n### 三次握手\n\n### 四次挥手\n\n### HTTP1.0和HTTP1.1的区别\n\n- 1.长连接(Persistent Connection)\n    - HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。\n    - HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。\n- 2.节约带宽\n    - HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。\n    - HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。\n- 3.HOST域\n    - 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。\n    - HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。\n- 4.缓存处理\n    - 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准\n    - HTTP1.1中引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。\n- 5.错误通知的管理\n    - 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。\n\n### HTTP1.1和HTTP2.0的区别\n\n- 1.多路复用\n    - HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。\n    - HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。\n- 2.头部数据压缩\n    - 在HTTP1.1不支持header数据的压缩，HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。\n    - HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。\n- 3.服务器推送\n    - 服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。\n    - 为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。\n\n### TIME_WAIT和CLOSE_WAIT\n\n- TIME_WAIT：表示主动关闭，通过优化系统内核参数可容易解决。（要么就是对方连接的异常，要么就是自己没有迅速回收资源），解决方法：/etc/sysctl.conf修改，让服务器能够快速回收和重用那些TIME_WAIT的资源。\n- CLOSE_WAIT：表示被动关闭，需要从程序本身出发。（在对方关闭连接之后服务器程序自己没有进一步发出ack信号，于是这个资源就一直 被程序占着） ESTABLISHED：表示正在通信\n\n### Https与加密算法\n\n- 密码学在计算机科学中使用非常广泛，HTTPS就是建立在密码学基础之上的一种安全的通信协议\n- 对称秘钥:对称密钥加密又叫专用密钥加密，即发送和接收数据的双方必使用相同的密钥对明文进行加密和解密运算。通常有两种模式：流加密和分组加密。\n- 非对称秘钥：非对称加密算法需要两个密钥：公开秘钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。\n\n### session和cookie区别\n\n- 1.存储位置不同\n    - cookie的数据信息存放在客户端浏览器上。\n    - session的数据信息存放在服务器上。\n- 2.存储容量不同\n    - 单个cookie保存的数据<=4KB，一个站点最多保存20个Cookie。\n    - 对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制\n- 3.存储方式不同\n    - cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。\n    - session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。\n- 4.隐私策略不同\n    - cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。\n    - session存储在服务器上，对客户端是透明对，不存在敏感信息泄漏的风险。\n- 5.有效期上不同\n    - 开发可以通过设置cookie的属性，达到使cookie长期有效的效果。\n    - session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。\n- 6.服务器压力不同\n    - cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。\n    - session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。\n- 7.浏览器支持不同\n    - 假如客户端浏览器不支持cookie：\n        - cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。\n        - 运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。\n    - 假如客户端浏览器支持cookie：\n        - cookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效。\n        - session只能在本窗口以及子窗口内有效。\n- 8.跨域支持上不同\n    - cookie支持跨域名访问。\n    - session不支持跨域名访问。\n\n## 分布式事务\n\n## 分布式队列","source":"_posts/java-outline.md","raw":"---\ntitle: JAVA知识点汇总\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop: 1\ntags:\n  - java\n  - spring\n  - mysql\n  - http\ncategories:\n  - work\nabbrlink: 2de3\ndate: 2020-10-15 20:50:34\nsubtitle:\n---\n\n## JVM内存模型\n\n### 程序计数器（线程私有）\n\n> 对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。\n\n- 当前线程的行号指示器\n- 唯一一个不会抛出OutOfMemory的内存区域\n\n### Java虚拟机栈（线程私有）\n\n> 栈描述的是Java方法执行的内存模型。\n>\n> 每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。\n>\n> 局部变量表所需要的内存空间在编译期完成分配，当进入一个方法时，这个方法在栈中需要分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表大小。\n\n- 每个栈帧存放内容：\n    1. 局部变量表（主要）： 方法参数、局部变量、编译器已知的数据类型\n    2. 操作数栈\n    3. 动态链接\n    4. 方法返回地址\n- 可能出现两种异常：\n    1. 线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverflowError。\n    2. 虚拟机栈空间可以动态扩展，当动态扩展是无法申请到足够的空间时，抛出OutOfMemory异常。\n\n### 本地方法栈（线程私有）\n\n- 本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++\n\n### 堆（线程共享）\n\n> 标量替换\n>\n> 1、标量是指不可分割的量，如java中基本数据类型和reference类型，相对的一个数据可以继续分解，称为聚合量；\n>\n> 2、如果把一个对象拆散，将其成员变量恢复到基本类型来访问就叫做标量替换；\n>\n> 3、如果逃逸分析发现一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是在栈上创建若干个成员变量；\n\n- 存放对象实例及数组， 但随着JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对(标量替换)\n- 大小可固定也可扩展，如果堆中没有内存完成实例分配，而且堆无法扩展将报OOM错误(OutOfMemoryError)\n\n### 方法区（线程共享）\n\n- 用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。\n\n## 垃圾回收\n\n### 判断对象是否存活算法\n\n- 引用计数法\n    - 原理：通过在对象头中分配一个空间来保存该对象被引用的次数。如果该对象被其它对象引用，则它的引用计数+1，如果删除对该对象的引用，那么它的引用计数就-1，当该对象的引用计数为0时，那么该对象就会被回收。\n    - 缺点：循环引用问题---如果有两个对象相互引用，那么这两个对象就不能被回收，因为它们的引用计数始终为1。这也就是我们常说的“内存泄漏”问题。\n- 可达性分析法（主流）\n    - 原理：从GCroot结点开始向下搜索，路径称为引用链，当对象没有任何一条引用链链接的时候，就认为这个对象是垃圾，并进行回收。\n    - 可作为GCroot的对象（GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收）：\n        1. 虚拟机栈（局部变量表）---局部变量或参数\n        2. 方法区中的类静态属性引用的对象\n        3. 方法区中的常量引用的对象\n        4. 本地方法栈中JNI（native方法）引用的对象\n\n### 如何回收---三大垃圾收集算法\n\n- 1. 标记-清除法\n\n      - 概念：\n        1. mutator：应用程序本身，负责NEW(分配内存)、READ(从内存中读取内容)、WRITE(将内容写入内存)\n        2. collector：垃圾收集器，回收不再使用的内存，供mutator进行NEW操作\n      - 算法原理：标记阶段和清除阶段\n        - 标记阶段：collector从mutator根对象开始进行遍历，对从mutator根对象可以访问到的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象。\n        - 清除阶段：collector对堆内存(heap memory)从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象-通过读取对象的header信息，则就将其回收。\n        - Tips：Collector在进行标记和清除阶段时会将整个应用程序暂停(mutator)，等待标记清除结束后才会恢复应用程序的运行，这也是Stop-The-World这个单词的来历。\n      - 缺点：垃圾收集后有可能会造成大量的内存碎片，假设一个方格代表1个单位的内存，如果有一个对象需要占用3个内存单位的话，那么就会导致Mutator一直处于暂停状态，而Collector一直在尝试进行垃圾收集，直到Out of Memory。\n\n- 2.复制算法\n\n    - 算法原理： 将堆内存对半分为两个半区，只用其中一个半区来进行对象内存的分配，如果在这个半区内存不够给新的对象分配了，那么就开始进行垃圾收集，将这个半区中的所有可达对象都拷贝到另外一个半区中去，然后继续在另外那个半区进行新对象的内存分配。\n    - 优点：解决内存碎片问题\n    - 缺点：可用堆内存减少了一半\n    - 适用场景：回收小的、存活期短的对象，主要针对新生代内存收集方法\n\n- 3.标记-整理算法\n\n    - 算法原理： 标记和整理阶段。\n\n        - 标记阶段与标记清除算法一样\n        - 整理阶段：移动所有的可达对象到堆内存的同一个区域中，使他们紧凑的排列在一起，从而将所有非可达对象释放出来的空闲内存都集中在一起，通过这样的方式来达到减少内存碎片的目的。\n\n    - 优点：解决内存碎片问题\n\n    - 缺点：引用额外空间来保存迁移地址，需要遍历多次堆内存\n\n    - 使用场景：主要针对的是老年代内存收集方法\n\n        > 新生代和老年代大小分配： > 响应时间和吞吐量优先的应用，尽可能设置大的新生代和小的老年代\n\n- 分代收集算法\n\n    - 算法原理：根据对象存活的生命周期将内存划分为若干个不同的区域。对不同区域采用不同的回收算法\n    - 新生代\n        - 新生代包括：\n            1. Eden 伊甸园\n            2. Survivor 存活区\n            3. Tenured Gen 养老区\n        - 采取**复制算法**，每次垃圾回收都要回收大部分对象，复制操作较少。一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。\n    - 老年代\n        - 采取**标记整理算法**，每次回收都只回收少量对象\n\n### 如何回收---常见垃圾回收器\n\n- Serial/Serial Old\n\n    - 特点：\n        1. 最古老的的垃圾收集器。\n        2. 单线程垃圾收集器，在它进行垃圾收集时，必须暂停所有用户线程。\n        3. Serial主要针对新生代，采用复制算法。Serial Old针对老年代，采用标记整理算法\n    - 优点：简单高效\n    - 缺点：停顿\n\n- ParNew\n\n    - 特点：\n\n        ​\tSerial的多线程版本\n\n- Parallel Scavenge\n\n    - 特点：\n        1. 并行收集器，不需要暂停\n        2. 新生代，采用复制算法\n\n- Parallel Old\n\n    - 特点：\n        1. Parallel Scavenge老年代版本，并行\n        2. 老年代，标记整理算法\n\n- CMS（Concurrent Mark Sweep）\n\n    - 特点：\n        1. 并发收集\n        2. 采用标记-清除算法\n    - 优点：快\n    - 缺点：\n        1. 占用CPU\n        2. 浮动垃圾\n        3. 出现ConcurrentMode Failure\n        4. 空间碎片\n\n- G1\n\n    - 特点\n        1. 当今最前沿的收集器，面向服务端应用\n        2. 并行与并发收集器，能建立可预测的停顿时间模型。\n\n按代分类\n\n- 年轻代收集器\n    - Serial、ParNew、Parallel Scavenge\n- 老年代收集器\n    - Serial Old、Parallel Old、CMS收集器\n- 特殊收集器\n    - G1收集器[新型，不在年轻、老年代范畴内]\n\n## 类加载\n\n### 加载过程：\n\n- 加载\n\n    1. 通过全类名获取定义此类的二进制字节流\n    2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构\n    3. 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口\n    4. Tips：一个非数组类的加载阶段（获取类的二进制字节流）是可控性最强的阶段，这一步我们可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。\n\n- 验证\n\n    - 目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全。 主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证。\n\n        ![image20210918170036312](https://i.loli.net/2021/09/18/F1BQWefNcAYUEDy.png)\n\n- 准备\n\n    - 为类变量（static修饰的字段变量）分配内存并且设置该类变量的初始值，（如static int i = 5 这里只是将 i 赋值为0，在初始化的阶段再把 i 赋值为5)，这里不包含final修饰的static ，因为final在编译的时候就已经分配了。这里不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象分配到Java堆中。\n\n- 解析\n\n    - 主要的任务是把常量池中的符号引用替换成直接引用，也就是得到类或者字段、方法在内存中的指针或者偏移量。\n\n- 初始化\n\n    - 如果该类具有父类就对父类进行初始化，执行其静态初始化器（静态代码块）和静态初始化成员变量。（前面已经对static 初始化了默认值，这里我们对它进行赋值，成员变量也将被初始化）\n\n        ![image20210918170449021](https://i.loli.net/2021/09/18/RLuVIpE7OWAx4Mz.png)\n\n### 类与类加载器\n\n- 一旦一个类被加载到JVM中，同一个类就不会被再次载入了。\n- 在JVM中，一个类用其全类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。\n- JVM预定义有三种类加载器\n    - 1.根类加载器\n        - 加载 Java 的核心类（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class），由C++实现，不是ClassLoader子类\n    - 2.扩展类加载器\n        - 它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。\n    - 3.系统类加载器\n        - 它负责在JVM启动时加载CLASSPATH环境变量所指定的JAR包和类路径。通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。用户自定义的类加载器默认以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。\n\n### 类加载机制\n\n- 1.全盘负责\n\n    - 当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入。\n\n- 2.双亲委派\n\n    - 如果一个类加载器收到了类加载请求，不会自己直接加载，而是把请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。\n\n        ![image20210918170625728](https://i.loli.net/2021/09/18/tJyd5oZ3aBS1pm9.png)\n\n    - 优势\n\n        - 1.避免类的重复加载。当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。\n        - 2.防止核心API库被随意篡改。假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现该类已被加载，则直接返回已加载过的Integer.class。\n\n- 3.缓存机制\n\n    - 该机制保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为什么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。\n\n### forName和loaderClass区别\n\n- Class.forName()得到的class是已经初始化完成的。\n- Classloader.loaderClass得到的class是还没有链接（验证，准备，解析三个过程被称为链接）的。\n\n### 对象创建过程\n\n- 在准备实例化一个类的对象前，首先准备实例化该类的父类，依次递归直到递归到Object类。此时，首先实例化Object类，再依次对以下各类进行实例化，直到完成对目标类的实例化。具体而言，在实例化每个类时，都遵循如下顺序：先依次执行实例变量初始化和实例代码块初始化，再执行构造函数初始化。也就是说，编译器会将实例变量初始化和实例代码块初始化相关代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后，构造函数本身的代码之前。\n\n### 对象的内存布局\n\n- 对象头（markword）\n\n    - 32位系统下，对象头8字节，64位则是16个字节\n\n    - 不同状态下存放数据\n\n        ![image20210918171629651](https://i.loli.net/2021/09/18/5UlmYsTDcFwKuX9.png)\n\n- 实例数据\n\n    - 存放对象程序中各种类型的字段类型，不管是从父类中继承下来的还是在子类中定义的。\n    - 分配策略:相同宽度的字段总是放在一起，比如double和long\n\n- 对齐填充\n\n    - 仅起到占位符的作用满足JVM要求。\n    - 由于HotSpot规定对象的大小必须是8的整数倍，对象头刚好是整数倍，如果实例数据不是的话，就需要占位符对齐填充。\n\n## synchronized\n\n### 具有可见性和原子性\n\n### JMM关于synchronized的两条规定：\n\n- 线程解锁前，必须把共享变量的最新值刷新到主内存中\n- 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时，需要从主内存中重新读取最新的值\n\n### 线程执行互斥代码的过程：\n\n1. 获得互斥锁\n2. 清空工作内存\n3. 从主内存拷贝变量的最新副本到工作的内存\n4. 执行代码\n5. 将更改后的共享变量的值刷新到主内存\n6. 释放互斥锁\n\n### 锁升级\n\n1. 检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁\n2. 如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1\n3. 如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。\n4. 当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁\n5. 如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。\n6. 如果自旋成功则依然处于轻量级状态。\n7. 如果自旋失败，则升级为重量级锁。\n\n### synchronized 能防止指令重排序吗？\n\n- synchronized不能防止指令重排序，但是能保证有序性，这和volatile实现有序性的方式不同，synchronized是通过互斥锁来保证有序性，即在单线程中无论指令如何重排序，其产生的结果对于其他线程来说是一致的。而volatile是通过内存屏障实现的有序性，即防止指令重排序来保证有序性。\n\n### 死锁\n\n- 两个线程都在等待对方先完成，造成程序的停滞。\n\n- 例如，现在张三想要李四的画，李四想要张三的书，张三对李四说“把你的画给我，我就给你书”，李四也对张三说“把你的书给我，我就给你画”两个人互相等对方先行动，就这么干等没有结果，这实际上就是死锁的概念。示例代码如下：\n\n    ```java\n    // 定义张三类\n    class Zhangsan {\n        public void say() {\n            System.out.println(\"张三对李四说：“你给我画，我就把书给你。”\");\n        }\n    \n        public void get() {\n            System.out.println(\"张三得到画了。\");\n        }\n    }\n    \n    // 定义李四类\n    class Lisi {\n        public void say() {\n            System.out.println(\"李四对张三说：“你给我书，我就把画给你”\");\n        }\n    \n        public void get() {\n            System.out.println(\"李四得到书了。\");\n        }\n    \n    }\n    \n    public class ThreadDeadLock implements Runnable {\n    \n        private static Zhangsan zs = new Zhangsan();    // 实例化static型对象\n    \n        private static Lisi ls = new Lisi();    // 实例化static型对象\n    \n        private boolean flag = false; // 声明标志位，判断那个先说话\n    \n        public void run() { // 覆写run()方法\n            if (flag) {\n                synchronized (zs) {  // 同步张三\n                    zs.say();\n                    try {\n                        Thread.sleep(500);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    synchronized (ls) {\n                        zs.get();\n                    }\n                }\n            } else {\n                synchronized (ls) {\n                    ls.say();\n                    try {\n                        Thread.sleep(500);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    synchronized (zs) {\n                        ls.get();\n                    }\n                }\n            }\n        }\n    \n        public static void main(String args[]) {\n            ThreadDeadLock t1 = new ThreadDeadLock();   // 控制张三\n            ThreadDeadLock t2 = new ThreadDeadLock();   // 控制李四\n            t1.flag = true;\n            t2.flag = false;\n            Thread thA = new Thread(t1);\n            Thread thB = new Thread(t2);\n            thA.start();\n            thB.start();\n        }\n    }\n    // 程序运行结果： 李四对张三说：“你给我书，我就把画给你” 张三对李四说：“你给我画，我就把书给你。\n    ```\n\n- 避免死锁\n\n    - 加锁顺序（线程按照一定的顺序加锁）\n    - 加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）\n    - 死锁检测\n\n## JUC\n\n### volatile\n\n- JMM模型\n\n    ![image20210918171727328](https://i.loli.net/2021/09/18/F23tz5UOqCEwJbA.png)\n\n- 可见性\n\n    - 修改了变量后，新值对其他线程立即可见（基于内存屏障禁止指令重排实现可见性）：\n        1. 对volatile变量执行写操作时，会在写操作后加入一条store屏障指令\n        2. 对volatile变量执行读操作时，会在读操作前加入一条load屏障指令\n    - 线程写volatile变量的过程：\n        1. 改变线程工作内存中volatile变量副本的值\n        2. 将改变后的副本的值从工作内存刷新到主内存\n    - 线程读volatile变量的过程：\n        1. 从主内存中读取volatile变量的最新值到线程的工作内存中\n        2. 从工作内存中读取volatile变量的副本\n\n- 不具备原子性\n\n    - 如 i++， 不是一个原子性操作，在实际执行时需要三步操作“读-改-写”，在操作未完成前其他线程修改了变量值的话，此操作就无效了\n    - 解决方案：\n        1. synchronized\n        2. ReentrantLock\n        3. AtomicInterger\n\n- 适用场合\n\n    - 对变量的写入操作不依赖当前值，如n = n + 1， n ++\n    - 该变量没有包含在具有其他变量的不变式中, 如 n < m\n\n- 和synchronizedvolatile的区别\n\n    - volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；\n    - 从内存可见性角度，volatile读相当于加锁，volatile写相当于解锁；\n    - synchronized既能够保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。\n\n- double check单例是否需要对实例使用volatile修饰？\n\n    ```java\n    public class SingletonClass {\n    \n        private static SingletonClass instance = null;\n        //private static volatile SingletonClass instance = null;\n    \n        public static SingletonClass getInstance() {\n            if (instance == null) {\n                synchronized (SingletonClass.class) {\n                    if (instance == null) {\n                        instance = new SingletonClass();\n                    }\n                }\n            }\n            return instance;\n        }\n    }\n    ```\n\n    - 答案是需要，因为**new操作是非原子性的,一般来说包含三个步骤：1.给对象分配内存，2.初始化对象，3.将对象内存地址赋值给引用**，正常来说是1->2->3这么个步骤，但是在指令重排序优化下，由于2、3不存在依赖性，可能会产生1->3>2这样的顺序，即给引用赋值的操作先于初始化操作，那么在多线程环境下，一个线程执行重排序后的指令，刚好执行完给引用赋值这一步，并未进行初始化，另一个线程恰好执行到第一个if语句，此时引用非空，但是实例并没初始化完成，直接返回后，调用实例方法则会发生空指针异常。所以必须依靠volatile来防止重排序，这个时候使用volatile实际上是保证了第一个if读的时候的有序性，对volatile变量的写happen-before读，从而禁止了newSingletonClass()时的重排序。\n\n### Atomic包（CAS）\n\n- 常用类：\n    1. AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReference（ 原子引用（声明引用类型的原子类））\n    2. AtomicIntegerArray 、AtomicLongArray 3.AtomicStampedReference（原子时间戳引用（根据版本号解决ABA问题））\n- 核心方法：\n    - boolean compareAndSet(expectedValue, updateValue) 使用CAS思想，依靠Unsafe类的CPU指令原语保证原子性\n\n### Locks包（AQS）\n\n- ReentrantLock（重入锁）\n    - 什么是可重入锁：同一线程外层函数获得锁之后，进入内层方法会自动获得锁，即线程可以进入任何一个已经拥有的锁所同步着的代码块\n    - ReentrantLock/Synchorized 典型的可重入锁，可重入锁作用：避免死锁\n    - lock可重复加，但是加几次就要释放几次，否则会阻塞\n- ReadWriteLock（读写锁）\n\n### 并发容器（Collections）\n\n- Queue\n    - ConcurrentLinkedQueue\n    - BlockingQueue\n    - Deque\n- CopyOnWriteArraySet\n- CopyOnWriteArrayList\n- ConcurrentSkipListSet\n- ConcurrentMap\n    - ConcurrentHashMap\n    - ConcurrentNavigableMap\n        - ConcurrentSkipListMap\n\n### 执行框架与线程池（Executor）\n\n- Future\n    - RunnableFuture\n        - RunnableScheduledFuture\n        - FutureTask\n    - ScheduledFuture\n- Callable\n- Executor\n    - ExecutorService\n        - ScheduledExecutorService\n            - ScheduledThreadPoolExecutor\n        - ThreadPoolExecutor\n- CompletionService\n    - ExecutorCompletionService\n- RejectedExecutionHandler\n    - ThreadPoolExecutor.DiscardPolicy\n    - ThreadPoolExecutor.DiscardOldestPolicy\n    - ThreadPoolExecutor.CallerRunsPolicy\n    - ThreadPoolExecutor.AbortPolicy\n- TimeUnit\n\n### 并发工具类（Tools）\n\n- CountDownLatch\n- CyclicBarrier\n- Semaphore\n- Executors\n- Exchanger\n\n## 集合（TODO 扩容机制）\n\n### Map\n\n- HashMap\n\n    > // 每个数组元素Entery（由key，value，next组成）存储一个链表的头结点Node。 // 当准备添加一个key-value对时，首先通过hash(key)方法计算hash值，然后通过indexFor(hash,length)求该key-value对的存储位置， // 计算方法是先用hash&0x7FFFFFFF(16进制最大正整数按位与)后，再对length取模，这就保证每一个key-value对都能存入HashMap中。 // 没有产生hash冲突前，Node的next是null。当计算出的位置相同时，1.8之前将新的Node插入链表头部，1.8之后，这个链表只让挂7个元素， // 超过七个就会转成一个红黑树进行处理，当红黑树下挂的节点小于等于6的时候，系统会把红黑树转成链表，新的Node插入链表的尾部。\n\n    - 数组+链表(1.8优化成数组+链表+红黑树)的组合实现，数组存储数据，链表解决冲突\n    - 线程不安全，继承自AbstractMap类，key可有一个为null，value可有多个null。默认容量为16。\n    - jdk1.7和1.8的区别： 1) 1.7使用hash+单链表（头插法），1.8使用hash+链表+红黑树（尾插法，链表长度>7时转成红黑树）。避免出现逆序和链表死循环问题 2) 计算hashcode的方法不同，1.7经过4次位移运算5次异或运算，1.8经过1次位移1次异或 3)扩容时重新计算元素位置的方法不同，1.7重新计算，1.8要么在原位置，要么原位置+扩容大小\n    - 扩容为什么是2倍： 只有2的n次幂时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞（最后return的是h&(length-1)，若尾数为0，那么0001、1001、1101等尾数为1的位置就永远不可能被entry占用）\n\n- Hashtable\n\n    > // HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。 // 因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法，可能会进入阻塞或轮询状态。 // 如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。\n\n    - Hashtable线程安全，继承自Dictionary类。key和value都不能为null。默认容量为11。\n\n- ConcurrentHashMap\n\n    > // ConcurrentHashMap线程安全，采用分段锁达到高效并发，继承自AbstractMap类。ConcurrentHashMap包含两个静态内部类 HashEntry 和 Segment。 > // HashEntry 用来封装映射表的键 / 值对;Segment 用来充当锁的角色。 > // 一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组，若干个 HashEntry 对象链接起来的链表组成桶。 > // 每个Segment守护着一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 > // put、get不需要跨段，有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。 > // 这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的， > // 但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。\n\n    - ConcurrentHashMap线程安全，采用分段锁达到高效并发，继承自AbstractMap类\n\n- LinkedHashMap\n\n    - LinkedHashMap继承自HashMap，所以它的底层仍然是基于拉链式散列结构，在数组+链表/红黑树的结构上，维护了一条双向链表，保持遍历顺序和插入顺序一致的问题。\n    - 线程不安全，增删快。允许有null值null键。\n\n- TreeMap\n\n    - TreeMap实现了SortedMap接口，保证了有序性。线程不安全。不允许有null值null键。\n    - 默认的排序是根据key值进行升序排序，也可以重写comparator方法来根据value进行排序具体取决于使用的构造方法。\n    - 基于红黑树（Red-Black tree）实现，基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n)。\n\n### List\n\n- ArrayList\n    - ArrayList底层结构为数组，线程不安全。查找快，增删慢(除了头尾)。\n- Vector\n    - Vector底层结构为数组，线程安全(synchronized)。查找慢，增删快。\n- LinkedList\n    - LinkedList底层结构为双向链表，线程不安全。查找慢，增删快(除了头尾)。\n\n### Set\n\n- HashSet\n    - HashSet底层结构为Hash表。无序，无重复值。\n- LinkedHashSet\n    - LinkedHashSet底层结构为双向链表。有序，无重复值。\n    - 继承于HashSet、又基于LinkedHashMap 来实现的\n- TreeSet\n    - TreeSet底层结构为红黑树。有序，无重复值。效率低。可自定义排序。\n\n### 红黑树\n\n> TreeMap、TreeSet及java8HashMap使用\n\n- 特点：\n    1. 自平衡二叉树\n    2. 根节点为黑色\n    3. 红色节点的两个子节点都是黑色\n    4. 任一节点到每个叶子的所有路径都包含相同数目的黑节点\n- 插入或删除节点时，规则可能被打破，这时需要动态调整，维持规则（特点3和4）：\n    1. 变色\n    2. 旋转：左旋、右旋\n\n## spring\n\n### IoC与DI\n\n- IoC：控制反转 反转对象的创建方式，由自己创建反转给程序创建\n- DI：依赖注入 不自己定义需要的类，直接向spring容器索取。IoC需要DI支持\n- 优点：\n    1. 降低组件耦合度\n    2. 提供服务，如事务管理，消息处理等。不需要手工控制事务处理复杂的事务传播\n    3. 减少代码量\n\n### AOP\n\n### spring工作流\n\n- 解析过程：读xml配置，扫描类文件，从配置或注解中获取bean的定义信息，注册一些扩展功能\n\n- 加载过程：通过解析完的定义信息获取bean实例 获取完整定义 -> 实例化 -> 依赖注入 -> 初始化 -> 类型转换。\n\n    - 1.获取BeanName：对传入的name进行解析，转化为可以从Map中获取到BeanDefinition的bean name\n\n        - 解析完配置后创建的 Map，使用的是 beanName 作为 key，BeanFactory.getBean 中传入的 name，有可能是这几种情况：\n            1. bean name，可以直接获取到定义 BeanDefinition。\n            2. alias name，别名，需要转化。在解析阶段，alias name 和 bean name 的映射关系被注册到 SimpleAliasRegistry 中。从该注册器中取到 beanName。\n            3. factorybean name, 带 & 前缀，通过它获取 BeanDefinition 的时候需要去除 & 前缀。\n\n    - 2.合并 BeanDefinition：对父类的定义进行合并和覆盖，如果父类还有父类，会进行递归合并，以获取完整的 Bean 定义信息。\n\n        - 从配置文件读取到的 BeanDefinition 是 GenericBeanDefinition,在后续实例化 Bean 的时候，使用的是 RootBeanDefinition,如果存在继承关系，GenericBeanDefinition 存储的是 增量信息 而不是 全量信息。在判断 parentName 存在的情况下，说明存在父类定义，启动合并。如果父类还有父类怎么办？递归调用，继续合并。合并完父类定义后，都会调用 RootBeanDefinition.overrideFrom 对父类的定义进行覆盖，获取到当前类能够正确实例化的 全量信息\n\n    - 3.实例化：使用构造或者工厂方法创建 Bean 实例（动态代理+ 反射）。\n\n        - 获取到完整的 RootBeanDefintion 后，就可以拿这份定义信息来实例具体的 Bean。具体实例创建见 AbstractAutowireCapableBeanFactory.createBeanInstance ，返回 Bean 的包装类 BeanWrapper，一共有三种策略：\n\n            1. 使用工厂方法创建，instantiateUsingFactoryMethod 。\n            2. 使用有参构造函数创建，autowireConstructor。\n            3. 使用无参构造函数创建，instantiateBean。\n\n            三个实例化方式，最后都会走 getInstantiationStrategy().instantiate() 虽然拿到了构造函数，并没有立即实例化。因为用户使用了 replace 和 lookup 的配置方法，用到了动态代理加入对应的逻辑。如果没有的话，直接使用反射来创建实例。 创建实例后，就可以开始注入属性和初始化等操作。\n\n        - 实例化时的**循环依赖问题**，分两种：\n\n            1. 构造器循环依赖。依赖的对象是通过构造器传入的，发生在实例化 Bean 的时候。\n            2. 设值循环依赖。依赖的对象是通过 setter 方法传入的，对象已经实例化，发生属性填充和依赖注入的时候。 如果是构造器循环依赖，本质上是无法解决的。比如我们准调用 A 的构造器，发现依赖 B，于是去调用 B 的构造器进行实例化，发现又依赖 C，于是调用 C 的构造器去初始化，结果依赖 A，整个形成一个死结，导致 A 无法创建。\n\n            - 如果是设值循环依赖，Spring 框架只支持单例下的设值循环依赖。Spring 通过对还在创建过程中的单例，缓存并提前暴露该单例，使得其他实例可以引用该依赖。\n\n            - 原型模式的任何循环依赖都不支持 单例模式下，构造函数的循环依赖无法解决，但设值循环依赖是可以解决的（提前暴露创建中的单例）。 为了能够实现单例的提前暴露。Spring 使用了三级缓存，见 DefaultSingletonBeanRegistry 这三个缓存的区别如下：\n\n                1. singletonObjects，单例缓存，存储已经实例化完成的单例。\n\n                2. singletonFactories，生产单例的工厂的缓存，存储工厂。\n\n                3. earlySingletonObjects，提前暴露的单例缓存，这时候的单例刚刚创建完，但还会注入依赖 先尝试从 singletonObjects 和 singletonFactory 读取，没有数据，然后尝试 singletonFactories 读取 singletonFactory，执行 getEarlyBeanReference 获取到引用后，存储到 earlySingletonObjects 中。 这个 earlySingletonObjects 的好处是，如果此时又有其他地方尝试获取未初始化的单例，可以从 earlySingletonObjects 直接取出而不需要再调用 getEarlyBeanReference。 实际上注入 C 的 A 实例，还在填充属性阶段，并没有完全地初始化。等递归回溯回去，A 顺利拿到依赖 B，才会真实地完成 A 的加载。\n\n                    ```java\n                    /** Cache of singleton objects: bean name --> bean instance */\n                    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);\n                    \n                    /** Cache of singleton factories: bean name --> ObjectFactory */\n                    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);\n                    \n                    /** Cache of early singleton objects: bean name --> bean instance */\n                    private final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);\n                    ```\n\n    - 4.属性填充：寻找并且注入依赖，依赖的 Bean 还会递归调用 getBean 方法获取。\n\n        - 主要的处理环节有：\n            1. 应用 InstantiationAwareBeanPostProcessor 处理器，在属性注入前后进行处理。假设我们使用了 @Autowire 注解，这里会调用到 AutowiredAnnotationBeanPostProcessor 来对依赖的实例进行检索和注入的，它是 InstantiationAwareBeanPostProcessor 的子类。\n            2. 根据名称或者类型进行自动注入，存储结果到 PropertyValues 中。\n            3. 应用 PropertyValues，填充到 BeanWrapper。这里在检索依赖实例的引用的时候，会递归调用 BeanFactory.getBean 来获得。\n\n    - 5.初始化：调用自定义的初始化方法。\n\n        1. 触发Aware Spring 在初始化阶段，如果判断 Bean 实现了几个Aware接口之一，会往 Bean 中注入它关心的资源。\n        2. 触发 BeanPostProcessor（连接IOC和AOP的桥梁） 在 Bean 的初始化前或者初始化后，我们如果需要进行一些增强操作（AOP比如打日志、做校验、属性修改、耗时检测）\n        3. 触发自定义 init 自定义初始化有两种方式可以：\n            1. 实现 InitializingBean。提供了一个很好的机会，在属性设置完成后再加入自己的初始化逻辑。\n            2. 定义 init 方法。自定义的初始化逻辑。\n\n    - 6.获取最终的 Bean：如果是 FactoryBean 需要调用 getObject 方法，如果需要类型转换调用 TypeConverter 进行转化。\n\n### Bean的生命周期\n\n- ![image20210918174436691](https://i.loli.net/2021/09/18/162nF7qvMfN8iKy.png)\n- 生命周期过程:\n    1. Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化\n    2. Bean实例化后将Bean的引入和值注入到Bean的属性中\n    3. 如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法\n    4. 如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入\n    5. 如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。\n    6. 如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。\n    7. 如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用\n    8. 如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。\n    9. 此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。\n    10. 如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。\n\n### 事务\n\n- 事务管理方式\n\n    - 编程式事务管理： 代码中调用commit()、rollback()等事务管理方法\n    - 声明式事务管理：\n        1. 修改spring配置文件，添加事务管理器和事务代理类。\n        2. 基于Transactional注解\n\n- 事务特性\n\n    1. 原子性：事务操作要么全部成功，要么全部失败\n    2. 一致性：事务执行前后一致，如转账不管转几次，账户总和不变\n    3. 隔离性：多个并发事务之间互相隔离\n    4. 持久性：事务一旦提交，数据改变是永久性的\n\n- 隔离级别：\n\n    1. 读未提交：事务A读取到事务B未提交的记录，之后B回滚，造成A读取到的数据不是有效的，这种情况称为脏读\n    2. 读已提交：事务只能读取到已提交的记录。可避免脏读，但会发生不可重复读。如A两次读取同一条记录的过程中，B修改并提交了该记录，造成A两次结果不一致\n    3. 可重复读(mysql默认)：多次从数据库读取某条记录，结果一致。如果多条数据可能会出现幻读。如A读取多条数据，重复两次相同操作，过程中B插进了一条数据，造成A两次读取结果不一致\n    4. 串行化：事务执行时会在所有级别上加锁（read、write都加锁），仿佛事务以串行方式进行，性能会大幅下降\n\n- 并发问题\n\n    - 脏读\n        - 事务A读取到事务B未提交的记录，之后B回滚，造成A读取到的数据不是有效的\n    - 不可重复读\n        - 范围在同一条记录。如A两次读取同一条记录的过程中，B修改并提交了该记录，造成A两次结果不一致\n    - 幻读\n        - 范围在多条记录。如A读取多条数据，重复两次相同操作，过程中B插进了一条数据，造成A两次读取结果不一致\n\n- 传播行为（Propagation）\n\n    ​\t// 保证在同一个事务中：\n\n    - 默认Propagation.REQUIRED:支持当前事务，假设当前没有事务。就新建一个事务。\n\n    - SUPPORTS:支持当前事务，假设当前没有事务，就以非事务方式运行。\n\n    - MANDATORY:支持当前事务，假设当前没有事务，就抛出异常。\n\n        // 保证在不同事务中\n\n    - REQUIRES_NEW:新建事务，假设当前存在事务。把当前事务挂起。\n\n    - NOT_SUPPORTED:以非事务方式运行操作。假设当前存在事务，就把当前事务挂起。\n\n    - NEVER:以非事务方式运行，假设当前存在事务，则抛出异常。\n\n    - NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。\n\n## mysql\n\n### MyISAM与InnoDB的区别\n\n1. InnoDB支持事务，MyISAM不支持\n2. InnoDB支持外键，MyISAM不支持\n3. InnoDB是聚集索引，MyISAM是非聚集索引。 聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。\n4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快\n5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一\n\n### 二叉搜索树\n\n特点:\n\n1. 所有非叶子结点至多有两个儿子\n2. 所有结点存储一个关键字\n3. 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树\n\n### B-树\n\n- 多路搜索树\n\n- 特性：\n\n    1. 所有非叶子结点最多只有M个儿子，M>2\n    2. 根节点儿子数为【2， M】\n    3. 除根结点外的非叶子结点儿子数为【M/2，M】\n    4. 每个结点存放【M/2-1，M-1】个关键字（至少2个）\n    5. 非叶子结点的关键字个数=指向儿子的指针个数-1；\n    6. 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；\n    7. 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；\n    8. 所有叶子结点位于同一层；\n\n    ![image-20210918191232742](https://i.loli.net/2021/09/18/GU86gywBaA7cIiQ.png)\n\n- 总结：\n\n    1. 关键字集合分布在整颗树中；\n    2. 任何一个关键字出现且只出现在一个结点中；\n    3. 搜索有可能在非叶子结点结束；\n    4. 其搜索性能等价于在关键字全集内做一次二分查找；\n    5. 自动层次控制；\n\n### B+树\n\n- B+树是B-树的变体，也是一种多路搜索树：\n\n    ![image-20210918191302660](https://i.loli.net/2021/09/18/mV5WLp2BusgXeqr.png)\n\n- 特性：\n\n    1. 非叶子结点的子树指针与关键字个数相同；\n    2. 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；\n    3. 为所有叶子结点增加一个链指针；\n    4. 所有关键字都在叶子结点出现；\n\n### 三种树对比\n\n- B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；\n- B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；\n- B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；\n\n## HTTP\n\n### 三次握手\n\n### 四次挥手\n\n### HTTP1.0和HTTP1.1的区别\n\n- 1.长连接(Persistent Connection)\n    - HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。\n    - HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。\n- 2.节约带宽\n    - HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。\n    - HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。\n- 3.HOST域\n    - 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。\n    - HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。\n- 4.缓存处理\n    - 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准\n    - HTTP1.1中引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。\n- 5.错误通知的管理\n    - 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。\n\n### HTTP1.1和HTTP2.0的区别\n\n- 1.多路复用\n    - HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。\n    - HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。\n- 2.头部数据压缩\n    - 在HTTP1.1不支持header数据的压缩，HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。\n    - HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。\n- 3.服务器推送\n    - 服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。\n    - 为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。\n\n### TIME_WAIT和CLOSE_WAIT\n\n- TIME_WAIT：表示主动关闭，通过优化系统内核参数可容易解决。（要么就是对方连接的异常，要么就是自己没有迅速回收资源），解决方法：/etc/sysctl.conf修改，让服务器能够快速回收和重用那些TIME_WAIT的资源。\n- CLOSE_WAIT：表示被动关闭，需要从程序本身出发。（在对方关闭连接之后服务器程序自己没有进一步发出ack信号，于是这个资源就一直 被程序占着） ESTABLISHED：表示正在通信\n\n### Https与加密算法\n\n- 密码学在计算机科学中使用非常广泛，HTTPS就是建立在密码学基础之上的一种安全的通信协议\n- 对称秘钥:对称密钥加密又叫专用密钥加密，即发送和接收数据的双方必使用相同的密钥对明文进行加密和解密运算。通常有两种模式：流加密和分组加密。\n- 非对称秘钥：非对称加密算法需要两个密钥：公开秘钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。\n\n### session和cookie区别\n\n- 1.存储位置不同\n    - cookie的数据信息存放在客户端浏览器上。\n    - session的数据信息存放在服务器上。\n- 2.存储容量不同\n    - 单个cookie保存的数据<=4KB，一个站点最多保存20个Cookie。\n    - 对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制\n- 3.存储方式不同\n    - cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。\n    - session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。\n- 4.隐私策略不同\n    - cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。\n    - session存储在服务器上，对客户端是透明对，不存在敏感信息泄漏的风险。\n- 5.有效期上不同\n    - 开发可以通过设置cookie的属性，达到使cookie长期有效的效果。\n    - session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。\n- 6.服务器压力不同\n    - cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。\n    - session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。\n- 7.浏览器支持不同\n    - 假如客户端浏览器不支持cookie：\n        - cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。\n        - 运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。\n    - 假如客户端浏览器支持cookie：\n        - cookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效。\n        - session只能在本窗口以及子窗口内有效。\n- 8.跨域支持上不同\n    - cookie支持跨域名访问。\n    - session不支持跨域名访问。\n\n## 分布式事务\n\n## 分布式队列","slug":"java-outline","published":1,"updated":"2021-12-10T09:05:27.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1br001vacbffqei8bdp","content":"<h2 id=\"JVM内存模型\"><a href=\"#JVM内存模型\" class=\"headerlink\" title=\"JVM内存模型\"></a>JVM内存模型</h2><h3 id=\"程序计数器（线程私有）\"><a href=\"#程序计数器（线程私有）\" class=\"headerlink\" title=\"程序计数器（线程私有）\"></a>程序计数器（线程私有）</h3><blockquote>\n<p>对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。</p>\n</blockquote>\n<ul>\n<li>当前线程的行号指示器</li>\n<li>唯一一个不会抛出OutOfMemory的内存区域</li>\n</ul>\n<h3 id=\"Java虚拟机栈（线程私有）\"><a href=\"#Java虚拟机栈（线程私有）\" class=\"headerlink\" title=\"Java虚拟机栈（线程私有）\"></a>Java虚拟机栈（线程私有）</h3><blockquote>\n<p>栈描述的是Java方法执行的内存模型。</p>\n<p>每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>\n<p>局部变量表所需要的内存空间在编译期完成分配，当进入一个方法时，这个方法在栈中需要分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表大小。</p>\n</blockquote>\n<ul>\n<li>每个栈帧存放内容：<ol>\n<li>局部变量表（主要）： 方法参数、局部变量、编译器已知的数据类型</li>\n<li>操作数栈</li>\n<li>动态链接</li>\n<li>方法返回地址</li>\n</ol>\n</li>\n<li>可能出现两种异常：<ol>\n<li>线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverflowError。</li>\n<li>虚拟机栈空间可以动态扩展，当动态扩展是无法申请到足够的空间时，抛出OutOfMemory异常。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"本地方法栈（线程私有）\"><a href=\"#本地方法栈（线程私有）\" class=\"headerlink\" title=\"本地方法栈（线程私有）\"></a>本地方法栈（线程私有）</h3><ul>\n<li>本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++</li>\n</ul>\n<h3 id=\"堆（线程共享）\"><a href=\"#堆（线程共享）\" class=\"headerlink\" title=\"堆（线程共享）\"></a>堆（线程共享）</h3><blockquote>\n<p>标量替换</p>\n<p>1、标量是指不可分割的量，如java中基本数据类型和reference类型，相对的一个数据可以继续分解，称为聚合量；</p>\n<p>2、如果把一个对象拆散，将其成员变量恢复到基本类型来访问就叫做标量替换；</p>\n<p>3、如果逃逸分析发现一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是在栈上创建若干个成员变量；</p>\n</blockquote>\n<ul>\n<li>存放对象实例及数组， 但随着JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对(标量替换)</li>\n<li>大小可固定也可扩展，如果堆中没有内存完成实例分配，而且堆无法扩展将报OOM错误(OutOfMemoryError)</li>\n</ul>\n<h3 id=\"方法区（线程共享）\"><a href=\"#方法区（线程共享）\" class=\"headerlink\" title=\"方法区（线程共享）\"></a>方法区（线程共享）</h3><ul>\n<li>用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。</li>\n</ul>\n<h2 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h2><h3 id=\"判断对象是否存活算法\"><a href=\"#判断对象是否存活算法\" class=\"headerlink\" title=\"判断对象是否存活算法\"></a>判断对象是否存活算法</h3><ul>\n<li>引用计数法<ul>\n<li>原理：通过在对象头中分配一个空间来保存该对象被引用的次数。如果该对象被其它对象引用，则它的引用计数+1，如果删除对该对象的引用，那么它的引用计数就-1，当该对象的引用计数为0时，那么该对象就会被回收。</li>\n<li>缺点：循环引用问题—如果有两个对象相互引用，那么这两个对象就不能被回收，因为它们的引用计数始终为1。这也就是我们常说的“内存泄漏”问题。</li>\n</ul>\n</li>\n<li>可达性分析法（主流）<ul>\n<li>原理：从GCroot结点开始向下搜索，路径称为引用链，当对象没有任何一条引用链链接的时候，就认为这个对象是垃圾，并进行回收。</li>\n<li>可作为GCroot的对象（GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收）：<ol>\n<li>虚拟机栈（局部变量表）—局部变量或参数</li>\n<li>方法区中的类静态属性引用的对象</li>\n<li>方法区中的常量引用的对象</li>\n<li>本地方法栈中JNI（native方法）引用的对象</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如何回收—三大垃圾收集算法\"><a href=\"#如何回收—三大垃圾收集算法\" class=\"headerlink\" title=\"如何回收—三大垃圾收集算法\"></a>如何回收—三大垃圾收集算法</h3><ul>\n<li><ol>\n<li><p>标记-清除法</p>\n<ul>\n<li>概念：<ol>\n<li>mutator：应用程序本身，负责NEW(分配内存)、READ(从内存中读取内容)、WRITE(将内容写入内存)</li>\n<li>collector：垃圾收集器，回收不再使用的内存，供mutator进行NEW操作</li>\n</ol>\n</li>\n<li>算法原理：标记阶段和清除阶段<ul>\n<li>标记阶段：collector从mutator根对象开始进行遍历，对从mutator根对象可以访问到的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象。</li>\n<li>清除阶段：collector对堆内存(heap memory)从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象-通过读取对象的header信息，则就将其回收。</li>\n<li>Tips：Collector在进行标记和清除阶段时会将整个应用程序暂停(mutator)，等待标记清除结束后才会恢复应用程序的运行，这也是Stop-The-World这个单词的来历。</li>\n</ul>\n</li>\n<li>缺点：垃圾收集后有可能会造成大量的内存碎片，假设一个方格代表1个单位的内存，如果有一个对象需要占用3个内存单位的话，那么就会导致Mutator一直处于暂停状态，而Collector一直在尝试进行垃圾收集，直到Out of Memory。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>2.复制算法</p>\n<ul>\n<li>算法原理： 将堆内存对半分为两个半区，只用其中一个半区来进行对象内存的分配，如果在这个半区内存不够给新的对象分配了，那么就开始进行垃圾收集，将这个半区中的所有可达对象都拷贝到另外一个半区中去，然后继续在另外那个半区进行新对象的内存分配。</li>\n<li>优点：解决内存碎片问题</li>\n<li>缺点：可用堆内存减少了一半</li>\n<li>适用场景：回收小的、存活期短的对象，主要针对新生代内存收集方法</li>\n</ul>\n</li>\n<li><p>3.标记-整理算法</p>\n<ul>\n<li><p>算法原理： 标记和整理阶段。</p>\n<ul>\n<li>标记阶段与标记清除算法一样</li>\n<li>整理阶段：移动所有的可达对象到堆内存的同一个区域中，使他们紧凑的排列在一起，从而将所有非可达对象释放出来的空闲内存都集中在一起，通过这样的方式来达到减少内存碎片的目的。</li>\n</ul>\n</li>\n<li><p>优点：解决内存碎片问题</p>\n</li>\n<li><p>缺点：引用额外空间来保存迁移地址，需要遍历多次堆内存</p>\n</li>\n<li><p>使用场景：主要针对的是老年代内存收集方法</p>\n<blockquote>\n<p>新生代和老年代大小分配： &gt; 响应时间和吞吐量优先的应用，尽可能设置大的新生代和小的老年代</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>分代收集算法</p>\n<ul>\n<li>算法原理：根据对象存活的生命周期将内存划分为若干个不同的区域。对不同区域采用不同的回收算法</li>\n<li>新生代<ul>\n<li>新生代包括：<ol>\n<li>Eden 伊甸园</li>\n<li>Survivor 存活区</li>\n<li>Tenured Gen 养老区</li>\n</ol>\n</li>\n<li>采取<strong>复制算法</strong>，每次垃圾回收都要回收大部分对象，复制操作较少。一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。</li>\n</ul>\n</li>\n<li>老年代<ul>\n<li>采取<strong>标记整理算法</strong>，每次回收都只回收少量对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如何回收—常见垃圾回收器\"><a href=\"#如何回收—常见垃圾回收器\" class=\"headerlink\" title=\"如何回收—常见垃圾回收器\"></a>如何回收—常见垃圾回收器</h3><ul>\n<li><p>Serial/Serial Old</p>\n<ul>\n<li>特点：<ol>\n<li>最古老的的垃圾收集器。</li>\n<li>单线程垃圾收集器，在它进行垃圾收集时，必须暂停所有用户线程。</li>\n<li>Serial主要针对新生代，采用复制算法。Serial Old针对老年代，采用标记整理算法</li>\n</ol>\n</li>\n<li>优点：简单高效</li>\n<li>缺点：停顿</li>\n</ul>\n</li>\n<li><p>ParNew</p>\n<ul>\n<li><p>特点：</p>\n<p>  ​    Serial的多线程版本</p>\n</li>\n</ul>\n</li>\n<li><p>Parallel Scavenge</p>\n<ul>\n<li>特点：<ol>\n<li>并行收集器，不需要暂停</li>\n<li>新生代，采用复制算法</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>Parallel Old</p>\n<ul>\n<li>特点：<ol>\n<li>Parallel Scavenge老年代版本，并行</li>\n<li>老年代，标记整理算法</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>CMS（Concurrent Mark Sweep）</p>\n<ul>\n<li>特点：<ol>\n<li>并发收集</li>\n<li>采用标记-清除算法</li>\n</ol>\n</li>\n<li>优点：快</li>\n<li>缺点：<ol>\n<li>占用CPU</li>\n<li>浮动垃圾</li>\n<li>出现ConcurrentMode Failure</li>\n<li>空间碎片</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>G1</p>\n<ul>\n<li>特点<ol>\n<li>当今最前沿的收集器，面向服务端应用</li>\n<li>并行与并发收集器，能建立可预测的停顿时间模型。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p>按代分类</p>\n<ul>\n<li>年轻代收集器<ul>\n<li>Serial、ParNew、Parallel Scavenge</li>\n</ul>\n</li>\n<li>老年代收集器<ul>\n<li>Serial Old、Parallel Old、CMS收集器</li>\n</ul>\n</li>\n<li>特殊收集器<ul>\n<li>G1收集器[新型，不在年轻、老年代范畴内]</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h2><h3 id=\"加载过程：\"><a href=\"#加载过程：\" class=\"headerlink\" title=\"加载过程：\"></a>加载过程：</h3><ul>\n<li><p>加载</p>\n<ol>\n<li>通过全类名获取定义此类的二进制字节流</li>\n<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>\n<li>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</li>\n<li>Tips：一个非数组类的加载阶段（获取类的二进制字节流）是可控性最强的阶段，这一步我们可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</li>\n</ol>\n</li>\n<li><p>验证</p>\n<ul>\n<li><p>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全。 主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证。</p>\n<p>  <img src=\"https://i.loli.net/2021/09/18/F1BQWefNcAYUEDy.png\" alt=\"image20210918170036312\"></p>\n</li>\n</ul>\n</li>\n<li><p>准备</p>\n<ul>\n<li>为类变量（static修饰的字段变量）分配内存并且设置该类变量的初始值，（如static int i = 5 这里只是将 i 赋值为0，在初始化的阶段再把 i 赋值为5)，这里不包含final修饰的static ，因为final在编译的时候就已经分配了。这里不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象分配到Java堆中。</li>\n</ul>\n</li>\n<li><p>解析</p>\n<ul>\n<li>主要的任务是把常量池中的符号引用替换成直接引用，也就是得到类或者字段、方法在内存中的指针或者偏移量。</li>\n</ul>\n</li>\n<li><p>初始化</p>\n<ul>\n<li><p>如果该类具有父类就对父类进行初始化，执行其静态初始化器（静态代码块）和静态初始化成员变量。（前面已经对static 初始化了默认值，这里我们对它进行赋值，成员变量也将被初始化）</p>\n<p>  <img src=\"https://i.loli.net/2021/09/18/RLuVIpE7OWAx4Mz.png\" alt=\"image20210918170449021\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类与类加载器\"><a href=\"#类与类加载器\" class=\"headerlink\" title=\"类与类加载器\"></a>类与类加载器</h3><ul>\n<li>一旦一个类被加载到JVM中，同一个类就不会被再次载入了。</li>\n<li>在JVM中，一个类用其全类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。</li>\n<li>JVM预定义有三种类加载器<ul>\n<li>1.根类加载器<ul>\n<li>加载 Java 的核心类（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class），由C++实现，不是ClassLoader子类</li>\n</ul>\n</li>\n<li>2.扩展类加载器<ul>\n<li>它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。</li>\n</ul>\n</li>\n<li>3.系统类加载器<ul>\n<li>它负责在JVM启动时加载CLASSPATH环境变量所指定的JAR包和类路径。通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。用户自定义的类加载器默认以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h3><ul>\n<li><p>1.全盘负责</p>\n<ul>\n<li>当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入。</li>\n</ul>\n</li>\n<li><p>2.双亲委派</p>\n<ul>\n<li><p>如果一个类加载器收到了类加载请求，不会自己直接加载，而是把请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。</p>\n<p>  <img src=\"https://i.loli.net/2021/09/18/tJyd5oZ3aBS1pm9.png\" alt=\"image20210918170625728\"></p>\n</li>\n<li><p>优势</p>\n<ul>\n<li>1.避免类的重复加载。当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</li>\n<li>2.防止核心API库被随意篡改。假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现该类已被加载，则直接返回已加载过的Integer.class。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>3.缓存机制</p>\n<ul>\n<li>该机制保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为什么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"forName和loaderClass区别\"><a href=\"#forName和loaderClass区别\" class=\"headerlink\" title=\"forName和loaderClass区别\"></a>forName和loaderClass区别</h3><ul>\n<li>Class.forName()得到的class是已经初始化完成的。</li>\n<li>Classloader.loaderClass得到的class是还没有链接（验证，准备，解析三个过程被称为链接）的。</li>\n</ul>\n<h3 id=\"对象创建过程\"><a href=\"#对象创建过程\" class=\"headerlink\" title=\"对象创建过程\"></a>对象创建过程</h3><ul>\n<li>在准备实例化一个类的对象前，首先准备实例化该类的父类，依次递归直到递归到Object类。此时，首先实例化Object类，再依次对以下各类进行实例化，直到完成对目标类的实例化。具体而言，在实例化每个类时，都遵循如下顺序：先依次执行实例变量初始化和实例代码块初始化，再执行构造函数初始化。也就是说，编译器会将实例变量初始化和实例代码块初始化相关代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后，构造函数本身的代码之前。</li>\n</ul>\n<h3 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h3><ul>\n<li><p>对象头（markword）</p>\n<ul>\n<li><p>32位系统下，对象头8字节，64位则是16个字节</p>\n</li>\n<li><p>不同状态下存放数据</p>\n<p>  <img src=\"https://i.loli.net/2021/09/18/5UlmYsTDcFwKuX9.png\" alt=\"image20210918171629651\"></p>\n</li>\n</ul>\n</li>\n<li><p>实例数据</p>\n<ul>\n<li>存放对象程序中各种类型的字段类型，不管是从父类中继承下来的还是在子类中定义的。</li>\n<li>分配策略:相同宽度的字段总是放在一起，比如double和long</li>\n</ul>\n</li>\n<li><p>对齐填充</p>\n<ul>\n<li>仅起到占位符的作用满足JVM要求。</li>\n<li>由于HotSpot规定对象的大小必须是8的整数倍，对象头刚好是整数倍，如果实例数据不是的话，就需要占位符对齐填充。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h2><h3 id=\"具有可见性和原子性\"><a href=\"#具有可见性和原子性\" class=\"headerlink\" title=\"具有可见性和原子性\"></a>具有可见性和原子性</h3><h3 id=\"JMM关于synchronized的两条规定：\"><a href=\"#JMM关于synchronized的两条规定：\" class=\"headerlink\" title=\"JMM关于synchronized的两条规定：\"></a>JMM关于synchronized的两条规定：</h3><ul>\n<li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li>\n<li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时，需要从主内存中重新读取最新的值</li>\n</ul>\n<h3 id=\"线程执行互斥代码的过程：\"><a href=\"#线程执行互斥代码的过程：\" class=\"headerlink\" title=\"线程执行互斥代码的过程：\"></a>线程执行互斥代码的过程：</h3><ol>\n<li>获得互斥锁</li>\n<li>清空工作内存</li>\n<li>从主内存拷贝变量的最新副本到工作的内存</li>\n<li>执行代码</li>\n<li>将更改后的共享变量的值刷新到主内存</li>\n<li>释放互斥锁</li>\n</ol>\n<h3 id=\"锁升级\"><a href=\"#锁升级\" class=\"headerlink\" title=\"锁升级\"></a>锁升级</h3><ol>\n<li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁</li>\n<li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1</li>\n<li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li>\n<li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁</li>\n<li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li>\n<li>如果自旋成功则依然处于轻量级状态。</li>\n<li>如果自旋失败，则升级为重量级锁。</li>\n</ol>\n<h3 id=\"synchronized-能防止指令重排序吗？\"><a href=\"#synchronized-能防止指令重排序吗？\" class=\"headerlink\" title=\"synchronized 能防止指令重排序吗？\"></a>synchronized 能防止指令重排序吗？</h3><ul>\n<li>synchronized不能防止指令重排序，但是能保证有序性，这和volatile实现有序性的方式不同，synchronized是通过互斥锁来保证有序性，即在单线程中无论指令如何重排序，其产生的结果对于其他线程来说是一致的。而volatile是通过内存屏障实现的有序性，即防止指令重排序来保证有序性。</li>\n</ul>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><ul>\n<li><p>两个线程都在等待对方先完成，造成程序的停滞。</p>\n</li>\n<li><p>例如，现在张三想要李四的画，李四想要张三的书，张三对李四说“把你的画给我，我就给你书”，李四也对张三说“把你的书给我，我就给你画”两个人互相等对方先行动，就这么干等没有结果，这实际上就是死锁的概念。示例代码如下：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义张三类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zhangsan</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"张三对李四说：“你给我画，我就把书给你。”\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"张三得到画了。\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义李四类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lisi</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"李四对张三说：“你给我书，我就把画给你”\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"李四得到书了。\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadDeadLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Zhangsan zs = <span class=\"keyword\">new</span> Zhangsan();    <span class=\"comment\">// 实例化static型对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Lisi ls = <span class=\"keyword\">new</span> Lisi();    <span class=\"comment\">// 实例化static型对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>; <span class=\"comment\">// 声明标志位，判断那个先说话</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// 覆写run()方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (zs) &#123;  <span class=\"comment\">// 同步张三</span></span><br><span class=\"line\">                zs.say();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (ls) &#123;</span><br><span class=\"line\">                    zs.get();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (ls) &#123;</span><br><span class=\"line\">                ls.say();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (zs) &#123;</span><br><span class=\"line\">                    ls.get();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">        ThreadDeadLock t1 = <span class=\"keyword\">new</span> ThreadDeadLock();   <span class=\"comment\">// 控制张三</span></span><br><span class=\"line\">        ThreadDeadLock t2 = <span class=\"keyword\">new</span> ThreadDeadLock();   <span class=\"comment\">// 控制李四</span></span><br><span class=\"line\">        t1.flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        t2.flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        Thread thA = <span class=\"keyword\">new</span> Thread(t1);</span><br><span class=\"line\">        Thread thB = <span class=\"keyword\">new</span> Thread(t2);</span><br><span class=\"line\">        thA.start();</span><br><span class=\"line\">        thB.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 程序运行结果： 李四对张三说：“你给我书，我就把画给你” 张三对李四说：“你给我画，我就把书给你。</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>避免死锁</p>\n<ul>\n<li>加锁顺序（线程按照一定的顺序加锁）</li>\n<li>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）</li>\n<li>死锁检测</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JUC\"><a href=\"#JUC\" class=\"headerlink\" title=\"JUC\"></a>JUC</h2><h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><ul>\n<li><p>JMM模型</p>\n<p>  <img src=\"https://i.loli.net/2021/09/18/F23tz5UOqCEwJbA.png\" alt=\"image20210918171727328\"></p>\n</li>\n<li><p>可见性</p>\n<ul>\n<li>修改了变量后，新值对其他线程立即可见（基于内存屏障禁止指令重排实现可见性）：<ol>\n<li>对volatile变量执行写操作时，会在写操作后加入一条store屏障指令</li>\n<li>对volatile变量执行读操作时，会在读操作前加入一条load屏障指令</li>\n</ol>\n</li>\n<li>线程写volatile变量的过程：<ol>\n<li>改变线程工作内存中volatile变量副本的值</li>\n<li>将改变后的副本的值从工作内存刷新到主内存</li>\n</ol>\n</li>\n<li>线程读volatile变量的过程：<ol>\n<li>从主内存中读取volatile变量的最新值到线程的工作内存中</li>\n<li>从工作内存中读取volatile变量的副本</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>不具备原子性</p>\n<ul>\n<li>如 i++， 不是一个原子性操作，在实际执行时需要三步操作“读-改-写”，在操作未完成前其他线程修改了变量值的话，此操作就无效了</li>\n<li>解决方案：<ol>\n<li>synchronized</li>\n<li>ReentrantLock</li>\n<li>AtomicInterger</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>适用场合</p>\n<ul>\n<li>对变量的写入操作不依赖当前值，如n = n + 1， n ++</li>\n<li>该变量没有包含在具有其他变量的不变式中, 如 n &lt; m</li>\n</ul>\n</li>\n<li><p>和synchronizedvolatile的区别</p>\n<ul>\n<li>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；</li>\n<li>从内存可见性角度，volatile读相当于加锁，volatile写相当于解锁；</li>\n<li>synchronized既能够保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。</li>\n</ul>\n</li>\n<li><p>double check单例是否需要对实例使用volatile修饰？</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonClass</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SingletonClass instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//private static volatile SingletonClass instance = null;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonClass <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (SingletonClass<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> SingletonClass();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>答案是需要，因为<strong>new操作是非原子性的,一般来说包含三个步骤：1.给对象分配内存，2.初始化对象，3.将对象内存地址赋值给引用</strong>，正常来说是1-&gt;2-&gt;3这么个步骤，但是在指令重排序优化下，由于2、3不存在依赖性，可能会产生1-&gt;3&gt;2这样的顺序，即给引用赋值的操作先于初始化操作，那么在多线程环境下，一个线程执行重排序后的指令，刚好执行完给引用赋值这一步，并未进行初始化，另一个线程恰好执行到第一个if语句，此时引用非空，但是实例并没初始化完成，直接返回后，调用实例方法则会发生空指针异常。所以必须依靠volatile来防止重排序，这个时候使用volatile实际上是保证了第一个if读的时候的有序性，对volatile变量的写happen-before读，从而禁止了newSingletonClass()时的重排序。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Atomic包（CAS）\"><a href=\"#Atomic包（CAS）\" class=\"headerlink\" title=\"Atomic包（CAS）\"></a>Atomic包（CAS）</h3><ul>\n<li>常用类：<ol>\n<li>AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReference（ 原子引用（声明引用类型的原子类））</li>\n<li>AtomicIntegerArray 、AtomicLongArray 3.AtomicStampedReference（原子时间戳引用（根据版本号解决ABA问题））</li>\n</ol>\n</li>\n<li>核心方法：<ul>\n<li>boolean compareAndSet(expectedValue, updateValue) 使用CAS思想，依靠Unsafe类的CPU指令原语保证原子性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Locks包（AQS）\"><a href=\"#Locks包（AQS）\" class=\"headerlink\" title=\"Locks包（AQS）\"></a>Locks包（AQS）</h3><ul>\n<li>ReentrantLock（重入锁）<ul>\n<li>什么是可重入锁：同一线程外层函数获得锁之后，进入内层方法会自动获得锁，即线程可以进入任何一个已经拥有的锁所同步着的代码块</li>\n<li>ReentrantLock/Synchorized 典型的可重入锁，可重入锁作用：避免死锁</li>\n<li>lock可重复加，但是加几次就要释放几次，否则会阻塞</li>\n</ul>\n</li>\n<li>ReadWriteLock（读写锁）</li>\n</ul>\n<h3 id=\"并发容器（Collections）\"><a href=\"#并发容器（Collections）\" class=\"headerlink\" title=\"并发容器（Collections）\"></a>并发容器（Collections）</h3><ul>\n<li>Queue<ul>\n<li>ConcurrentLinkedQueue</li>\n<li>BlockingQueue</li>\n<li>Deque</li>\n</ul>\n</li>\n<li>CopyOnWriteArraySet</li>\n<li>CopyOnWriteArrayList</li>\n<li>ConcurrentSkipListSet</li>\n<li>ConcurrentMap<ul>\n<li>ConcurrentHashMap</li>\n<li>ConcurrentNavigableMap<ul>\n<li>ConcurrentSkipListMap</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"执行框架与线程池（Executor）\"><a href=\"#执行框架与线程池（Executor）\" class=\"headerlink\" title=\"执行框架与线程池（Executor）\"></a>执行框架与线程池（Executor）</h3><ul>\n<li>Future<ul>\n<li>RunnableFuture<ul>\n<li>RunnableScheduledFuture</li>\n<li>FutureTask</li>\n</ul>\n</li>\n<li>ScheduledFuture</li>\n</ul>\n</li>\n<li>Callable</li>\n<li>Executor<ul>\n<li>ExecutorService<ul>\n<li>ScheduledExecutorService<ul>\n<li>ScheduledThreadPoolExecutor</li>\n</ul>\n</li>\n<li>ThreadPoolExecutor</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>CompletionService<ul>\n<li>ExecutorCompletionService</li>\n</ul>\n</li>\n<li>RejectedExecutionHandler<ul>\n<li>ThreadPoolExecutor.DiscardPolicy</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy</li>\n<li>ThreadPoolExecutor.AbortPolicy</li>\n</ul>\n</li>\n<li>TimeUnit</li>\n</ul>\n<h3 id=\"并发工具类（Tools）\"><a href=\"#并发工具类（Tools）\" class=\"headerlink\" title=\"并发工具类（Tools）\"></a>并发工具类（Tools）</h3><ul>\n<li>CountDownLatch</li>\n<li>CyclicBarrier</li>\n<li>Semaphore</li>\n<li>Executors</li>\n<li>Exchanger</li>\n</ul>\n<h2 id=\"集合（TODO-扩容机制）\"><a href=\"#集合（TODO-扩容机制）\" class=\"headerlink\" title=\"集合（TODO 扩容机制）\"></a>集合（TODO 扩容机制）</h2><h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><ul>\n<li><p>HashMap</p>\n<blockquote>\n<p>// 每个数组元素Entery（由key，value，next组成）存储一个链表的头结点Node。 // 当准备添加一个key-value对时，首先通过hash(key)方法计算hash值，然后通过indexFor(hash,length)求该key-value对的存储位置， // 计算方法是先用hash&amp;0x7FFFFFFF(16进制最大正整数按位与)后，再对length取模，这就保证每一个key-value对都能存入HashMap中。 // 没有产生hash冲突前，Node的next是null。当计算出的位置相同时，1.8之前将新的Node插入链表头部，1.8之后，这个链表只让挂7个元素， // 超过七个就会转成一个红黑树进行处理，当红黑树下挂的节点小于等于6的时候，系统会把红黑树转成链表，新的Node插入链表的尾部。</p>\n</blockquote>\n<ul>\n<li>数组+链表(1.8优化成数组+链表+红黑树)的组合实现，数组存储数据，链表解决冲突</li>\n<li>线程不安全，继承自AbstractMap类，key可有一个为null，value可有多个null。默认容量为16。</li>\n<li>jdk1.7和1.8的区别： 1) 1.7使用hash+单链表（头插法），1.8使用hash+链表+红黑树（尾插法，链表长度&gt;7时转成红黑树）。避免出现逆序和链表死循环问题 2) 计算hashcode的方法不同，1.7经过4次位移运算5次异或运算，1.8经过1次位移1次异或 3)扩容时重新计算元素位置的方法不同，1.7重新计算，1.8要么在原位置，要么原位置+扩容大小</li>\n<li>扩容为什么是2倍： 只有2的n次幂时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞（最后return的是h&amp;(length-1)，若尾数为0，那么0001、1001、1101等尾数为1的位置就永远不可能被entry占用）</li>\n</ul>\n</li>\n<li><p>Hashtable</p>\n<blockquote>\n<p>// HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。 // 因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法，可能会进入阻塞或轮询状态。 // 如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>\n</blockquote>\n<ul>\n<li>Hashtable线程安全，继承自Dictionary类。key和value都不能为null。默认容量为11。</li>\n</ul>\n</li>\n<li><p>ConcurrentHashMap</p>\n<blockquote>\n<p>// ConcurrentHashMap线程安全，采用分段锁达到高效并发，继承自AbstractMap类。ConcurrentHashMap包含两个静态内部类 HashEntry 和 Segment。 &gt; // HashEntry 用来封装映射表的键 / 值对;Segment 用来充当锁的角色。 &gt; // 一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组，若干个 HashEntry 对象链接起来的链表组成桶。 &gt; // 每个Segment守护着一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 &gt; // put、get不需要跨段，有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。 &gt; // 这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的， &gt; // 但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。</p>\n</blockquote>\n<ul>\n<li>ConcurrentHashMap线程安全，采用分段锁达到高效并发，继承自AbstractMap类</li>\n</ul>\n</li>\n<li><p>LinkedHashMap</p>\n<ul>\n<li>LinkedHashMap继承自HashMap，所以它的底层仍然是基于拉链式散列结构，在数组+链表/红黑树的结构上，维护了一条双向链表，保持遍历顺序和插入顺序一致的问题。</li>\n<li>线程不安全，增删快。允许有null值null键。</li>\n</ul>\n</li>\n<li><p>TreeMap</p>\n<ul>\n<li>TreeMap实现了SortedMap接口，保证了有序性。线程不安全。不允许有null值null键。</li>\n<li>默认的排序是根据key值进行升序排序，也可以重写comparator方法来根据value进行排序具体取决于使用的构造方法。</li>\n<li>基于红黑树（Red-Black tree）实现，基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n)。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><ul>\n<li>ArrayList<ul>\n<li>ArrayList底层结构为数组，线程不安全。查找快，增删慢(除了头尾)。</li>\n</ul>\n</li>\n<li>Vector<ul>\n<li>Vector底层结构为数组，线程安全(synchronized)。查找慢，增删快。</li>\n</ul>\n</li>\n<li>LinkedList<ul>\n<li>LinkedList底层结构为双向链表，线程不安全。查找慢，增删快(除了头尾)。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><ul>\n<li>HashSet<ul>\n<li>HashSet底层结构为Hash表。无序，无重复值。</li>\n</ul>\n</li>\n<li>LinkedHashSet<ul>\n<li>LinkedHashSet底层结构为双向链表。有序，无重复值。</li>\n<li>继承于HashSet、又基于LinkedHashMap 来实现的</li>\n</ul>\n</li>\n<li>TreeSet<ul>\n<li>TreeSet底层结构为红黑树。有序，无重复值。效率低。可自定义排序。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><blockquote>\n<p>TreeMap、TreeSet及java8HashMap使用</p>\n</blockquote>\n<ul>\n<li>特点：<ol>\n<li>自平衡二叉树</li>\n<li>根节点为黑色</li>\n<li>红色节点的两个子节点都是黑色</li>\n<li>任一节点到每个叶子的所有路径都包含相同数目的黑节点</li>\n</ol>\n</li>\n<li>插入或删除节点时，规则可能被打破，这时需要动态调整，维持规则（特点3和4）：<ol>\n<li>变色</li>\n<li>旋转：左旋、右旋</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"spring\"><a href=\"#spring\" class=\"headerlink\" title=\"spring\"></a>spring</h2><h3 id=\"IoC与DI\"><a href=\"#IoC与DI\" class=\"headerlink\" title=\"IoC与DI\"></a>IoC与DI</h3><ul>\n<li>IoC：控制反转 反转对象的创建方式，由自己创建反转给程序创建</li>\n<li>DI：依赖注入 不自己定义需要的类，直接向spring容器索取。IoC需要DI支持</li>\n<li>优点：<ol>\n<li>降低组件耦合度</li>\n<li>提供服务，如事务管理，消息处理等。不需要手工控制事务处理复杂的事务传播</li>\n<li>减少代码量</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h3><h3 id=\"spring工作流\"><a href=\"#spring工作流\" class=\"headerlink\" title=\"spring工作流\"></a>spring工作流</h3><ul>\n<li><p>解析过程：读xml配置，扫描类文件，从配置或注解中获取bean的定义信息，注册一些扩展功能</p>\n</li>\n<li><p>加载过程：通过解析完的定义信息获取bean实例 获取完整定义 -&gt; 实例化 -&gt; 依赖注入 -&gt; 初始化 -&gt; 类型转换。</p>\n<ul>\n<li><p>1.获取BeanName：对传入的name进行解析，转化为可以从Map中获取到BeanDefinition的bean name</p>\n<ul>\n<li>解析完配置后创建的 Map，使用的是 beanName 作为 key，BeanFactory.getBean 中传入的 name，有可能是这几种情况：<ol>\n<li>bean name，可以直接获取到定义 BeanDefinition。</li>\n<li>alias name，别名，需要转化。在解析阶段，alias name 和 bean name 的映射关系被注册到 SimpleAliasRegistry 中。从该注册器中取到 beanName。</li>\n<li>factorybean name, 带 &amp; 前缀，通过它获取 BeanDefinition 的时候需要去除 &amp; 前缀。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>2.合并 BeanDefinition：对父类的定义进行合并和覆盖，如果父类还有父类，会进行递归合并，以获取完整的 Bean 定义信息。</p>\n<ul>\n<li>从配置文件读取到的 BeanDefinition 是 GenericBeanDefinition,在后续实例化 Bean 的时候，使用的是 RootBeanDefinition,如果存在继承关系，GenericBeanDefinition 存储的是 增量信息 而不是 全量信息。在判断 parentName 存在的情况下，说明存在父类定义，启动合并。如果父类还有父类怎么办？递归调用，继续合并。合并完父类定义后，都会调用 RootBeanDefinition.overrideFrom 对父类的定义进行覆盖，获取到当前类能够正确实例化的 全量信息</li>\n</ul>\n</li>\n<li><p>3.实例化：使用构造或者工厂方法创建 Bean 实例（动态代理+ 反射）。</p>\n<ul>\n<li><p>获取到完整的 RootBeanDefintion 后，就可以拿这份定义信息来实例具体的 Bean。具体实例创建见 AbstractAutowireCapableBeanFactory.createBeanInstance ，返回 Bean 的包装类 BeanWrapper，一共有三种策略：</p>\n<ol>\n<li><p>使用工厂方法创建，instantiateUsingFactoryMethod 。</p>\n</li>\n<li><p>使用有参构造函数创建，autowireConstructor。</p>\n</li>\n<li><p>使用无参构造函数创建，instantiateBean。</p>\n<p>三个实例化方式，最后都会走 getInstantiationStrategy().instantiate() 虽然拿到了构造函数，并没有立即实例化。因为用户使用了 replace 和 lookup 的配置方法，用到了动态代理加入对应的逻辑。如果没有的话，直接使用反射来创建实例。 创建实例后，就可以开始注入属性和初始化等操作。</p>\n</li>\n</ol>\n</li>\n<li><p>实例化时的<strong>循环依赖问题</strong>，分两种：</p>\n<ol>\n<li>构造器循环依赖。依赖的对象是通过构造器传入的，发生在实例化 Bean 的时候。</li>\n<li>设值循环依赖。依赖的对象是通过 setter 方法传入的，对象已经实例化，发生属性填充和依赖注入的时候。 如果是构造器循环依赖，本质上是无法解决的。比如我们准调用 A 的构造器，发现依赖 B，于是去调用 B 的构造器进行实例化，发现又依赖 C，于是调用 C 的构造器去初始化，结果依赖 A，整个形成一个死结，导致 A 无法创建。</li>\n</ol>\n<ul>\n<li><p>如果是设值循环依赖，Spring 框架只支持单例下的设值循环依赖。Spring 通过对还在创建过程中的单例，缓存并提前暴露该单例，使得其他实例可以引用该依赖。</p>\n</li>\n<li><p>原型模式的任何循环依赖都不支持 单例模式下，构造函数的循环依赖无法解决，但设值循环依赖是可以解决的（提前暴露创建中的单例）。 为了能够实现单例的提前暴露。Spring 使用了三级缓存，见 DefaultSingletonBeanRegistry 这三个缓存的区别如下：</p>\n<ol>\n<li><p>singletonObjects，单例缓存，存储已经实例化完成的单例。</p>\n</li>\n<li><p>singletonFactories，生产单例的工厂的缓存，存储工厂。</p>\n</li>\n<li><p>earlySingletonObjects，提前暴露的单例缓存，这时候的单例刚刚创建完，但还会注入依赖 先尝试从 singletonObjects 和 singletonFactory 读取，没有数据，然后尝试 singletonFactories 读取 singletonFactory，执行 getEarlyBeanReference 获取到引用后，存储到 earlySingletonObjects 中。 这个 earlySingletonObjects 的好处是，如果此时又有其他地方尝试获取未初始化的单例，可以从 earlySingletonObjects 直接取出而不需要再调用 getEarlyBeanReference。 实际上注入 C 的 A 实例，还在填充属性阶段，并没有完全地初始化。等递归回溯回去，A 顺利拿到依赖 B，才会真实地完成 A 的加载。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; singletonObjects = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class=\"number\">256</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class=\"keyword\">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;(<span class=\"number\">16</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>4.属性填充：寻找并且注入依赖，依赖的 Bean 还会递归调用 getBean 方法获取。</p>\n<ul>\n<li>主要的处理环节有：<ol>\n<li>应用 InstantiationAwareBeanPostProcessor 处理器，在属性注入前后进行处理。假设我们使用了 @Autowire 注解，这里会调用到 AutowiredAnnotationBeanPostProcessor 来对依赖的实例进行检索和注入的，它是 InstantiationAwareBeanPostProcessor 的子类。</li>\n<li>根据名称或者类型进行自动注入，存储结果到 PropertyValues 中。</li>\n<li>应用 PropertyValues，填充到 BeanWrapper。这里在检索依赖实例的引用的时候，会递归调用 BeanFactory.getBean 来获得。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>5.初始化：调用自定义的初始化方法。</p>\n<ol>\n<li>触发Aware Spring 在初始化阶段，如果判断 Bean 实现了几个Aware接口之一，会往 Bean 中注入它关心的资源。</li>\n<li>触发 BeanPostProcessor（连接IOC和AOP的桥梁） 在 Bean 的初始化前或者初始化后，我们如果需要进行一些增强操作（AOP比如打日志、做校验、属性修改、耗时检测）</li>\n<li>触发自定义 init 自定义初始化有两种方式可以：<ol>\n<li>实现 InitializingBean。提供了一个很好的机会，在属性设置完成后再加入自己的初始化逻辑。</li>\n<li>定义 init 方法。自定义的初始化逻辑。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>6.获取最终的 Bean：如果是 FactoryBean 需要调用 getObject 方法，如果需要类型转换调用 TypeConverter 进行转化。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Bean的生命周期\"><a href=\"#Bean的生命周期\" class=\"headerlink\" title=\"Bean的生命周期\"></a>Bean的生命周期</h3><ul>\n<li><img src=\"https://i.loli.net/2021/09/18/162nF7qvMfN8iKy.png\" alt=\"image20210918174436691\"></li>\n<li>生命周期过程:<ol>\n<li>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</li>\n<li>Bean实例化后将Bean的引入和值注入到Bean的属性中</li>\n<li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</li>\n<li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</li>\n<li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</li>\n<li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</li>\n<li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</li>\n<li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</li>\n<li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</li>\n<li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><ul>\n<li><p>事务管理方式</p>\n<ul>\n<li>编程式事务管理： 代码中调用commit()、rollback()等事务管理方法</li>\n<li>声明式事务管理：<ol>\n<li>修改spring配置文件，添加事务管理器和事务代理类。</li>\n<li>基于Transactional注解</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>事务特性</p>\n<ol>\n<li>原子性：事务操作要么全部成功，要么全部失败</li>\n<li>一致性：事务执行前后一致，如转账不管转几次，账户总和不变</li>\n<li>隔离性：多个并发事务之间互相隔离</li>\n<li>持久性：事务一旦提交，数据改变是永久性的</li>\n</ol>\n</li>\n<li><p>隔离级别：</p>\n<ol>\n<li>读未提交：事务A读取到事务B未提交的记录，之后B回滚，造成A读取到的数据不是有效的，这种情况称为脏读</li>\n<li>读已提交：事务只能读取到已提交的记录。可避免脏读，但会发生不可重复读。如A两次读取同一条记录的过程中，B修改并提交了该记录，造成A两次结果不一致</li>\n<li>可重复读(mysql默认)：多次从数据库读取某条记录，结果一致。如果多条数据可能会出现幻读。如A读取多条数据，重复两次相同操作，过程中B插进了一条数据，造成A两次读取结果不一致</li>\n<li>串行化：事务执行时会在所有级别上加锁（read、write都加锁），仿佛事务以串行方式进行，性能会大幅下降</li>\n</ol>\n</li>\n<li><p>并发问题</p>\n<ul>\n<li>脏读<ul>\n<li>事务A读取到事务B未提交的记录，之后B回滚，造成A读取到的数据不是有效的</li>\n</ul>\n</li>\n<li>不可重复读<ul>\n<li>范围在同一条记录。如A两次读取同一条记录的过程中，B修改并提交了该记录，造成A两次结果不一致</li>\n</ul>\n</li>\n<li>幻读<ul>\n<li>范围在多条记录。如A读取多条数据，重复两次相同操作，过程中B插进了一条数据，造成A两次读取结果不一致</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>传播行为（Propagation）</p>\n<p>  ​    // 保证在同一个事务中：</p>\n<ul>\n<li><p>默认Propagation.REQUIRED:支持当前事务，假设当前没有事务。就新建一个事务。</p>\n</li>\n<li><p>SUPPORTS:支持当前事务，假设当前没有事务，就以非事务方式运行。</p>\n</li>\n<li><p>MANDATORY:支持当前事务，假设当前没有事务，就抛出异常。</p>\n<p>  // 保证在不同事务中</p>\n</li>\n<li><p>REQUIRES_NEW:新建事务，假设当前存在事务。把当前事务挂起。</p>\n</li>\n<li><p>NOT_SUPPORTED:以非事务方式运行操作。假设当前存在事务，就把当前事务挂起。</p>\n</li>\n<li><p>NEVER:以非事务方式运行，假设当前存在事务，则抛出异常。</p>\n</li>\n<li><p>NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"mysql\"><a href=\"#mysql\" class=\"headerlink\" title=\"mysql\"></a>mysql</h2><h3 id=\"MyISAM与InnoDB的区别\"><a href=\"#MyISAM与InnoDB的区别\" class=\"headerlink\" title=\"MyISAM与InnoDB的区别\"></a>MyISAM与InnoDB的区别</h3><ol>\n<li>InnoDB支持事务，MyISAM不支持</li>\n<li>InnoDB支持外键，MyISAM不支持</li>\n<li>InnoDB是聚集索引，MyISAM是非聚集索引。 聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>\n<li>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快</li>\n<li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一</li>\n</ol>\n<h3 id=\"二叉搜索树\"><a href=\"#二叉搜索树\" class=\"headerlink\" title=\"二叉搜索树\"></a>二叉搜索树</h3><p>特点:</p>\n<ol>\n<li>所有非叶子结点至多有两个儿子</li>\n<li>所有结点存储一个关键字</li>\n<li>非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树</li>\n</ol>\n<h3 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B-树\"></a>B-树</h3><ul>\n<li><p>多路搜索树</p>\n</li>\n<li><p>特性：</p>\n<ol>\n<li><p>所有非叶子结点最多只有M个儿子，M&gt;2</p>\n</li>\n<li><p>根节点儿子数为【2， M】</p>\n</li>\n<li><p>除根结点外的非叶子结点儿子数为【M/2，M】</p>\n</li>\n<li><p>每个结点存放【M/2-1，M-1】个关键字（至少2个）</p>\n</li>\n<li><p>非叶子结点的关键字个数=指向儿子的指针个数-1；</p>\n</li>\n<li><p>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</p>\n</li>\n<li><p>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</p>\n</li>\n<li><p>所有叶子结点位于同一层；</p>\n<p><img src=\"https://i.loli.net/2021/09/18/GU86gywBaA7cIiQ.png\" alt=\"image-20210918191232742\"></p>\n</li>\n</ol>\n</li>\n<li><p>总结：</p>\n<ol>\n<li>关键字集合分布在整颗树中；</li>\n<li>任何一个关键字出现且只出现在一个结点中；</li>\n<li>搜索有可能在非叶子结点结束；</li>\n<li>其搜索性能等价于在关键字全集内做一次二分查找；</li>\n<li>自动层次控制；</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"B-树-1\"><a href=\"#B-树-1\" class=\"headerlink\" title=\"B+树\"></a>B+树</h3><ul>\n<li><p>B+树是B-树的变体，也是一种多路搜索树：</p>\n<p>  <img src=\"https://i.loli.net/2021/09/18/mV5WLp2BusgXeqr.png\" alt=\"image-20210918191302660\"></p>\n</li>\n<li><p>特性：</p>\n<ol>\n<li>非叶子结点的子树指针与关键字个数相同；</li>\n<li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</li>\n<li>为所有叶子结点增加一个链指针；</li>\n<li>所有关键字都在叶子结点出现；</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"三种树对比\"><a href=\"#三种树对比\" class=\"headerlink\" title=\"三种树对比\"></a>三种树对比</h3><ul>\n<li>B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</li>\n<li>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</li>\n<li>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</li>\n</ul>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><h3 id=\"HTTP1-0和HTTP1-1的区别\"><a href=\"#HTTP1-0和HTTP1-1的区别\" class=\"headerlink\" title=\"HTTP1.0和HTTP1.1的区别\"></a>HTTP1.0和HTTP1.1的区别</h3><ul>\n<li>1.长连接(Persistent Connection)<ul>\n<li>HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。</li>\n<li>HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li>\n</ul>\n</li>\n<li>2.节约带宽<ul>\n<li>HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。</li>\n<li>HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。</li>\n</ul>\n</li>\n<li>3.HOST域<ul>\n<li>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</li>\n<li>HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。</li>\n</ul>\n</li>\n<li>4.缓存处理<ul>\n<li>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准</li>\n<li>HTTP1.1中引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>\n</ul>\n</li>\n<li>5.错误通知的管理<ul>\n<li>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTP1-1和HTTP2-0的区别\"><a href=\"#HTTP1-1和HTTP2-0的区别\" class=\"headerlink\" title=\"HTTP1.1和HTTP2.0的区别\"></a>HTTP1.1和HTTP2.0的区别</h3><ul>\n<li>1.多路复用<ul>\n<li>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</li>\n<li>HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</li>\n</ul>\n</li>\n<li>2.头部数据压缩<ul>\n<li>在HTTP1.1不支持header数据的压缩，HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。</li>\n<li>HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</li>\n</ul>\n</li>\n<li>3.服务器推送<ul>\n<li>服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。</li>\n<li>为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"TIME-WAIT和CLOSE-WAIT\"><a href=\"#TIME-WAIT和CLOSE-WAIT\" class=\"headerlink\" title=\"TIME_WAIT和CLOSE_WAIT\"></a>TIME_WAIT和CLOSE_WAIT</h3><ul>\n<li>TIME_WAIT：表示主动关闭，通过优化系统内核参数可容易解决。（要么就是对方连接的异常，要么就是自己没有迅速回收资源），解决方法：/etc/sysctl.conf修改，让服务器能够快速回收和重用那些TIME_WAIT的资源。</li>\n<li>CLOSE_WAIT：表示被动关闭，需要从程序本身出发。（在对方关闭连接之后服务器程序自己没有进一步发出ack信号，于是这个资源就一直 被程序占着） ESTABLISHED：表示正在通信</li>\n</ul>\n<h3 id=\"Https与加密算法\"><a href=\"#Https与加密算法\" class=\"headerlink\" title=\"Https与加密算法\"></a>Https与加密算法</h3><ul>\n<li>密码学在计算机科学中使用非常广泛，HTTPS就是建立在密码学基础之上的一种安全的通信协议</li>\n<li>对称秘钥:对称密钥加密又叫专用密钥加密，即发送和接收数据的双方必使用相同的密钥对明文进行加密和解密运算。通常有两种模式：流加密和分组加密。</li>\n<li>非对称秘钥：非对称加密算法需要两个密钥：公开秘钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</li>\n</ul>\n<h3 id=\"session和cookie区别\"><a href=\"#session和cookie区别\" class=\"headerlink\" title=\"session和cookie区别\"></a>session和cookie区别</h3><ul>\n<li>1.存储位置不同<ul>\n<li>cookie的数据信息存放在客户端浏览器上。</li>\n<li>session的数据信息存放在服务器上。</li>\n</ul>\n</li>\n<li>2.存储容量不同<ul>\n<li>单个cookie保存的数据&lt;=4KB，一个站点最多保存20个Cookie。</li>\n<li>对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制</li>\n</ul>\n</li>\n<li>3.存储方式不同<ul>\n<li>cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。</li>\n<li>session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。</li>\n</ul>\n</li>\n<li>4.隐私策略不同<ul>\n<li>cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。</li>\n<li>session存储在服务器上，对客户端是透明对，不存在敏感信息泄漏的风险。</li>\n</ul>\n</li>\n<li>5.有效期上不同<ul>\n<li>开发可以通过设置cookie的属性，达到使cookie长期有效的效果。</li>\n<li>session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。</li>\n</ul>\n</li>\n<li>6.服务器压力不同<ul>\n<li>cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。</li>\n<li>session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。</li>\n</ul>\n</li>\n<li>7.浏览器支持不同<ul>\n<li>假如客户端浏览器不支持cookie：<ul>\n<li>cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。</li>\n<li>运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。</li>\n</ul>\n</li>\n<li>假如客户端浏览器支持cookie：<ul>\n<li>cookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效。</li>\n<li>session只能在本窗口以及子窗口内有效。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>8.跨域支持上不同<ul>\n<li>cookie支持跨域名访问。</li>\n<li>session不支持跨域名访问。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式事务\"><a href=\"#分布式事务\" class=\"headerlink\" title=\"分布式事务\"></a>分布式事务</h2><h2 id=\"分布式队列\"><a href=\"#分布式队列\" class=\"headerlink\" title=\"分布式队列\"></a>分布式队列</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"JVM内存模型\"><a href=\"#JVM内存模型\" class=\"headerlink\" title=\"JVM内存模型\"></a>JVM内存模型</h2><h3 id=\"程序计数器（线程私有）\"><a href=\"#程序计数器（线程私有）\" class=\"headerlink\" title=\"程序计数器（线程私有）\"></a>程序计数器（线程私有）</h3><blockquote>\n<p>对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。</p>\n</blockquote>\n<ul>\n<li>当前线程的行号指示器</li>\n<li>唯一一个不会抛出OutOfMemory的内存区域</li>\n</ul>\n<h3 id=\"Java虚拟机栈（线程私有）\"><a href=\"#Java虚拟机栈（线程私有）\" class=\"headerlink\" title=\"Java虚拟机栈（线程私有）\"></a>Java虚拟机栈（线程私有）</h3><blockquote>\n<p>栈描述的是Java方法执行的内存模型。</p>\n<p>每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>\n<p>局部变量表所需要的内存空间在编译期完成分配，当进入一个方法时，这个方法在栈中需要分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表大小。</p>\n</blockquote>\n<ul>\n<li>每个栈帧存放内容：<ol>\n<li>局部变量表（主要）： 方法参数、局部变量、编译器已知的数据类型</li>\n<li>操作数栈</li>\n<li>动态链接</li>\n<li>方法返回地址</li>\n</ol>\n</li>\n<li>可能出现两种异常：<ol>\n<li>线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverflowError。</li>\n<li>虚拟机栈空间可以动态扩展，当动态扩展是无法申请到足够的空间时，抛出OutOfMemory异常。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"本地方法栈（线程私有）\"><a href=\"#本地方法栈（线程私有）\" class=\"headerlink\" title=\"本地方法栈（线程私有）\"></a>本地方法栈（线程私有）</h3><ul>\n<li>本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++</li>\n</ul>\n<h3 id=\"堆（线程共享）\"><a href=\"#堆（线程共享）\" class=\"headerlink\" title=\"堆（线程共享）\"></a>堆（线程共享）</h3><blockquote>\n<p>标量替换</p>\n<p>1、标量是指不可分割的量，如java中基本数据类型和reference类型，相对的一个数据可以继续分解，称为聚合量；</p>\n<p>2、如果把一个对象拆散，将其成员变量恢复到基本类型来访问就叫做标量替换；</p>\n<p>3、如果逃逸分析发现一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是在栈上创建若干个成员变量；</p>\n</blockquote>\n<ul>\n<li>存放对象实例及数组， 但随着JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对(标量替换)</li>\n<li>大小可固定也可扩展，如果堆中没有内存完成实例分配，而且堆无法扩展将报OOM错误(OutOfMemoryError)</li>\n</ul>\n<h3 id=\"方法区（线程共享）\"><a href=\"#方法区（线程共享）\" class=\"headerlink\" title=\"方法区（线程共享）\"></a>方法区（线程共享）</h3><ul>\n<li>用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。</li>\n</ul>\n<h2 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h2><h3 id=\"判断对象是否存活算法\"><a href=\"#判断对象是否存活算法\" class=\"headerlink\" title=\"判断对象是否存活算法\"></a>判断对象是否存活算法</h3><ul>\n<li>引用计数法<ul>\n<li>原理：通过在对象头中分配一个空间来保存该对象被引用的次数。如果该对象被其它对象引用，则它的引用计数+1，如果删除对该对象的引用，那么它的引用计数就-1，当该对象的引用计数为0时，那么该对象就会被回收。</li>\n<li>缺点：循环引用问题—如果有两个对象相互引用，那么这两个对象就不能被回收，因为它们的引用计数始终为1。这也就是我们常说的“内存泄漏”问题。</li>\n</ul>\n</li>\n<li>可达性分析法（主流）<ul>\n<li>原理：从GCroot结点开始向下搜索，路径称为引用链，当对象没有任何一条引用链链接的时候，就认为这个对象是垃圾，并进行回收。</li>\n<li>可作为GCroot的对象（GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收）：<ol>\n<li>虚拟机栈（局部变量表）—局部变量或参数</li>\n<li>方法区中的类静态属性引用的对象</li>\n<li>方法区中的常量引用的对象</li>\n<li>本地方法栈中JNI（native方法）引用的对象</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如何回收—三大垃圾收集算法\"><a href=\"#如何回收—三大垃圾收集算法\" class=\"headerlink\" title=\"如何回收—三大垃圾收集算法\"></a>如何回收—三大垃圾收集算法</h3><ul>\n<li><ol>\n<li><p>标记-清除法</p>\n<ul>\n<li>概念：<ol>\n<li>mutator：应用程序本身，负责NEW(分配内存)、READ(从内存中读取内容)、WRITE(将内容写入内存)</li>\n<li>collector：垃圾收集器，回收不再使用的内存，供mutator进行NEW操作</li>\n</ol>\n</li>\n<li>算法原理：标记阶段和清除阶段<ul>\n<li>标记阶段：collector从mutator根对象开始进行遍历，对从mutator根对象可以访问到的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象。</li>\n<li>清除阶段：collector对堆内存(heap memory)从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象-通过读取对象的header信息，则就将其回收。</li>\n<li>Tips：Collector在进行标记和清除阶段时会将整个应用程序暂停(mutator)，等待标记清除结束后才会恢复应用程序的运行，这也是Stop-The-World这个单词的来历。</li>\n</ul>\n</li>\n<li>缺点：垃圾收集后有可能会造成大量的内存碎片，假设一个方格代表1个单位的内存，如果有一个对象需要占用3个内存单位的话，那么就会导致Mutator一直处于暂停状态，而Collector一直在尝试进行垃圾收集，直到Out of Memory。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>2.复制算法</p>\n<ul>\n<li>算法原理： 将堆内存对半分为两个半区，只用其中一个半区来进行对象内存的分配，如果在这个半区内存不够给新的对象分配了，那么就开始进行垃圾收集，将这个半区中的所有可达对象都拷贝到另外一个半区中去，然后继续在另外那个半区进行新对象的内存分配。</li>\n<li>优点：解决内存碎片问题</li>\n<li>缺点：可用堆内存减少了一半</li>\n<li>适用场景：回收小的、存活期短的对象，主要针对新生代内存收集方法</li>\n</ul>\n</li>\n<li><p>3.标记-整理算法</p>\n<ul>\n<li><p>算法原理： 标记和整理阶段。</p>\n<ul>\n<li>标记阶段与标记清除算法一样</li>\n<li>整理阶段：移动所有的可达对象到堆内存的同一个区域中，使他们紧凑的排列在一起，从而将所有非可达对象释放出来的空闲内存都集中在一起，通过这样的方式来达到减少内存碎片的目的。</li>\n</ul>\n</li>\n<li><p>优点：解决内存碎片问题</p>\n</li>\n<li><p>缺点：引用额外空间来保存迁移地址，需要遍历多次堆内存</p>\n</li>\n<li><p>使用场景：主要针对的是老年代内存收集方法</p>\n<blockquote>\n<p>新生代和老年代大小分配： &gt; 响应时间和吞吐量优先的应用，尽可能设置大的新生代和小的老年代</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>分代收集算法</p>\n<ul>\n<li>算法原理：根据对象存活的生命周期将内存划分为若干个不同的区域。对不同区域采用不同的回收算法</li>\n<li>新生代<ul>\n<li>新生代包括：<ol>\n<li>Eden 伊甸园</li>\n<li>Survivor 存活区</li>\n<li>Tenured Gen 养老区</li>\n</ol>\n</li>\n<li>采取<strong>复制算法</strong>，每次垃圾回收都要回收大部分对象，复制操作较少。一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。</li>\n</ul>\n</li>\n<li>老年代<ul>\n<li>采取<strong>标记整理算法</strong>，每次回收都只回收少量对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如何回收—常见垃圾回收器\"><a href=\"#如何回收—常见垃圾回收器\" class=\"headerlink\" title=\"如何回收—常见垃圾回收器\"></a>如何回收—常见垃圾回收器</h3><ul>\n<li><p>Serial/Serial Old</p>\n<ul>\n<li>特点：<ol>\n<li>最古老的的垃圾收集器。</li>\n<li>单线程垃圾收集器，在它进行垃圾收集时，必须暂停所有用户线程。</li>\n<li>Serial主要针对新生代，采用复制算法。Serial Old针对老年代，采用标记整理算法</li>\n</ol>\n</li>\n<li>优点：简单高效</li>\n<li>缺点：停顿</li>\n</ul>\n</li>\n<li><p>ParNew</p>\n<ul>\n<li><p>特点：</p>\n<p>  ​    Serial的多线程版本</p>\n</li>\n</ul>\n</li>\n<li><p>Parallel Scavenge</p>\n<ul>\n<li>特点：<ol>\n<li>并行收集器，不需要暂停</li>\n<li>新生代，采用复制算法</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>Parallel Old</p>\n<ul>\n<li>特点：<ol>\n<li>Parallel Scavenge老年代版本，并行</li>\n<li>老年代，标记整理算法</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>CMS（Concurrent Mark Sweep）</p>\n<ul>\n<li>特点：<ol>\n<li>并发收集</li>\n<li>采用标记-清除算法</li>\n</ol>\n</li>\n<li>优点：快</li>\n<li>缺点：<ol>\n<li>占用CPU</li>\n<li>浮动垃圾</li>\n<li>出现ConcurrentMode Failure</li>\n<li>空间碎片</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>G1</p>\n<ul>\n<li>特点<ol>\n<li>当今最前沿的收集器，面向服务端应用</li>\n<li>并行与并发收集器，能建立可预测的停顿时间模型。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p>按代分类</p>\n<ul>\n<li>年轻代收集器<ul>\n<li>Serial、ParNew、Parallel Scavenge</li>\n</ul>\n</li>\n<li>老年代收集器<ul>\n<li>Serial Old、Parallel Old、CMS收集器</li>\n</ul>\n</li>\n<li>特殊收集器<ul>\n<li>G1收集器[新型，不在年轻、老年代范畴内]</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h2><h3 id=\"加载过程：\"><a href=\"#加载过程：\" class=\"headerlink\" title=\"加载过程：\"></a>加载过程：</h3><ul>\n<li><p>加载</p>\n<ol>\n<li>通过全类名获取定义此类的二进制字节流</li>\n<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>\n<li>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</li>\n<li>Tips：一个非数组类的加载阶段（获取类的二进制字节流）是可控性最强的阶段，这一步我们可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</li>\n</ol>\n</li>\n<li><p>验证</p>\n<ul>\n<li><p>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全。 主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证。</p>\n<p>  <img src=\"https://i.loli.net/2021/09/18/F1BQWefNcAYUEDy.png\" alt=\"image20210918170036312\"></p>\n</li>\n</ul>\n</li>\n<li><p>准备</p>\n<ul>\n<li>为类变量（static修饰的字段变量）分配内存并且设置该类变量的初始值，（如static int i = 5 这里只是将 i 赋值为0，在初始化的阶段再把 i 赋值为5)，这里不包含final修饰的static ，因为final在编译的时候就已经分配了。这里不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象分配到Java堆中。</li>\n</ul>\n</li>\n<li><p>解析</p>\n<ul>\n<li>主要的任务是把常量池中的符号引用替换成直接引用，也就是得到类或者字段、方法在内存中的指针或者偏移量。</li>\n</ul>\n</li>\n<li><p>初始化</p>\n<ul>\n<li><p>如果该类具有父类就对父类进行初始化，执行其静态初始化器（静态代码块）和静态初始化成员变量。（前面已经对static 初始化了默认值，这里我们对它进行赋值，成员变量也将被初始化）</p>\n<p>  <img src=\"https://i.loli.net/2021/09/18/RLuVIpE7OWAx4Mz.png\" alt=\"image20210918170449021\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类与类加载器\"><a href=\"#类与类加载器\" class=\"headerlink\" title=\"类与类加载器\"></a>类与类加载器</h3><ul>\n<li>一旦一个类被加载到JVM中，同一个类就不会被再次载入了。</li>\n<li>在JVM中，一个类用其全类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。</li>\n<li>JVM预定义有三种类加载器<ul>\n<li>1.根类加载器<ul>\n<li>加载 Java 的核心类（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class），由C++实现，不是ClassLoader子类</li>\n</ul>\n</li>\n<li>2.扩展类加载器<ul>\n<li>它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。</li>\n</ul>\n</li>\n<li>3.系统类加载器<ul>\n<li>它负责在JVM启动时加载CLASSPATH环境变量所指定的JAR包和类路径。通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。用户自定义的类加载器默认以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h3><ul>\n<li><p>1.全盘负责</p>\n<ul>\n<li>当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入。</li>\n</ul>\n</li>\n<li><p>2.双亲委派</p>\n<ul>\n<li><p>如果一个类加载器收到了类加载请求，不会自己直接加载，而是把请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。</p>\n<p>  <img src=\"https://i.loli.net/2021/09/18/tJyd5oZ3aBS1pm9.png\" alt=\"image20210918170625728\"></p>\n</li>\n<li><p>优势</p>\n<ul>\n<li>1.避免类的重复加载。当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</li>\n<li>2.防止核心API库被随意篡改。假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现该类已被加载，则直接返回已加载过的Integer.class。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>3.缓存机制</p>\n<ul>\n<li>该机制保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为什么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"forName和loaderClass区别\"><a href=\"#forName和loaderClass区别\" class=\"headerlink\" title=\"forName和loaderClass区别\"></a>forName和loaderClass区别</h3><ul>\n<li>Class.forName()得到的class是已经初始化完成的。</li>\n<li>Classloader.loaderClass得到的class是还没有链接（验证，准备，解析三个过程被称为链接）的。</li>\n</ul>\n<h3 id=\"对象创建过程\"><a href=\"#对象创建过程\" class=\"headerlink\" title=\"对象创建过程\"></a>对象创建过程</h3><ul>\n<li>在准备实例化一个类的对象前，首先准备实例化该类的父类，依次递归直到递归到Object类。此时，首先实例化Object类，再依次对以下各类进行实例化，直到完成对目标类的实例化。具体而言，在实例化每个类时，都遵循如下顺序：先依次执行实例变量初始化和实例代码块初始化，再执行构造函数初始化。也就是说，编译器会将实例变量初始化和实例代码块初始化相关代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后，构造函数本身的代码之前。</li>\n</ul>\n<h3 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h3><ul>\n<li><p>对象头（markword）</p>\n<ul>\n<li><p>32位系统下，对象头8字节，64位则是16个字节</p>\n</li>\n<li><p>不同状态下存放数据</p>\n<p>  <img src=\"https://i.loli.net/2021/09/18/5UlmYsTDcFwKuX9.png\" alt=\"image20210918171629651\"></p>\n</li>\n</ul>\n</li>\n<li><p>实例数据</p>\n<ul>\n<li>存放对象程序中各种类型的字段类型，不管是从父类中继承下来的还是在子类中定义的。</li>\n<li>分配策略:相同宽度的字段总是放在一起，比如double和long</li>\n</ul>\n</li>\n<li><p>对齐填充</p>\n<ul>\n<li>仅起到占位符的作用满足JVM要求。</li>\n<li>由于HotSpot规定对象的大小必须是8的整数倍，对象头刚好是整数倍，如果实例数据不是的话，就需要占位符对齐填充。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h2><h3 id=\"具有可见性和原子性\"><a href=\"#具有可见性和原子性\" class=\"headerlink\" title=\"具有可见性和原子性\"></a>具有可见性和原子性</h3><h3 id=\"JMM关于synchronized的两条规定：\"><a href=\"#JMM关于synchronized的两条规定：\" class=\"headerlink\" title=\"JMM关于synchronized的两条规定：\"></a>JMM关于synchronized的两条规定：</h3><ul>\n<li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li>\n<li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时，需要从主内存中重新读取最新的值</li>\n</ul>\n<h3 id=\"线程执行互斥代码的过程：\"><a href=\"#线程执行互斥代码的过程：\" class=\"headerlink\" title=\"线程执行互斥代码的过程：\"></a>线程执行互斥代码的过程：</h3><ol>\n<li>获得互斥锁</li>\n<li>清空工作内存</li>\n<li>从主内存拷贝变量的最新副本到工作的内存</li>\n<li>执行代码</li>\n<li>将更改后的共享变量的值刷新到主内存</li>\n<li>释放互斥锁</li>\n</ol>\n<h3 id=\"锁升级\"><a href=\"#锁升级\" class=\"headerlink\" title=\"锁升级\"></a>锁升级</h3><ol>\n<li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁</li>\n<li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1</li>\n<li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li>\n<li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁</li>\n<li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li>\n<li>如果自旋成功则依然处于轻量级状态。</li>\n<li>如果自旋失败，则升级为重量级锁。</li>\n</ol>\n<h3 id=\"synchronized-能防止指令重排序吗？\"><a href=\"#synchronized-能防止指令重排序吗？\" class=\"headerlink\" title=\"synchronized 能防止指令重排序吗？\"></a>synchronized 能防止指令重排序吗？</h3><ul>\n<li>synchronized不能防止指令重排序，但是能保证有序性，这和volatile实现有序性的方式不同，synchronized是通过互斥锁来保证有序性，即在单线程中无论指令如何重排序，其产生的结果对于其他线程来说是一致的。而volatile是通过内存屏障实现的有序性，即防止指令重排序来保证有序性。</li>\n</ul>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><ul>\n<li><p>两个线程都在等待对方先完成，造成程序的停滞。</p>\n</li>\n<li><p>例如，现在张三想要李四的画，李四想要张三的书，张三对李四说“把你的画给我，我就给你书”，李四也对张三说“把你的书给我，我就给你画”两个人互相等对方先行动，就这么干等没有结果，这实际上就是死锁的概念。示例代码如下：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义张三类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zhangsan</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"张三对李四说：“你给我画，我就把书给你。”\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"张三得到画了。\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义李四类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lisi</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"李四对张三说：“你给我书，我就把画给你”\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"李四得到书了。\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadDeadLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Zhangsan zs = <span class=\"keyword\">new</span> Zhangsan();    <span class=\"comment\">// 实例化static型对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Lisi ls = <span class=\"keyword\">new</span> Lisi();    <span class=\"comment\">// 实例化static型对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>; <span class=\"comment\">// 声明标志位，判断那个先说话</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// 覆写run()方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (zs) &#123;  <span class=\"comment\">// 同步张三</span></span><br><span class=\"line\">                zs.say();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (ls) &#123;</span><br><span class=\"line\">                    zs.get();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (ls) &#123;</span><br><span class=\"line\">                ls.say();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (zs) &#123;</span><br><span class=\"line\">                    ls.get();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">        ThreadDeadLock t1 = <span class=\"keyword\">new</span> ThreadDeadLock();   <span class=\"comment\">// 控制张三</span></span><br><span class=\"line\">        ThreadDeadLock t2 = <span class=\"keyword\">new</span> ThreadDeadLock();   <span class=\"comment\">// 控制李四</span></span><br><span class=\"line\">        t1.flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        t2.flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        Thread thA = <span class=\"keyword\">new</span> Thread(t1);</span><br><span class=\"line\">        Thread thB = <span class=\"keyword\">new</span> Thread(t2);</span><br><span class=\"line\">        thA.start();</span><br><span class=\"line\">        thB.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 程序运行结果： 李四对张三说：“你给我书，我就把画给你” 张三对李四说：“你给我画，我就把书给你。</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>避免死锁</p>\n<ul>\n<li>加锁顺序（线程按照一定的顺序加锁）</li>\n<li>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）</li>\n<li>死锁检测</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JUC\"><a href=\"#JUC\" class=\"headerlink\" title=\"JUC\"></a>JUC</h2><h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><ul>\n<li><p>JMM模型</p>\n<p>  <img src=\"https://i.loli.net/2021/09/18/F23tz5UOqCEwJbA.png\" alt=\"image20210918171727328\"></p>\n</li>\n<li><p>可见性</p>\n<ul>\n<li>修改了变量后，新值对其他线程立即可见（基于内存屏障禁止指令重排实现可见性）：<ol>\n<li>对volatile变量执行写操作时，会在写操作后加入一条store屏障指令</li>\n<li>对volatile变量执行读操作时，会在读操作前加入一条load屏障指令</li>\n</ol>\n</li>\n<li>线程写volatile变量的过程：<ol>\n<li>改变线程工作内存中volatile变量副本的值</li>\n<li>将改变后的副本的值从工作内存刷新到主内存</li>\n</ol>\n</li>\n<li>线程读volatile变量的过程：<ol>\n<li>从主内存中读取volatile变量的最新值到线程的工作内存中</li>\n<li>从工作内存中读取volatile变量的副本</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>不具备原子性</p>\n<ul>\n<li>如 i++， 不是一个原子性操作，在实际执行时需要三步操作“读-改-写”，在操作未完成前其他线程修改了变量值的话，此操作就无效了</li>\n<li>解决方案：<ol>\n<li>synchronized</li>\n<li>ReentrantLock</li>\n<li>AtomicInterger</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>适用场合</p>\n<ul>\n<li>对变量的写入操作不依赖当前值，如n = n + 1， n ++</li>\n<li>该变量没有包含在具有其他变量的不变式中, 如 n &lt; m</li>\n</ul>\n</li>\n<li><p>和synchronizedvolatile的区别</p>\n<ul>\n<li>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；</li>\n<li>从内存可见性角度，volatile读相当于加锁，volatile写相当于解锁；</li>\n<li>synchronized既能够保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。</li>\n</ul>\n</li>\n<li><p>double check单例是否需要对实例使用volatile修饰？</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonClass</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SingletonClass instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//private static volatile SingletonClass instance = null;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonClass <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (SingletonClass<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> SingletonClass();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>答案是需要，因为<strong>new操作是非原子性的,一般来说包含三个步骤：1.给对象分配内存，2.初始化对象，3.将对象内存地址赋值给引用</strong>，正常来说是1-&gt;2-&gt;3这么个步骤，但是在指令重排序优化下，由于2、3不存在依赖性，可能会产生1-&gt;3&gt;2这样的顺序，即给引用赋值的操作先于初始化操作，那么在多线程环境下，一个线程执行重排序后的指令，刚好执行完给引用赋值这一步，并未进行初始化，另一个线程恰好执行到第一个if语句，此时引用非空，但是实例并没初始化完成，直接返回后，调用实例方法则会发生空指针异常。所以必须依靠volatile来防止重排序，这个时候使用volatile实际上是保证了第一个if读的时候的有序性，对volatile变量的写happen-before读，从而禁止了newSingletonClass()时的重排序。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Atomic包（CAS）\"><a href=\"#Atomic包（CAS）\" class=\"headerlink\" title=\"Atomic包（CAS）\"></a>Atomic包（CAS）</h3><ul>\n<li>常用类：<ol>\n<li>AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReference（ 原子引用（声明引用类型的原子类））</li>\n<li>AtomicIntegerArray 、AtomicLongArray 3.AtomicStampedReference（原子时间戳引用（根据版本号解决ABA问题））</li>\n</ol>\n</li>\n<li>核心方法：<ul>\n<li>boolean compareAndSet(expectedValue, updateValue) 使用CAS思想，依靠Unsafe类的CPU指令原语保证原子性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Locks包（AQS）\"><a href=\"#Locks包（AQS）\" class=\"headerlink\" title=\"Locks包（AQS）\"></a>Locks包（AQS）</h3><ul>\n<li>ReentrantLock（重入锁）<ul>\n<li>什么是可重入锁：同一线程外层函数获得锁之后，进入内层方法会自动获得锁，即线程可以进入任何一个已经拥有的锁所同步着的代码块</li>\n<li>ReentrantLock/Synchorized 典型的可重入锁，可重入锁作用：避免死锁</li>\n<li>lock可重复加，但是加几次就要释放几次，否则会阻塞</li>\n</ul>\n</li>\n<li>ReadWriteLock（读写锁）</li>\n</ul>\n<h3 id=\"并发容器（Collections）\"><a href=\"#并发容器（Collections）\" class=\"headerlink\" title=\"并发容器（Collections）\"></a>并发容器（Collections）</h3><ul>\n<li>Queue<ul>\n<li>ConcurrentLinkedQueue</li>\n<li>BlockingQueue</li>\n<li>Deque</li>\n</ul>\n</li>\n<li>CopyOnWriteArraySet</li>\n<li>CopyOnWriteArrayList</li>\n<li>ConcurrentSkipListSet</li>\n<li>ConcurrentMap<ul>\n<li>ConcurrentHashMap</li>\n<li>ConcurrentNavigableMap<ul>\n<li>ConcurrentSkipListMap</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"执行框架与线程池（Executor）\"><a href=\"#执行框架与线程池（Executor）\" class=\"headerlink\" title=\"执行框架与线程池（Executor）\"></a>执行框架与线程池（Executor）</h3><ul>\n<li>Future<ul>\n<li>RunnableFuture<ul>\n<li>RunnableScheduledFuture</li>\n<li>FutureTask</li>\n</ul>\n</li>\n<li>ScheduledFuture</li>\n</ul>\n</li>\n<li>Callable</li>\n<li>Executor<ul>\n<li>ExecutorService<ul>\n<li>ScheduledExecutorService<ul>\n<li>ScheduledThreadPoolExecutor</li>\n</ul>\n</li>\n<li>ThreadPoolExecutor</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>CompletionService<ul>\n<li>ExecutorCompletionService</li>\n</ul>\n</li>\n<li>RejectedExecutionHandler<ul>\n<li>ThreadPoolExecutor.DiscardPolicy</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy</li>\n<li>ThreadPoolExecutor.AbortPolicy</li>\n</ul>\n</li>\n<li>TimeUnit</li>\n</ul>\n<h3 id=\"并发工具类（Tools）\"><a href=\"#并发工具类（Tools）\" class=\"headerlink\" title=\"并发工具类（Tools）\"></a>并发工具类（Tools）</h3><ul>\n<li>CountDownLatch</li>\n<li>CyclicBarrier</li>\n<li>Semaphore</li>\n<li>Executors</li>\n<li>Exchanger</li>\n</ul>\n<h2 id=\"集合（TODO-扩容机制）\"><a href=\"#集合（TODO-扩容机制）\" class=\"headerlink\" title=\"集合（TODO 扩容机制）\"></a>集合（TODO 扩容机制）</h2><h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><ul>\n<li><p>HashMap</p>\n<blockquote>\n<p>// 每个数组元素Entery（由key，value，next组成）存储一个链表的头结点Node。 // 当准备添加一个key-value对时，首先通过hash(key)方法计算hash值，然后通过indexFor(hash,length)求该key-value对的存储位置， // 计算方法是先用hash&amp;0x7FFFFFFF(16进制最大正整数按位与)后，再对length取模，这就保证每一个key-value对都能存入HashMap中。 // 没有产生hash冲突前，Node的next是null。当计算出的位置相同时，1.8之前将新的Node插入链表头部，1.8之后，这个链表只让挂7个元素， // 超过七个就会转成一个红黑树进行处理，当红黑树下挂的节点小于等于6的时候，系统会把红黑树转成链表，新的Node插入链表的尾部。</p>\n</blockquote>\n<ul>\n<li>数组+链表(1.8优化成数组+链表+红黑树)的组合实现，数组存储数据，链表解决冲突</li>\n<li>线程不安全，继承自AbstractMap类，key可有一个为null，value可有多个null。默认容量为16。</li>\n<li>jdk1.7和1.8的区别： 1) 1.7使用hash+单链表（头插法），1.8使用hash+链表+红黑树（尾插法，链表长度&gt;7时转成红黑树）。避免出现逆序和链表死循环问题 2) 计算hashcode的方法不同，1.7经过4次位移运算5次异或运算，1.8经过1次位移1次异或 3)扩容时重新计算元素位置的方法不同，1.7重新计算，1.8要么在原位置，要么原位置+扩容大小</li>\n<li>扩容为什么是2倍： 只有2的n次幂时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞（最后return的是h&amp;(length-1)，若尾数为0，那么0001、1001、1101等尾数为1的位置就永远不可能被entry占用）</li>\n</ul>\n</li>\n<li><p>Hashtable</p>\n<blockquote>\n<p>// HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。 // 因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法，可能会进入阻塞或轮询状态。 // 如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>\n</blockquote>\n<ul>\n<li>Hashtable线程安全，继承自Dictionary类。key和value都不能为null。默认容量为11。</li>\n</ul>\n</li>\n<li><p>ConcurrentHashMap</p>\n<blockquote>\n<p>// ConcurrentHashMap线程安全，采用分段锁达到高效并发，继承自AbstractMap类。ConcurrentHashMap包含两个静态内部类 HashEntry 和 Segment。 &gt; // HashEntry 用来封装映射表的键 / 值对;Segment 用来充当锁的角色。 &gt; // 一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组，若干个 HashEntry 对象链接起来的链表组成桶。 &gt; // 每个Segment守护着一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 &gt; // put、get不需要跨段，有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。 &gt; // 这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的， &gt; // 但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。</p>\n</blockquote>\n<ul>\n<li>ConcurrentHashMap线程安全，采用分段锁达到高效并发，继承自AbstractMap类</li>\n</ul>\n</li>\n<li><p>LinkedHashMap</p>\n<ul>\n<li>LinkedHashMap继承自HashMap，所以它的底层仍然是基于拉链式散列结构，在数组+链表/红黑树的结构上，维护了一条双向链表，保持遍历顺序和插入顺序一致的问题。</li>\n<li>线程不安全，增删快。允许有null值null键。</li>\n</ul>\n</li>\n<li><p>TreeMap</p>\n<ul>\n<li>TreeMap实现了SortedMap接口，保证了有序性。线程不安全。不允许有null值null键。</li>\n<li>默认的排序是根据key值进行升序排序，也可以重写comparator方法来根据value进行排序具体取决于使用的构造方法。</li>\n<li>基于红黑树（Red-Black tree）实现，基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n)。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><ul>\n<li>ArrayList<ul>\n<li>ArrayList底层结构为数组，线程不安全。查找快，增删慢(除了头尾)。</li>\n</ul>\n</li>\n<li>Vector<ul>\n<li>Vector底层结构为数组，线程安全(synchronized)。查找慢，增删快。</li>\n</ul>\n</li>\n<li>LinkedList<ul>\n<li>LinkedList底层结构为双向链表，线程不安全。查找慢，增删快(除了头尾)。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><ul>\n<li>HashSet<ul>\n<li>HashSet底层结构为Hash表。无序，无重复值。</li>\n</ul>\n</li>\n<li>LinkedHashSet<ul>\n<li>LinkedHashSet底层结构为双向链表。有序，无重复值。</li>\n<li>继承于HashSet、又基于LinkedHashMap 来实现的</li>\n</ul>\n</li>\n<li>TreeSet<ul>\n<li>TreeSet底层结构为红黑树。有序，无重复值。效率低。可自定义排序。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><blockquote>\n<p>TreeMap、TreeSet及java8HashMap使用</p>\n</blockquote>\n<ul>\n<li>特点：<ol>\n<li>自平衡二叉树</li>\n<li>根节点为黑色</li>\n<li>红色节点的两个子节点都是黑色</li>\n<li>任一节点到每个叶子的所有路径都包含相同数目的黑节点</li>\n</ol>\n</li>\n<li>插入或删除节点时，规则可能被打破，这时需要动态调整，维持规则（特点3和4）：<ol>\n<li>变色</li>\n<li>旋转：左旋、右旋</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"spring\"><a href=\"#spring\" class=\"headerlink\" title=\"spring\"></a>spring</h2><h3 id=\"IoC与DI\"><a href=\"#IoC与DI\" class=\"headerlink\" title=\"IoC与DI\"></a>IoC与DI</h3><ul>\n<li>IoC：控制反转 反转对象的创建方式，由自己创建反转给程序创建</li>\n<li>DI：依赖注入 不自己定义需要的类，直接向spring容器索取。IoC需要DI支持</li>\n<li>优点：<ol>\n<li>降低组件耦合度</li>\n<li>提供服务，如事务管理，消息处理等。不需要手工控制事务处理复杂的事务传播</li>\n<li>减少代码量</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h3><h3 id=\"spring工作流\"><a href=\"#spring工作流\" class=\"headerlink\" title=\"spring工作流\"></a>spring工作流</h3><ul>\n<li><p>解析过程：读xml配置，扫描类文件，从配置或注解中获取bean的定义信息，注册一些扩展功能</p>\n</li>\n<li><p>加载过程：通过解析完的定义信息获取bean实例 获取完整定义 -&gt; 实例化 -&gt; 依赖注入 -&gt; 初始化 -&gt; 类型转换。</p>\n<ul>\n<li><p>1.获取BeanName：对传入的name进行解析，转化为可以从Map中获取到BeanDefinition的bean name</p>\n<ul>\n<li>解析完配置后创建的 Map，使用的是 beanName 作为 key，BeanFactory.getBean 中传入的 name，有可能是这几种情况：<ol>\n<li>bean name，可以直接获取到定义 BeanDefinition。</li>\n<li>alias name，别名，需要转化。在解析阶段，alias name 和 bean name 的映射关系被注册到 SimpleAliasRegistry 中。从该注册器中取到 beanName。</li>\n<li>factorybean name, 带 &amp; 前缀，通过它获取 BeanDefinition 的时候需要去除 &amp; 前缀。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>2.合并 BeanDefinition：对父类的定义进行合并和覆盖，如果父类还有父类，会进行递归合并，以获取完整的 Bean 定义信息。</p>\n<ul>\n<li>从配置文件读取到的 BeanDefinition 是 GenericBeanDefinition,在后续实例化 Bean 的时候，使用的是 RootBeanDefinition,如果存在继承关系，GenericBeanDefinition 存储的是 增量信息 而不是 全量信息。在判断 parentName 存在的情况下，说明存在父类定义，启动合并。如果父类还有父类怎么办？递归调用，继续合并。合并完父类定义后，都会调用 RootBeanDefinition.overrideFrom 对父类的定义进行覆盖，获取到当前类能够正确实例化的 全量信息</li>\n</ul>\n</li>\n<li><p>3.实例化：使用构造或者工厂方法创建 Bean 实例（动态代理+ 反射）。</p>\n<ul>\n<li><p>获取到完整的 RootBeanDefintion 后，就可以拿这份定义信息来实例具体的 Bean。具体实例创建见 AbstractAutowireCapableBeanFactory.createBeanInstance ，返回 Bean 的包装类 BeanWrapper，一共有三种策略：</p>\n<ol>\n<li><p>使用工厂方法创建，instantiateUsingFactoryMethod 。</p>\n</li>\n<li><p>使用有参构造函数创建，autowireConstructor。</p>\n</li>\n<li><p>使用无参构造函数创建，instantiateBean。</p>\n<p>三个实例化方式，最后都会走 getInstantiationStrategy().instantiate() 虽然拿到了构造函数，并没有立即实例化。因为用户使用了 replace 和 lookup 的配置方法，用到了动态代理加入对应的逻辑。如果没有的话，直接使用反射来创建实例。 创建实例后，就可以开始注入属性和初始化等操作。</p>\n</li>\n</ol>\n</li>\n<li><p>实例化时的<strong>循环依赖问题</strong>，分两种：</p>\n<ol>\n<li>构造器循环依赖。依赖的对象是通过构造器传入的，发生在实例化 Bean 的时候。</li>\n<li>设值循环依赖。依赖的对象是通过 setter 方法传入的，对象已经实例化，发生属性填充和依赖注入的时候。 如果是构造器循环依赖，本质上是无法解决的。比如我们准调用 A 的构造器，发现依赖 B，于是去调用 B 的构造器进行实例化，发现又依赖 C，于是调用 C 的构造器去初始化，结果依赖 A，整个形成一个死结，导致 A 无法创建。</li>\n</ol>\n<ul>\n<li><p>如果是设值循环依赖，Spring 框架只支持单例下的设值循环依赖。Spring 通过对还在创建过程中的单例，缓存并提前暴露该单例，使得其他实例可以引用该依赖。</p>\n</li>\n<li><p>原型模式的任何循环依赖都不支持 单例模式下，构造函数的循环依赖无法解决，但设值循环依赖是可以解决的（提前暴露创建中的单例）。 为了能够实现单例的提前暴露。Spring 使用了三级缓存，见 DefaultSingletonBeanRegistry 这三个缓存的区别如下：</p>\n<ol>\n<li><p>singletonObjects，单例缓存，存储已经实例化完成的单例。</p>\n</li>\n<li><p>singletonFactories，生产单例的工厂的缓存，存储工厂。</p>\n</li>\n<li><p>earlySingletonObjects，提前暴露的单例缓存，这时候的单例刚刚创建完，但还会注入依赖 先尝试从 singletonObjects 和 singletonFactory 读取，没有数据，然后尝试 singletonFactories 读取 singletonFactory，执行 getEarlyBeanReference 获取到引用后，存储到 earlySingletonObjects 中。 这个 earlySingletonObjects 的好处是，如果此时又有其他地方尝试获取未初始化的单例，可以从 earlySingletonObjects 直接取出而不需要再调用 getEarlyBeanReference。 实际上注入 C 的 A 实例，还在填充属性阶段，并没有完全地初始化。等递归回溯回去，A 顺利拿到依赖 B，才会真实地完成 A 的加载。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; singletonObjects = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class=\"number\">256</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class=\"keyword\">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;(<span class=\"number\">16</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>4.属性填充：寻找并且注入依赖，依赖的 Bean 还会递归调用 getBean 方法获取。</p>\n<ul>\n<li>主要的处理环节有：<ol>\n<li>应用 InstantiationAwareBeanPostProcessor 处理器，在属性注入前后进行处理。假设我们使用了 @Autowire 注解，这里会调用到 AutowiredAnnotationBeanPostProcessor 来对依赖的实例进行检索和注入的，它是 InstantiationAwareBeanPostProcessor 的子类。</li>\n<li>根据名称或者类型进行自动注入，存储结果到 PropertyValues 中。</li>\n<li>应用 PropertyValues，填充到 BeanWrapper。这里在检索依赖实例的引用的时候，会递归调用 BeanFactory.getBean 来获得。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>5.初始化：调用自定义的初始化方法。</p>\n<ol>\n<li>触发Aware Spring 在初始化阶段，如果判断 Bean 实现了几个Aware接口之一，会往 Bean 中注入它关心的资源。</li>\n<li>触发 BeanPostProcessor（连接IOC和AOP的桥梁） 在 Bean 的初始化前或者初始化后，我们如果需要进行一些增强操作（AOP比如打日志、做校验、属性修改、耗时检测）</li>\n<li>触发自定义 init 自定义初始化有两种方式可以：<ol>\n<li>实现 InitializingBean。提供了一个很好的机会，在属性设置完成后再加入自己的初始化逻辑。</li>\n<li>定义 init 方法。自定义的初始化逻辑。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>6.获取最终的 Bean：如果是 FactoryBean 需要调用 getObject 方法，如果需要类型转换调用 TypeConverter 进行转化。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Bean的生命周期\"><a href=\"#Bean的生命周期\" class=\"headerlink\" title=\"Bean的生命周期\"></a>Bean的生命周期</h3><ul>\n<li><img src=\"https://i.loli.net/2021/09/18/162nF7qvMfN8iKy.png\" alt=\"image20210918174436691\"></li>\n<li>生命周期过程:<ol>\n<li>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</li>\n<li>Bean实例化后将Bean的引入和值注入到Bean的属性中</li>\n<li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</li>\n<li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</li>\n<li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</li>\n<li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</li>\n<li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</li>\n<li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</li>\n<li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</li>\n<li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><ul>\n<li><p>事务管理方式</p>\n<ul>\n<li>编程式事务管理： 代码中调用commit()、rollback()等事务管理方法</li>\n<li>声明式事务管理：<ol>\n<li>修改spring配置文件，添加事务管理器和事务代理类。</li>\n<li>基于Transactional注解</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>事务特性</p>\n<ol>\n<li>原子性：事务操作要么全部成功，要么全部失败</li>\n<li>一致性：事务执行前后一致，如转账不管转几次，账户总和不变</li>\n<li>隔离性：多个并发事务之间互相隔离</li>\n<li>持久性：事务一旦提交，数据改变是永久性的</li>\n</ol>\n</li>\n<li><p>隔离级别：</p>\n<ol>\n<li>读未提交：事务A读取到事务B未提交的记录，之后B回滚，造成A读取到的数据不是有效的，这种情况称为脏读</li>\n<li>读已提交：事务只能读取到已提交的记录。可避免脏读，但会发生不可重复读。如A两次读取同一条记录的过程中，B修改并提交了该记录，造成A两次结果不一致</li>\n<li>可重复读(mysql默认)：多次从数据库读取某条记录，结果一致。如果多条数据可能会出现幻读。如A读取多条数据，重复两次相同操作，过程中B插进了一条数据，造成A两次读取结果不一致</li>\n<li>串行化：事务执行时会在所有级别上加锁（read、write都加锁），仿佛事务以串行方式进行，性能会大幅下降</li>\n</ol>\n</li>\n<li><p>并发问题</p>\n<ul>\n<li>脏读<ul>\n<li>事务A读取到事务B未提交的记录，之后B回滚，造成A读取到的数据不是有效的</li>\n</ul>\n</li>\n<li>不可重复读<ul>\n<li>范围在同一条记录。如A两次读取同一条记录的过程中，B修改并提交了该记录，造成A两次结果不一致</li>\n</ul>\n</li>\n<li>幻读<ul>\n<li>范围在多条记录。如A读取多条数据，重复两次相同操作，过程中B插进了一条数据，造成A两次读取结果不一致</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>传播行为（Propagation）</p>\n<p>  ​    // 保证在同一个事务中：</p>\n<ul>\n<li><p>默认Propagation.REQUIRED:支持当前事务，假设当前没有事务。就新建一个事务。</p>\n</li>\n<li><p>SUPPORTS:支持当前事务，假设当前没有事务，就以非事务方式运行。</p>\n</li>\n<li><p>MANDATORY:支持当前事务，假设当前没有事务，就抛出异常。</p>\n<p>  // 保证在不同事务中</p>\n</li>\n<li><p>REQUIRES_NEW:新建事务，假设当前存在事务。把当前事务挂起。</p>\n</li>\n<li><p>NOT_SUPPORTED:以非事务方式运行操作。假设当前存在事务，就把当前事务挂起。</p>\n</li>\n<li><p>NEVER:以非事务方式运行，假设当前存在事务，则抛出异常。</p>\n</li>\n<li><p>NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"mysql\"><a href=\"#mysql\" class=\"headerlink\" title=\"mysql\"></a>mysql</h2><h3 id=\"MyISAM与InnoDB的区别\"><a href=\"#MyISAM与InnoDB的区别\" class=\"headerlink\" title=\"MyISAM与InnoDB的区别\"></a>MyISAM与InnoDB的区别</h3><ol>\n<li>InnoDB支持事务，MyISAM不支持</li>\n<li>InnoDB支持外键，MyISAM不支持</li>\n<li>InnoDB是聚集索引，MyISAM是非聚集索引。 聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>\n<li>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快</li>\n<li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一</li>\n</ol>\n<h3 id=\"二叉搜索树\"><a href=\"#二叉搜索树\" class=\"headerlink\" title=\"二叉搜索树\"></a>二叉搜索树</h3><p>特点:</p>\n<ol>\n<li>所有非叶子结点至多有两个儿子</li>\n<li>所有结点存储一个关键字</li>\n<li>非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树</li>\n</ol>\n<h3 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B-树\"></a>B-树</h3><ul>\n<li><p>多路搜索树</p>\n</li>\n<li><p>特性：</p>\n<ol>\n<li><p>所有非叶子结点最多只有M个儿子，M&gt;2</p>\n</li>\n<li><p>根节点儿子数为【2， M】</p>\n</li>\n<li><p>除根结点外的非叶子结点儿子数为【M/2，M】</p>\n</li>\n<li><p>每个结点存放【M/2-1，M-1】个关键字（至少2个）</p>\n</li>\n<li><p>非叶子结点的关键字个数=指向儿子的指针个数-1；</p>\n</li>\n<li><p>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</p>\n</li>\n<li><p>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</p>\n</li>\n<li><p>所有叶子结点位于同一层；</p>\n<p><img src=\"https://i.loli.net/2021/09/18/GU86gywBaA7cIiQ.png\" alt=\"image-20210918191232742\"></p>\n</li>\n</ol>\n</li>\n<li><p>总结：</p>\n<ol>\n<li>关键字集合分布在整颗树中；</li>\n<li>任何一个关键字出现且只出现在一个结点中；</li>\n<li>搜索有可能在非叶子结点结束；</li>\n<li>其搜索性能等价于在关键字全集内做一次二分查找；</li>\n<li>自动层次控制；</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"B-树-1\"><a href=\"#B-树-1\" class=\"headerlink\" title=\"B+树\"></a>B+树</h3><ul>\n<li><p>B+树是B-树的变体，也是一种多路搜索树：</p>\n<p>  <img src=\"https://i.loli.net/2021/09/18/mV5WLp2BusgXeqr.png\" alt=\"image-20210918191302660\"></p>\n</li>\n<li><p>特性：</p>\n<ol>\n<li>非叶子结点的子树指针与关键字个数相同；</li>\n<li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</li>\n<li>为所有叶子结点增加一个链指针；</li>\n<li>所有关键字都在叶子结点出现；</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"三种树对比\"><a href=\"#三种树对比\" class=\"headerlink\" title=\"三种树对比\"></a>三种树对比</h3><ul>\n<li>B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</li>\n<li>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</li>\n<li>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</li>\n</ul>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><h3 id=\"HTTP1-0和HTTP1-1的区别\"><a href=\"#HTTP1-0和HTTP1-1的区别\" class=\"headerlink\" title=\"HTTP1.0和HTTP1.1的区别\"></a>HTTP1.0和HTTP1.1的区别</h3><ul>\n<li>1.长连接(Persistent Connection)<ul>\n<li>HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。</li>\n<li>HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li>\n</ul>\n</li>\n<li>2.节约带宽<ul>\n<li>HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。</li>\n<li>HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。</li>\n</ul>\n</li>\n<li>3.HOST域<ul>\n<li>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</li>\n<li>HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。</li>\n</ul>\n</li>\n<li>4.缓存处理<ul>\n<li>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准</li>\n<li>HTTP1.1中引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>\n</ul>\n</li>\n<li>5.错误通知的管理<ul>\n<li>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTP1-1和HTTP2-0的区别\"><a href=\"#HTTP1-1和HTTP2-0的区别\" class=\"headerlink\" title=\"HTTP1.1和HTTP2.0的区别\"></a>HTTP1.1和HTTP2.0的区别</h3><ul>\n<li>1.多路复用<ul>\n<li>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</li>\n<li>HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</li>\n</ul>\n</li>\n<li>2.头部数据压缩<ul>\n<li>在HTTP1.1不支持header数据的压缩，HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。</li>\n<li>HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</li>\n</ul>\n</li>\n<li>3.服务器推送<ul>\n<li>服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。</li>\n<li>为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"TIME-WAIT和CLOSE-WAIT\"><a href=\"#TIME-WAIT和CLOSE-WAIT\" class=\"headerlink\" title=\"TIME_WAIT和CLOSE_WAIT\"></a>TIME_WAIT和CLOSE_WAIT</h3><ul>\n<li>TIME_WAIT：表示主动关闭，通过优化系统内核参数可容易解决。（要么就是对方连接的异常，要么就是自己没有迅速回收资源），解决方法：/etc/sysctl.conf修改，让服务器能够快速回收和重用那些TIME_WAIT的资源。</li>\n<li>CLOSE_WAIT：表示被动关闭，需要从程序本身出发。（在对方关闭连接之后服务器程序自己没有进一步发出ack信号，于是这个资源就一直 被程序占着） ESTABLISHED：表示正在通信</li>\n</ul>\n<h3 id=\"Https与加密算法\"><a href=\"#Https与加密算法\" class=\"headerlink\" title=\"Https与加密算法\"></a>Https与加密算法</h3><ul>\n<li>密码学在计算机科学中使用非常广泛，HTTPS就是建立在密码学基础之上的一种安全的通信协议</li>\n<li>对称秘钥:对称密钥加密又叫专用密钥加密，即发送和接收数据的双方必使用相同的密钥对明文进行加密和解密运算。通常有两种模式：流加密和分组加密。</li>\n<li>非对称秘钥：非对称加密算法需要两个密钥：公开秘钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</li>\n</ul>\n<h3 id=\"session和cookie区别\"><a href=\"#session和cookie区别\" class=\"headerlink\" title=\"session和cookie区别\"></a>session和cookie区别</h3><ul>\n<li>1.存储位置不同<ul>\n<li>cookie的数据信息存放在客户端浏览器上。</li>\n<li>session的数据信息存放在服务器上。</li>\n</ul>\n</li>\n<li>2.存储容量不同<ul>\n<li>单个cookie保存的数据&lt;=4KB，一个站点最多保存20个Cookie。</li>\n<li>对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制</li>\n</ul>\n</li>\n<li>3.存储方式不同<ul>\n<li>cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。</li>\n<li>session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。</li>\n</ul>\n</li>\n<li>4.隐私策略不同<ul>\n<li>cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。</li>\n<li>session存储在服务器上，对客户端是透明对，不存在敏感信息泄漏的风险。</li>\n</ul>\n</li>\n<li>5.有效期上不同<ul>\n<li>开发可以通过设置cookie的属性，达到使cookie长期有效的效果。</li>\n<li>session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。</li>\n</ul>\n</li>\n<li>6.服务器压力不同<ul>\n<li>cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。</li>\n<li>session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。</li>\n</ul>\n</li>\n<li>7.浏览器支持不同<ul>\n<li>假如客户端浏览器不支持cookie：<ul>\n<li>cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。</li>\n<li>运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。</li>\n</ul>\n</li>\n<li>假如客户端浏览器支持cookie：<ul>\n<li>cookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效。</li>\n<li>session只能在本窗口以及子窗口内有效。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>8.跨域支持上不同<ul>\n<li>cookie支持跨域名访问。</li>\n<li>session不支持跨域名访问。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式事务\"><a href=\"#分布式事务\" class=\"headerlink\" title=\"分布式事务\"></a>分布式事务</h2><h2 id=\"分布式队列\"><a href=\"#分布式队列\" class=\"headerlink\" title=\"分布式队列\"></a>分布式队列</h2>"},{"title":"不做第二个蛋壳","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":null,"abbrlink":"7b21","date":"2020-12-18T16:00:00.000Z","subtitle":null,"_content":"\n### 不做第二个蛋壳","source":"_posts/read-test.md","raw":"---\ntitle: 不做第二个蛋壳\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop:\ntags:\n  - finance\ncategories:\n  - life\nabbrlink: 7b21\ndate: 2020-12-19 00:00:00\nsubtitle:\n---\n\n### 不做第二个蛋壳","slug":"read-test","published":1,"updated":"2021-12-10T09:05:27.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1bt001yacbf64wl34n1","content":"<h3 id=\"不做第二个蛋壳\"><a href=\"#不做第二个蛋壳\" class=\"headerlink\" title=\"不做第二个蛋壳\"></a>不做第二个蛋壳</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"不做第二个蛋壳\"><a href=\"#不做第二个蛋壳\" class=\"headerlink\" title=\"不做第二个蛋壳\"></a>不做第二个蛋壳</h3>"},{"title":"BIO NIO与Netty","header-img":"/img/header_img/post-bg-desk.jpg","catalog":true,"top":1,"abbrlink":"5dae","date":"2021-08-24T16:00:00.000Z","subtitle":null,"_content":"# BIO、NIO与Netty\n\n\n\n> ### 网络编程：\n>\n> ​\t\t网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定的IP地址和监听端口），客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果连接建立成功，双方就可以通过网络套接字（Socket）进行通信。\n>\n> ### BIO:\n>\n> ​\t\t在1.4版本之前，Java IO类库是阻塞IO（Blocking IO），建立网络连接的时候采用BIO模式。\n>\n> ### NIO:\n>\n> ​\t\t为了支持非阻塞IO，Java引进了新的IO库，简称为JAVA NIO（Non-Blocking IO）。Java NIO属于 IO多路复用模型。\n>\n> ### Netty:\n>\n> ​\t\tNetty是一个异步的、[事件驱动](https://baike.baidu.com/item/事件驱动/9597519)的网络应用程序框架，基于NIO，使用Netty 可以快速开发出一个网络应用，例如实现了某种协议的客户、[服务端](https://baike.baidu.com/item/服务端/6492316)应用。\n\n\n\n## 1. Java BIO\n\n### 1.1 Java BIO模型\n\n- 同步阻塞IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，在高并发的应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。\n\n    ![bio-model](https://i.loli.net/2021/10/18/6jJxcVENwszR8Wd.png)\n\n### 1.2 Java BIO 工作流程\n\n1. 服务器端启动一个 `ServerSocket`，监听端口。\n2. 客户端启动 `Socket` 与服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯。\n3. 客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待或被拒绝，如果有响应，客户端线程会等待请求结束后继续执行。\n\n### 1.3 Java BIO代码示例([所有代码可前往github下载](https://github.com/VickyLuoLuo/netty.git))\n\n- 最简单的BIO服务器：\n\n```java\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class BioServer {\n\n    public static void main(String[] args) throws IOException {\n        // 创建ServerSocket\n        ServerSocket serverSocket = new ServerSocket(9090);\n        System.out.println(\"服务器启动\");\n        while (true) {\n            //监听，等待客户端连接\n            System.out.println(\"等待连接....\");\n            final Socket socket = serverSocket.accept(); // 阻塞\n            System.out.println(\"连接到一个客户端\");\n            byte[] bytes = new byte[1024];\n            socket.getInputStream().read(bytes); // 阻塞\n            System.out.println(\"收到客户端消息：\" + new String(bytes));\n        }\n    }\n}\n```\n\n- 我们可以对上述代码进行优化，将`socket.getInputStream().read(bytes)`消息处理部分改成线程池异步处理：\n\n```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class BioServer {\n\n    public static void main(String[] args) throws IOException {\n        // 创建ServerSocket\n        ServerSocket serverSocket = new ServerSocket(9090);\n        System.out.println(\"服务器启动\");\n        // 线程池机制,思路: 1. 创建一个线程池 2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)\n        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();\n        while (true) {\n            //监听，等待客户端连接\n            System.out.println(\"等待连接....\");\n            final Socket socket = serverSocket.accept(); // 阻塞\n            System.out.println(\"连接到一个客户端\");\n            newCachedThreadPool.execute(() -> {\n                // 通讯处理\n                handler(socket);\n            });\n        }\n    }\n\n    public static void handler(Socket socket) {\n        try {\n            byte[] bytes = new byte[1024];\n            //通过socket获取输入流\n            InputStream inputStream = socket.getInputStream();\n            //循环的读取客户端发送的数据\n            while (true) {\n                System.out.println(\"handler线程：id = \" + Thread.currentThread().getId() + \"等待接收消息\");\n                int read = inputStream.read(bytes); // 阻塞\n                if (read != -1) {\n                    System.out.println(\"handler线程：id = \" + Thread.currentThread().getId() + \"收到消息：\" + new String(bytes, 0, read));\n                } else {\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            System.out.println(\"handler线程：id = \" + Thread.currentThread().getId() + \"关闭连接\"); \n            try {\n                socket.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n​\t\t这样可以同时处理多个连接请求，但是由于`inputStream.read(bytes)`是阻塞的，当有多个连接请求时，每个连接占用一个线程，此时如果大部分连接都没有发送消息，线程就一直被占用，造成资源浪费。\n\n## 2. Java NIO\n\n### 2.1 Java NIO模型\n\n- 同步非阻塞IO，服务器实现模式为一个线程处理多个连接请求，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 `I/O` 请求就进行处理。\n\n    ![nio-model](https://i.loli.net/2021/10/18/ABy7qJoGhwaSzip.png)\n\n### 2.2 Java NIO的三大核心组件\n\n1. ####  通道（Channel）\n\n    在BIO中，同一个网络连接会通过输入流（Input Stream）和输出流（Output Stream）不断地进行输入和输出的操作。在NIO中，同一个网络连接使用一个通道表示，所有的NIO的IO操作都是从通道开始的。一个通道类似于BIO中的两个流的结合体，既可以从通道读取，也可以向通道写入。\n\n2. ####  选择器（Selector）\n\n    > IO多路复用指的是一个进程/线程可以同时监视多个文件描述符（一个网络连接，操作系统底层使用一个文件描述符来表示），一旦其中的一个或者多个文件描述符可读或者可写，系统内核就通知该进程/线程。\n\n    通过选择器，一个线程可以查询多个通道的IO事件的就绪状态，即监视多个文件描述符。具体的开发层面来说，首先把通道注册到选择器中，然后通过选择器内部的机制，可以查询（select）这些注册的通道是否有已经就绪的IO事件（例如可读、可写、网络连接完成等）。一个选择器只需要一个线程进行监控，系统不必为每一个网络连接（文件描述符）创建进程/线程，从而大大减小了系统的开销。\n\n3. #### 缓冲区（Buffer）\n\n    应用程序与通道（Channel）主要的交互操作，就是进行数据的read读取和write写入。通道的读取，就是将数据从通道读取到缓冲区中；通道的写入，就是将数据从缓冲区中写入到通道中。\n\n### 2.3 Selector、Channel 和 Buffer的 关系\n\n1. 每个 `Channel` 都会对应一个 `Buffer`。\n2. `Selector` 对应一个线程，一个线程对应多个 `Channel`（连接）。\n3. `Selector` 会根据不同的事件，在各个通道上切换。\n4. `Buffer` 就是一个内存块，底层是一个数组。\n5. 数据通过 `Buffer`进行读写，`BIO` 中要么是输入流，要么是输出流，不能双向，但是 `NIO` 的 `Buffer` 是可以读也可以写，需要 `flip` 方法切换 。`Channel` 是双向的，可以返回底层操作系统的情况，比如 `Linux`，底层的操作系统通道就是双向的。\n\n![nio-element](https://i.loli.net/2021/10/18/4F5pSqTYbayDgsJ.png)\n\n### 2.4 Java NIO 工作流程\n\n1. 服务器端启动一个 `ServerSocketChannel`，监听端口。---类似BIO中的ServerSocket。\n\n2. 客户端启动 `SocketChannel`与服务器进行通信。---类似BIO中的Socket。\n\n3. 获取`Selector`选择器，并将`ServerSocketChannel`注册到`Selector`上，接收新连接。注册后返回一个 `SelectionKey`（集合），会和该 `Selector` 关联。一个 `Selector` 上可以注册多个 `SocketChannel`。\n\n4. 当客户端连接时，服务端会通过 `ServerSocketChannel` 得到`SocketChannel`。\n\n5. `Selector` 进行监听 `select` 方法，返回有事件发生的通道的个数。\n\n6. 将 `socketChannel` 注册到 `Selector` 上，进一步得到各个 `SelectionKey`（有事件发生）。\n\n7. 在通过 `SelectionKey` 反向获取 `SocketChannel`。\n\n8. 可以通过得到的 `channel`，完成业务处理。\n\n    ![nio-workflow](https://i.loli.net/2021/10/18/ybcGt7zRT459L8Z.png)\n\n### 2.4 Java NIO 代码示例([所有代码可前往github下载](https://github.com/VickyLuoLuo/netty.git))\n\n- 简单的NIO服务器，使用一个集合`List<SocketChannel>`来存放所有从客户端接收到的`SocketChannel`，并一直轮询处理IO事件\n\n```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class NioServer {\n\n    static List<SocketChannel> channelList = new ArrayList<>();\n\n    public static void startServer() throws IOException {\n\n        // 获取通道\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        // 设置为非阻塞\n        serverSocketChannel.configureBlocking(false);\n        // 绑定连接\n        serverSocketChannel.bind(new InetSocketAddress(5252));\n        System.out.println(\"服务器启动成功\");\n\n        // 轮询感兴趣的IO就绪事件（选择键集合）\n        while (true) {\n\n            // 获取客户端连接\n            SocketChannel socketChannel = serverSocketChannel.accept(); // 非阻塞\n            if (null != socketChannel) {\n                System.out.println(\"连接成功\");\n                // 设置SocketChannel为非阻塞模式。NIO的非阻塞是由操作系统内部实现的，底层调用了系统内核的accept方法\n                socketChannel.configureBlocking(false);\n\n                channelList.add(socketChannel);\n            }\n            // 获取选择键集合\n            Iterator<SocketChannel> channels = channelList.iterator();\n            while (channels.hasNext()) {\n                // 获取单个的选择键并处理\n                SocketChannel channel = channels.next();\n                ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                // 调用通道的read方法，从通道读取数据写入缓冲区，并返回读取到的数据\n                int length = channel.read(byteBuffer); // 非阻塞\n                if (length > 0) {\n                    System.out.println(\"接收到消息：\" + new String(byteBuffer.array(), 0, length));\n                } else if (length == -1) {\n                    channels.remove();\n                    System.out.println(\"客户端断开连接\");\n                }\n\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        startServer();\n    }\n}\n```\n\n- 上述代码有个很严重的问题，由于关键的两个方法：接收连接`serverSocketChannel.accept()`和读取消息`channel.read(byteBuffer)`都是非阻塞的，`while(true)`就会无限循环直到内存溢出，`Selector`很好的解决了这个问题，`selector.select()`会阻塞，直到有事件发生：\n\n```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\n\npublic class NioSelectorServer {\n    public static void startServer() throws IOException {\n\n        // 获取通道\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        // 设置为非阻塞\n        serverSocketChannel.configureBlocking(false);\n        // 绑定连接\n        serverSocketChannel.bind(new InetSocketAddress(5656));\n        System.out.println(\"服务器启动成功\");\n\n        // 获取选择器\n        Selector selector = Selector.open(); // epoll\n        // 将通道注册的“接收新连接”IO事件注册到选择器上\n        SelectionKey selectionKey = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        // 轮询感兴趣的IO就绪事件（选择键集合）\n        while (selector.select() > 0) { // 阻塞 epoll-wait\n            // 获取选择键集合\n            Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();\n            while (selectedKeys.hasNext()) {\n                // 获取单个的选择键并处理\n                SelectionKey selectedKey = selectedKeys.next();\n                if (selectedKey.isAcceptable()) {\n                    // 若选择键的IO事件是“连接就绪”，就获取客户端连接\n                    SocketChannel socketChannel = serverSocketChannel.accept();\n                    // 切换为非阻塞模式\n                    socketChannel.configureBlocking(false);\n                    // 将新连接的通道可读事件注册到选择器上\n                    socketChannel.register(selector, SelectionKey.OP_READ);\n                    System.out.println(\"连接成功\");\n                } else if (selectedKey.isReadable()) {\n                    // 若选择键的IO事件是“可读”，就读取数据\n                    SocketChannel socketChannel = (SocketChannel) selectedKey.channel();\n                    // 读取数据，然后丢弃\n                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                    // 调用通道的read方法，从通道读取数据写入缓冲区，并返回读取到的数据\n                    int length = socketChannel.read(byteBuffer);\n                    if (length > 0) {\n                        System.out.println(\"接收到消息：\" + new String(byteBuffer.array(), 0, length));\n                    } else if (length == -1) {\n                        System.out.println(\"客户端断开连接\");\n                        socketChannel.close();\n                    }\n                }\n                // 移除选择键\n                selectedKeys.remove();\n            }\n        }\n        // 关闭连接\n        serverSocketChannel.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        startServer();\n    }\n}\n```\n\n### 2.5 多路复用器`Selector`\n\n​\t通过`Selector`，可以使用一个线程查询多个通道的IO事件的就绪状态，并在没有事件发生时阻塞。其原理依赖于`epoll`系统调用(Linux系统为例)，`epoll`系统调用的主要方法：\n\n1. epoll_create\n\n    创建一个epoll文件描述符。可简单理解为channel 集合。\n\n2. epoll_ctl\n\n    添加/修改/删除需要侦听的文件描述符及其事件。可简单理解为channel事件集合。\n\n3. epoll_wait\n\n    接收发生在被侦听的描述符上的，用户感兴趣的IO事件。可简单理解为 channel事件集合为空时阻塞。\n\n### 2.6 Java NIO 常用类及属性\n\n​\t\t参见另一篇博客：[Java NIO通信基础](https://vickyluoluo.github.io/2021/03/31/57bd.html)\n\n## 3. Netty\n\n### 3.1 原生NIO存在的问题\n\n1. `NIO` 的类库和 `API` 繁杂，使用麻烦：需要熟练掌握 `Selector`、`ServerSocketChannel`、`SocketChannel`、`ByteBuffer`等。\n2. 需要具备其他的额外技能：要熟悉 `Java` 多线程编程，因为 `NIO` 编程涉及到 `Reactor` 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 `NIO` 程序。\n3. 开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。\n4.  `JDK NIO` 的 `Bug`：例如臭名昭著的 `Epoll Bug`，它会导致 `Selector` 空轮询，最终导致 `CPU100%`。直到 `JDK1.7` 版本该问题仍旧存在，没有被根本解决\n\n### 3.2 Netty 的优点\n\n`Netty` 对 `JDK` 自带的 `NIO` 的 `API` 进行了封装，解决了上述问题。\n\n1. 设计优雅：适用于各种传输类型的统一 `API` 阻塞和非阻塞 `Socket`；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。\n2. 使用方便：详细记录的 `Javadoc`，用户指南和示例；没有其他依赖项，`JDK5（Netty3.x）`或 `6（Netty4.x）`就足够了。\n3. 高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。\n4. 安全：完整的 `SSL/TLS` 和 `StartTLS` 支持。\n5. 社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 `Bug` 可以被及时修复，同时，更多的新功能会被加入。\n\n### 3.3 Netty工作原理\n\n![](https://i.loli.net/2021/10/18/3cnCUJG4yerixqK.png)\n\n`Netty` 线程模型基于主从 `Reactors` 多线程模型，`BossGroup` 线程维护 `Selector`，只关注 `Accecpt` 当接收到 `Accept` 事件，获取到对应的 `SocketChannel`，封装成 `NIOScoketChannel` 并注册到 `Worker` 线程（事件循环），并进行维护当 `Worker` 线程监听到 `Selector` 中通道发生自己感兴趣的事件后，由 `handler`进行处理。\n\n![](https://i.loli.net/2021/10/18/chLyW8ko5aRuPqN.png)\n\n说明：\n\n1. `Netty` 抽象出两组线程池 `BossGroup` 专门负责接收客户端的连接，`WorkerGroup` 专门负责网络的读写\n2. `BossGroup` 和 `WorkerGroup` 类型都是 `NioEventLoopGroup` \n3. `NioEventLoopGroup` 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 `NioEventLoop` \n4. `NioEventLoop` 表示一个不断循环的执行处理任务的线程，每个 `NioEventLoop` 都有一个 `Selector`，用于监听绑定在其上的 `socket` 的网络通讯\n5. `NioEventLoopGroup` 可以有多个线程，即可以含有多个 `NioEventLoop` \n6. 每个 `BossNioEventLoop` 循环执行的步骤有 `3` 步\n    - 轮询 `accept` 事件\n    - 处理 `accept` 事件，与 `client` 建立连接，生成 `NioScocketChannel`，并将其注册到某个 `worker` `NIOEventLoop` 上的 `Selector`\n    - 处理任务队列的任务，即 `runAllTasks`\n7. 每个 `Worker` `NIOEventLoop` 循环执行的步骤\n    - 轮询 `read`，`write` 事件\n    - 处理 `I/O` 事件，即 `read`，`write` 事件，在对应 `NioScocketChannel` 处理\n    - 处理任务队列的任务，即 `runAllTasks`\n8. 每个 `Worker` `NIOEventLoop` 处理业务时，会使用 `pipeline`（管道），`pipeline` 中包含了 `channel`，即通过 `pipeline` 可以获取到对应通道，管道中维护了很多的处理器\n\n### 3.4 Netty 代码示例([所有代码可前往github下载](https://github.com/VickyLuoLuo/netty.git))\n\n- 简单的Netty服务器实现：\n    1. `NettyServer.java` 服务器启动类，通过链式编程配置启动参数并监听端口\n\n```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class NettyServer {\n\n    public static void main(String[] args) throws Exception {\n\n        //创建两个线程组bossGroup和workerGroup，默认子线程个数为cpu核数 * 2，bossGroup只处理连接请求,真正的客户端业务处理会交给workerGroup\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup(8);\n\n        try {\n            //创建服务器端的启动对象，配置参数\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            //使用链式编程来进行设置\n            bootstrap.group(bossGroup, workerGroup) //设置两个线程组\n                    .channel(NioServerSocketChannel.class) //使用NioSocketChannel 作为服务器的通道实现\n                    .option(ChannelOption.SO_BACKLOG, 128) // 初始化服务器接收连接的队列大小\n                    .childHandler(new ChannelInitializer<SocketChannel>() {//创建一个通道初始化对象(匿名对象)\n                        //给workGroup的SocketChannel设置处理器\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            System.out.println(\"客户socketchannel hashcode=\" + ch.hashCode()); //可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue\n                            ch.pipeline().addLast(new NettyServerHandler()); // 可添加多个\n                        }\n                    });\n\n            System.out.println(\".....服务器 is ready...\");\n\n            //启动服务器并绑定端口，bind是异步操作，可以通过isDone()等方法查看事件执行情况\n            ChannelFuture cf = bootstrap.bind(6668).sync();\n\n            //给cf 注册监听器，监控我们关心的事件\n            cf.addListener((ChannelFutureListener) future -> {\n                if (cf.isSuccess()) {\n                    System.out.println(\"监听端口成功\");\n                } else {\n                    System.out.println(\"监听端口失败\");\n                }\n            });\n\n            //对关闭通道进行监听\n            cf.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}\n```\n\n​\t\t\t2. `NettyServerHandler.java `自定义`ChannelHandler`处理业务，只需根据需要继承指定类型的抽象类，通过重载父类方法实现业务处理：\n\n```java\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.util.CharsetUtil;\n\npublic class NettyServerHandler extends ChannelInboundHandlerAdapter {\n\n    /**\n     * 当客户端连接服务器完成时触发\n     * @param ctx: 上下文对象, 含有 管道pipeline , 通道channel, 地址\n     */\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) {\n        System.out.println(\"客户端连接通道建立完成\");\n    }\n\n    /**\n     * 读取数据实际(这里我们可以读取客户端发送的消息)\n     * @param ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址\n     * @param msg: 就是客户端发送的数据 默认Object\n     */\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\n        Channel channel = ctx.channel();\n        //将 msg 转成一个 ByteBuf,ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.\n        ByteBuf buf = (ByteBuf) msg;\n        System.out.println(\"客户端发送消息是:\" + buf.toString(CharsetUtil.UTF_8));\n        System.out.println(\"客户端地址:\" + channel.remoteAddress());\n    }\n\n    /**\n     *  数据读取完毕\n     */\n    @Override\n    public void channelReadComplete(ChannelHandlerContext ctx) {\n        //将数据写入到缓存，并刷新\n        ctx.writeAndFlush(Unpooled.copiedBuffer(\"hello, 客户端\", CharsetUtil.UTF_8));\n    }\n\n    /**\n     * 处理异常, 一般关闭通道\n     * @param ctx\n     * @param cause\n     */\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n        ctx.close();\n    }\n}\n\n```\n\n- `SpringBoot` + `Netty`实现网络聊天室核心代码([完整代码可前往github下载](https://github.com/VickyLuoLuo/netty.git))：\n\n```java\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Component;\n\n@Component\n@Qualifier(\"somethingChannelInitializer\")\npublic class NettyWebSocketChannelInitializer extends ChannelInitializer<SocketChannel> {\n\n    @Autowired\n    private TextWebSocketFrameHandler textWebSocketFrameHandler;\n\n    @Override\n    public void initChannel(SocketChannel ch) throws Exception {//2\n        ChannelPipeline pipeline = ch.pipeline();\n\n        pipeline.addLast(new HttpServerCodec()); // http解编码器\n        pipeline.addLast(new HttpObjectAggregator(64*1024)); // 补充http解编码器\n        pipeline.addLast(new ChunkedWriteHandler()); // 保证队列中的每一个元素是一次性发送\n        pipeline.addLast(new WebSocketServerProtocolHandler(\"/ws\")); //\n        pipeline.addLast(textWebSocketFrameHandler); // 自定义ChannelHandler\n\n    }\n}\n```\n\n```java\nimport com.lhl.netty.chat.util.RandomName;\nimport com.lhl.netty.chat.util.RedisDao;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.handler.codec.http.websocketx.TextWebSocketFrame;\nimport io.netty.util.concurrent.GlobalEventExecutor;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Component;\n\n@Component\n@Qualifier(\"textWebSocketFrameHandler\")\n@ChannelHandler.Sharable\npublic class TextWebSocketFrameHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {\n\n    public static ChannelGroup channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n\n    @Autowired\n    private RedisDao redisDao;\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx,\n                                TextWebSocketFrame msg) throws Exception {\n        Channel incoming = ctx.channel();\n        String uName = redisDao.getString(incoming.id()+\"\");\n        for (Channel channel : channels) {\n            if (channel != incoming){\n                channel.writeAndFlush(new TextWebSocketFrame(\"[\" + uName + \"]\" + msg.text()));\n            } else {\n                channel.writeAndFlush(new TextWebSocketFrame(\"[我]\" + msg.text() ));\n            }\n        }\n    }\n\n    @Override\n    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n        System.out.println(ctx.channel().remoteAddress());\n        String uName = new RandomName().getRandomName();\n\n        Channel incoming = ctx.channel();\n        for (Channel channel : channels) {\n            channel.writeAndFlush(new TextWebSocketFrame(\"[新用户] - \" + uName + \" 加入群聊\"));\n        }\n        redisDao.saveString(incoming.id()+\"\",uName);\n        channels.add(ctx.channel());\n    }\n\n    @Override\n    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n        Channel incoming = ctx.channel();\n        String uName = redisDao.getString(String.valueOf(incoming.id()));\n        for (Channel channel : channels) {\n            channel.writeAndFlush(new TextWebSocketFrame(\"[用户] - \" + uName + \" 离开\"));\n        }\n        redisDao.deleteString(String.valueOf(incoming.id()));\n\n        channels.remove(ctx.channel());\n    }\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        Channel incoming = ctx.channel();\n        System.out.println(\"用户:\"+redisDao.getString(incoming.id()+\"\")+\"在线\");\n    }\n\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        Channel incoming = ctx.channel();\n        System.out.println(\"用户:\"+redisDao.getString(incoming.id()+\"\")+\"掉线\");\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)\n            throws Exception {\n        Channel incoming = ctx.channel();\n        System.out.println(\"用户:\"+redisDao.getString(incoming.id()+\"\")+\"异常\");\n        cause.printStackTrace();\n        ctx.close();\n    }\n\n}\n```\n\n### 3.5 Netty常用类及属性\n\n#### Bootstrap、ServerBootstrap\n\n1. `Bootstrap` 意思是引导，一个 `Netty` 应用通常由一个 `Bootstrap` 开始，主要作用是配置整个 `Netty` 程序，串联各个组件，`Netty` 中 `Bootstrap` 类是客户端程序的启动引导类，`ServerBootstrap` 是服务端启动引导类。\n2. 常见的方法有\n    - `public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)`，该方法用于服务器端，用来设置两个 `EventLoop`\n    - `public B group(EventLoopGroup group)`，该方法用于客户端，用来设置一个 `EventLoop`\n    - `public B channel(Class<? extends C> channelClass)`，该方法用来设置一个服务器端的通道实现\n    - `public <T> B option(ChannelOption<T> option, T value)`，用来给 `ServerChannel` 添加配置\n    - `public <T> ServerBootstrap childOption(ChannelOption<T> childOption, T value)`，用来给接收到的通道添加配置\n    - `public ServerBootstrap childHandler(ChannelHandler childHandler)`，该方法用来设置业务处理类（自定义的`handler`）\n    - `public ChannelFuture bind(int inetPort)`，该方法用于服务器端，用来设置占用的端口号\n    - `public ChannelFuture connect(String inetHost, int inetPort)`，该方法用于客户端，用来连接服务器端\n\n####  Future、ChannelFuture\n\n`Netty` 中所有的 `IO` 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 `Future` 和 `ChannelFutures`，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件\n\n常见的方法有\n\n- `Channel channel()`，返回当前正在进行 `IO` 操作的通道\n- `ChannelFuture sync()`，等待异步操作执行完毕\n\n#### Channel\n\n1. `Netty` 网络通信的组件，能够用于执行网络 `I/O` 操作。\n2. 通过 `Channel` 可获得当前网络连接的通道的状态\n3. 通过 `Channel` 可获得网络连接的配置参数（例如接收缓冲区大小）\n4. `Channel` 提供异步的网络 `I/O` 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 `I/O` 调用都将立即返回，并且不保证在调用结束时所请求的 `I/O` 操作已完成\n5. 调用立即返回一个 `ChannelFuture` 实例，通过注册监听器到 `ChannelFuture` 上，可以 `I/O` 操作成功、失败或取消时回调通知调用方\n6. 支持关联 `I/O` 操作与对应的处理程序\n7. 不同协议、不同的阻塞类型的连接都有不同的 `Channel` 类型与之对应，常用的 `Channel` 类型：\n    - `NioSocketChannel`，异步的客户端 `TCP` `Socket` 连接。\n    - `NioServerSocketChannel`，异步的服务器端 `TCP` `Socket` 连接。\n    - `NioDatagramChannel`，异步的 `UDP` 连接。\n    - `NioSctpChannel`，异步的客户端 `Sctp` 连接。\n    - `NioSctpServerChannel`，异步的 `Sctp` 服务器端连接，这些通道涵盖了 `UDP` 和 `TCP` 网络 `IO` 以及文件 `IO`。\n\n#### Selector\n\n1. `Netty` 基于 `Selector` 对象实现 `I/O` 多路复用，通过 `Selector` 一个线程可以监听多个连接的 `Channel` 事件。\n2. 当向一个 `Selector` 中注册 `Channel` 后，`Selector` 内部的机制就可以自动不断地查询（`Select`）这些注册的 `Channel` 是否有已就绪的 `I/O` 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 `Channel`\n\n#### ChannelHandler \n\n1. `ChannelHandler` 是一个接口，处理 `I/O` 事件或拦截 `I/O` 操作，并将其转发到其 `ChannelPipeline`（业务处理链）中的下一个处理程序。\n2. `ChannelHandler` 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类\n\n#### Pipeline 和 ChannelPipeline\n\n1. `ChannelPipeline` 是一个 `Handler` 的集合，它负责处理和拦截 `inbound` 或者 `outbound` 的事件和操作，相当于一个贯穿 `Netty` 的链。（也可以这样理解：`ChannelPipeline` 是保存 `ChannelHandler` 的 `List`，用于处理或拦截 `Channel` 的入站事件和出站操作）\n2. `ChannelPipeline` 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 `Channel` 中各个的 `ChannelHandler` 如何相互交互\n3. 在 `Netty` 中每个 `Channel` 都有且仅有一个 `ChannelPipeline` 与之对应，它们的组成关系如下\n\n![](https://i.loli.net/2021/10/18/oZARqLONHzbaGiP.png)\n\n​\t![](https://i.loli.net/2021/10/18/KeR8OM6uTVqhjFZ.png)\n\n4. 常用方法\n    `ChannelPipeline addFirst(ChannelHandler... handlers)`，把一个业务处理类（`handler`）添加到链中的第一个位置`ChannelPipeline addLast(ChannelHandler... handlers)`，把一个业务处理类（`handler`）添加到链中的最后一个位置\n\n#### ChannelHandlerContext\n\n1. 保存 `Channel` 相关的所有上下文信息，同时关联一个 `ChannelHandler` 对象\n2. 即 `ChannelHandlerContext` 中包含一个具体的事件处理器 `ChannelHandler`，同时 `ChannelHandlerContext` 中也绑定了对应的 `pipeline` 和 `Channel` 的信息，方便对 `ChannelHandler` 进行调用。\n3. 常用方法\n    - `ChannelFuture close()`，关闭通道\n    - `ChannelOutboundInvoker flush()`，刷新\n    - `ChannelFuture writeAndFlush(Object msg)`，将数据写到 \n    - `ChannelPipeline` 中当前 `ChannelHandler` 的下一个 `ChannelHandler` 开始处理（出站）\n\n![](https://i.loli.net/2021/10/18/qRSk7ezATLQtKV5.png)\n\n#### ChannelOption\n\n1. `Netty` 在创建 `Channel` 实例后，一般都需要设置 `ChannelOption` 参数。\n2. `ChannelOption` 参数如下：\n\n![](https://i.loli.net/2021/10/18/Z6pAFyCjhOU5dvg.png)\n\n#### EventLoopGroup\n\n1. `EventLoopGroup` 是一组 `EventLoop` 的抽象，`Netty` 为了更好的利用多核 `CPU` 资源，一般会有多个 `EventLoop` 同时工作，每个 `EventLoop` 维护着一个 `Selector` 实例。\n2. `EventLoopGroup` 提供 `next` 接口，可以从组里面按照一定规则获取其中一个 `EventLoop` 来处理任务。在 `Netty` 服务器端编程中，我们一般都需要提供两个 `EventLoopGroup`，例如：`BossEventLoopGroup` 和 `WorkerEventLoopGroup`。\n3. 通常一个服务端口即一个 `ServerSocketChannel` 对应一个 `Selector` 和一个 `EventLoop` 线程。`BossEventLoop` 负责接收客户端的连接并将 `SocketChannel` 交给 `WorkerEventLoopGroup` 来进行 `IO` 处理，如下图所示\n\n![](https://i.loli.net/2021/10/18/zoQgpkliDMshRN1.png)\n\n4. 常用方法\n    `public NioEventLoopGroup()`，构造方法\n    `public Future<?> shutdownGracefully()`，断开连接，关闭线程\n\n#### Unpooled \n\n1. `Netty` 提供一个专门用来操作缓冲区（即 `Netty` 的数据容器）的工具类\n2. 常用方法如下所示\n\n![](https://i.loli.net/2021/10/18/yQbHkAGRs7fqYX2.png)\n\n3.  `Unpooled` 获取 `Netty` 的数据容器 `ByteBuf` 的基本使用\n\n![](https://i.loli.net/2021/10/18/CpM4xhrFYE1IdVB.png)","source":"_posts/bio-nio-netty.md","raw":"---\ntitle: BIO NIO与Netty\nheader-img: /img/header_img/post-bg-desk.jpg\ncatalog: true\ntop: 1\ntags:\n  - IO\n  - netty\ncategories:\n  - work\nabbrlink: 5dae\ndate: 2021-8-25 00:00:00\nsubtitle:\n---\n# BIO、NIO与Netty\n\n\n\n> ### 网络编程：\n>\n> ​\t\t网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定的IP地址和监听端口），客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果连接建立成功，双方就可以通过网络套接字（Socket）进行通信。\n>\n> ### BIO:\n>\n> ​\t\t在1.4版本之前，Java IO类库是阻塞IO（Blocking IO），建立网络连接的时候采用BIO模式。\n>\n> ### NIO:\n>\n> ​\t\t为了支持非阻塞IO，Java引进了新的IO库，简称为JAVA NIO（Non-Blocking IO）。Java NIO属于 IO多路复用模型。\n>\n> ### Netty:\n>\n> ​\t\tNetty是一个异步的、[事件驱动](https://baike.baidu.com/item/事件驱动/9597519)的网络应用程序框架，基于NIO，使用Netty 可以快速开发出一个网络应用，例如实现了某种协议的客户、[服务端](https://baike.baidu.com/item/服务端/6492316)应用。\n\n\n\n## 1. Java BIO\n\n### 1.1 Java BIO模型\n\n- 同步阻塞IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，在高并发的应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。\n\n    ![bio-model](https://i.loli.net/2021/10/18/6jJxcVENwszR8Wd.png)\n\n### 1.2 Java BIO 工作流程\n\n1. 服务器端启动一个 `ServerSocket`，监听端口。\n2. 客户端启动 `Socket` 与服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯。\n3. 客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待或被拒绝，如果有响应，客户端线程会等待请求结束后继续执行。\n\n### 1.3 Java BIO代码示例([所有代码可前往github下载](https://github.com/VickyLuoLuo/netty.git))\n\n- 最简单的BIO服务器：\n\n```java\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class BioServer {\n\n    public static void main(String[] args) throws IOException {\n        // 创建ServerSocket\n        ServerSocket serverSocket = new ServerSocket(9090);\n        System.out.println(\"服务器启动\");\n        while (true) {\n            //监听，等待客户端连接\n            System.out.println(\"等待连接....\");\n            final Socket socket = serverSocket.accept(); // 阻塞\n            System.out.println(\"连接到一个客户端\");\n            byte[] bytes = new byte[1024];\n            socket.getInputStream().read(bytes); // 阻塞\n            System.out.println(\"收到客户端消息：\" + new String(bytes));\n        }\n    }\n}\n```\n\n- 我们可以对上述代码进行优化，将`socket.getInputStream().read(bytes)`消息处理部分改成线程池异步处理：\n\n```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class BioServer {\n\n    public static void main(String[] args) throws IOException {\n        // 创建ServerSocket\n        ServerSocket serverSocket = new ServerSocket(9090);\n        System.out.println(\"服务器启动\");\n        // 线程池机制,思路: 1. 创建一个线程池 2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)\n        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();\n        while (true) {\n            //监听，等待客户端连接\n            System.out.println(\"等待连接....\");\n            final Socket socket = serverSocket.accept(); // 阻塞\n            System.out.println(\"连接到一个客户端\");\n            newCachedThreadPool.execute(() -> {\n                // 通讯处理\n                handler(socket);\n            });\n        }\n    }\n\n    public static void handler(Socket socket) {\n        try {\n            byte[] bytes = new byte[1024];\n            //通过socket获取输入流\n            InputStream inputStream = socket.getInputStream();\n            //循环的读取客户端发送的数据\n            while (true) {\n                System.out.println(\"handler线程：id = \" + Thread.currentThread().getId() + \"等待接收消息\");\n                int read = inputStream.read(bytes); // 阻塞\n                if (read != -1) {\n                    System.out.println(\"handler线程：id = \" + Thread.currentThread().getId() + \"收到消息：\" + new String(bytes, 0, read));\n                } else {\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            System.out.println(\"handler线程：id = \" + Thread.currentThread().getId() + \"关闭连接\"); \n            try {\n                socket.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n​\t\t这样可以同时处理多个连接请求，但是由于`inputStream.read(bytes)`是阻塞的，当有多个连接请求时，每个连接占用一个线程，此时如果大部分连接都没有发送消息，线程就一直被占用，造成资源浪费。\n\n## 2. Java NIO\n\n### 2.1 Java NIO模型\n\n- 同步非阻塞IO，服务器实现模式为一个线程处理多个连接请求，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 `I/O` 请求就进行处理。\n\n    ![nio-model](https://i.loli.net/2021/10/18/ABy7qJoGhwaSzip.png)\n\n### 2.2 Java NIO的三大核心组件\n\n1. ####  通道（Channel）\n\n    在BIO中，同一个网络连接会通过输入流（Input Stream）和输出流（Output Stream）不断地进行输入和输出的操作。在NIO中，同一个网络连接使用一个通道表示，所有的NIO的IO操作都是从通道开始的。一个通道类似于BIO中的两个流的结合体，既可以从通道读取，也可以向通道写入。\n\n2. ####  选择器（Selector）\n\n    > IO多路复用指的是一个进程/线程可以同时监视多个文件描述符（一个网络连接，操作系统底层使用一个文件描述符来表示），一旦其中的一个或者多个文件描述符可读或者可写，系统内核就通知该进程/线程。\n\n    通过选择器，一个线程可以查询多个通道的IO事件的就绪状态，即监视多个文件描述符。具体的开发层面来说，首先把通道注册到选择器中，然后通过选择器内部的机制，可以查询（select）这些注册的通道是否有已经就绪的IO事件（例如可读、可写、网络连接完成等）。一个选择器只需要一个线程进行监控，系统不必为每一个网络连接（文件描述符）创建进程/线程，从而大大减小了系统的开销。\n\n3. #### 缓冲区（Buffer）\n\n    应用程序与通道（Channel）主要的交互操作，就是进行数据的read读取和write写入。通道的读取，就是将数据从通道读取到缓冲区中；通道的写入，就是将数据从缓冲区中写入到通道中。\n\n### 2.3 Selector、Channel 和 Buffer的 关系\n\n1. 每个 `Channel` 都会对应一个 `Buffer`。\n2. `Selector` 对应一个线程，一个线程对应多个 `Channel`（连接）。\n3. `Selector` 会根据不同的事件，在各个通道上切换。\n4. `Buffer` 就是一个内存块，底层是一个数组。\n5. 数据通过 `Buffer`进行读写，`BIO` 中要么是输入流，要么是输出流，不能双向，但是 `NIO` 的 `Buffer` 是可以读也可以写，需要 `flip` 方法切换 。`Channel` 是双向的，可以返回底层操作系统的情况，比如 `Linux`，底层的操作系统通道就是双向的。\n\n![nio-element](https://i.loli.net/2021/10/18/4F5pSqTYbayDgsJ.png)\n\n### 2.4 Java NIO 工作流程\n\n1. 服务器端启动一个 `ServerSocketChannel`，监听端口。---类似BIO中的ServerSocket。\n\n2. 客户端启动 `SocketChannel`与服务器进行通信。---类似BIO中的Socket。\n\n3. 获取`Selector`选择器，并将`ServerSocketChannel`注册到`Selector`上，接收新连接。注册后返回一个 `SelectionKey`（集合），会和该 `Selector` 关联。一个 `Selector` 上可以注册多个 `SocketChannel`。\n\n4. 当客户端连接时，服务端会通过 `ServerSocketChannel` 得到`SocketChannel`。\n\n5. `Selector` 进行监听 `select` 方法，返回有事件发生的通道的个数。\n\n6. 将 `socketChannel` 注册到 `Selector` 上，进一步得到各个 `SelectionKey`（有事件发生）。\n\n7. 在通过 `SelectionKey` 反向获取 `SocketChannel`。\n\n8. 可以通过得到的 `channel`，完成业务处理。\n\n    ![nio-workflow](https://i.loli.net/2021/10/18/ybcGt7zRT459L8Z.png)\n\n### 2.4 Java NIO 代码示例([所有代码可前往github下载](https://github.com/VickyLuoLuo/netty.git))\n\n- 简单的NIO服务器，使用一个集合`List<SocketChannel>`来存放所有从客户端接收到的`SocketChannel`，并一直轮询处理IO事件\n\n```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class NioServer {\n\n    static List<SocketChannel> channelList = new ArrayList<>();\n\n    public static void startServer() throws IOException {\n\n        // 获取通道\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        // 设置为非阻塞\n        serverSocketChannel.configureBlocking(false);\n        // 绑定连接\n        serverSocketChannel.bind(new InetSocketAddress(5252));\n        System.out.println(\"服务器启动成功\");\n\n        // 轮询感兴趣的IO就绪事件（选择键集合）\n        while (true) {\n\n            // 获取客户端连接\n            SocketChannel socketChannel = serverSocketChannel.accept(); // 非阻塞\n            if (null != socketChannel) {\n                System.out.println(\"连接成功\");\n                // 设置SocketChannel为非阻塞模式。NIO的非阻塞是由操作系统内部实现的，底层调用了系统内核的accept方法\n                socketChannel.configureBlocking(false);\n\n                channelList.add(socketChannel);\n            }\n            // 获取选择键集合\n            Iterator<SocketChannel> channels = channelList.iterator();\n            while (channels.hasNext()) {\n                // 获取单个的选择键并处理\n                SocketChannel channel = channels.next();\n                ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                // 调用通道的read方法，从通道读取数据写入缓冲区，并返回读取到的数据\n                int length = channel.read(byteBuffer); // 非阻塞\n                if (length > 0) {\n                    System.out.println(\"接收到消息：\" + new String(byteBuffer.array(), 0, length));\n                } else if (length == -1) {\n                    channels.remove();\n                    System.out.println(\"客户端断开连接\");\n                }\n\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        startServer();\n    }\n}\n```\n\n- 上述代码有个很严重的问题，由于关键的两个方法：接收连接`serverSocketChannel.accept()`和读取消息`channel.read(byteBuffer)`都是非阻塞的，`while(true)`就会无限循环直到内存溢出，`Selector`很好的解决了这个问题，`selector.select()`会阻塞，直到有事件发生：\n\n```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\n\npublic class NioSelectorServer {\n    public static void startServer() throws IOException {\n\n        // 获取通道\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        // 设置为非阻塞\n        serverSocketChannel.configureBlocking(false);\n        // 绑定连接\n        serverSocketChannel.bind(new InetSocketAddress(5656));\n        System.out.println(\"服务器启动成功\");\n\n        // 获取选择器\n        Selector selector = Selector.open(); // epoll\n        // 将通道注册的“接收新连接”IO事件注册到选择器上\n        SelectionKey selectionKey = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        // 轮询感兴趣的IO就绪事件（选择键集合）\n        while (selector.select() > 0) { // 阻塞 epoll-wait\n            // 获取选择键集合\n            Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();\n            while (selectedKeys.hasNext()) {\n                // 获取单个的选择键并处理\n                SelectionKey selectedKey = selectedKeys.next();\n                if (selectedKey.isAcceptable()) {\n                    // 若选择键的IO事件是“连接就绪”，就获取客户端连接\n                    SocketChannel socketChannel = serverSocketChannel.accept();\n                    // 切换为非阻塞模式\n                    socketChannel.configureBlocking(false);\n                    // 将新连接的通道可读事件注册到选择器上\n                    socketChannel.register(selector, SelectionKey.OP_READ);\n                    System.out.println(\"连接成功\");\n                } else if (selectedKey.isReadable()) {\n                    // 若选择键的IO事件是“可读”，就读取数据\n                    SocketChannel socketChannel = (SocketChannel) selectedKey.channel();\n                    // 读取数据，然后丢弃\n                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                    // 调用通道的read方法，从通道读取数据写入缓冲区，并返回读取到的数据\n                    int length = socketChannel.read(byteBuffer);\n                    if (length > 0) {\n                        System.out.println(\"接收到消息：\" + new String(byteBuffer.array(), 0, length));\n                    } else if (length == -1) {\n                        System.out.println(\"客户端断开连接\");\n                        socketChannel.close();\n                    }\n                }\n                // 移除选择键\n                selectedKeys.remove();\n            }\n        }\n        // 关闭连接\n        serverSocketChannel.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        startServer();\n    }\n}\n```\n\n### 2.5 多路复用器`Selector`\n\n​\t通过`Selector`，可以使用一个线程查询多个通道的IO事件的就绪状态，并在没有事件发生时阻塞。其原理依赖于`epoll`系统调用(Linux系统为例)，`epoll`系统调用的主要方法：\n\n1. epoll_create\n\n    创建一个epoll文件描述符。可简单理解为channel 集合。\n\n2. epoll_ctl\n\n    添加/修改/删除需要侦听的文件描述符及其事件。可简单理解为channel事件集合。\n\n3. epoll_wait\n\n    接收发生在被侦听的描述符上的，用户感兴趣的IO事件。可简单理解为 channel事件集合为空时阻塞。\n\n### 2.6 Java NIO 常用类及属性\n\n​\t\t参见另一篇博客：[Java NIO通信基础](https://vickyluoluo.github.io/2021/03/31/57bd.html)\n\n## 3. Netty\n\n### 3.1 原生NIO存在的问题\n\n1. `NIO` 的类库和 `API` 繁杂，使用麻烦：需要熟练掌握 `Selector`、`ServerSocketChannel`、`SocketChannel`、`ByteBuffer`等。\n2. 需要具备其他的额外技能：要熟悉 `Java` 多线程编程，因为 `NIO` 编程涉及到 `Reactor` 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 `NIO` 程序。\n3. 开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。\n4.  `JDK NIO` 的 `Bug`：例如臭名昭著的 `Epoll Bug`，它会导致 `Selector` 空轮询，最终导致 `CPU100%`。直到 `JDK1.7` 版本该问题仍旧存在，没有被根本解决\n\n### 3.2 Netty 的优点\n\n`Netty` 对 `JDK` 自带的 `NIO` 的 `API` 进行了封装，解决了上述问题。\n\n1. 设计优雅：适用于各种传输类型的统一 `API` 阻塞和非阻塞 `Socket`；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。\n2. 使用方便：详细记录的 `Javadoc`，用户指南和示例；没有其他依赖项，`JDK5（Netty3.x）`或 `6（Netty4.x）`就足够了。\n3. 高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。\n4. 安全：完整的 `SSL/TLS` 和 `StartTLS` 支持。\n5. 社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 `Bug` 可以被及时修复，同时，更多的新功能会被加入。\n\n### 3.3 Netty工作原理\n\n![](https://i.loli.net/2021/10/18/3cnCUJG4yerixqK.png)\n\n`Netty` 线程模型基于主从 `Reactors` 多线程模型，`BossGroup` 线程维护 `Selector`，只关注 `Accecpt` 当接收到 `Accept` 事件，获取到对应的 `SocketChannel`，封装成 `NIOScoketChannel` 并注册到 `Worker` 线程（事件循环），并进行维护当 `Worker` 线程监听到 `Selector` 中通道发生自己感兴趣的事件后，由 `handler`进行处理。\n\n![](https://i.loli.net/2021/10/18/chLyW8ko5aRuPqN.png)\n\n说明：\n\n1. `Netty` 抽象出两组线程池 `BossGroup` 专门负责接收客户端的连接，`WorkerGroup` 专门负责网络的读写\n2. `BossGroup` 和 `WorkerGroup` 类型都是 `NioEventLoopGroup` \n3. `NioEventLoopGroup` 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 `NioEventLoop` \n4. `NioEventLoop` 表示一个不断循环的执行处理任务的线程，每个 `NioEventLoop` 都有一个 `Selector`，用于监听绑定在其上的 `socket` 的网络通讯\n5. `NioEventLoopGroup` 可以有多个线程，即可以含有多个 `NioEventLoop` \n6. 每个 `BossNioEventLoop` 循环执行的步骤有 `3` 步\n    - 轮询 `accept` 事件\n    - 处理 `accept` 事件，与 `client` 建立连接，生成 `NioScocketChannel`，并将其注册到某个 `worker` `NIOEventLoop` 上的 `Selector`\n    - 处理任务队列的任务，即 `runAllTasks`\n7. 每个 `Worker` `NIOEventLoop` 循环执行的步骤\n    - 轮询 `read`，`write` 事件\n    - 处理 `I/O` 事件，即 `read`，`write` 事件，在对应 `NioScocketChannel` 处理\n    - 处理任务队列的任务，即 `runAllTasks`\n8. 每个 `Worker` `NIOEventLoop` 处理业务时，会使用 `pipeline`（管道），`pipeline` 中包含了 `channel`，即通过 `pipeline` 可以获取到对应通道，管道中维护了很多的处理器\n\n### 3.4 Netty 代码示例([所有代码可前往github下载](https://github.com/VickyLuoLuo/netty.git))\n\n- 简单的Netty服务器实现：\n    1. `NettyServer.java` 服务器启动类，通过链式编程配置启动参数并监听端口\n\n```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class NettyServer {\n\n    public static void main(String[] args) throws Exception {\n\n        //创建两个线程组bossGroup和workerGroup，默认子线程个数为cpu核数 * 2，bossGroup只处理连接请求,真正的客户端业务处理会交给workerGroup\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup(8);\n\n        try {\n            //创建服务器端的启动对象，配置参数\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            //使用链式编程来进行设置\n            bootstrap.group(bossGroup, workerGroup) //设置两个线程组\n                    .channel(NioServerSocketChannel.class) //使用NioSocketChannel 作为服务器的通道实现\n                    .option(ChannelOption.SO_BACKLOG, 128) // 初始化服务器接收连接的队列大小\n                    .childHandler(new ChannelInitializer<SocketChannel>() {//创建一个通道初始化对象(匿名对象)\n                        //给workGroup的SocketChannel设置处理器\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            System.out.println(\"客户socketchannel hashcode=\" + ch.hashCode()); //可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue\n                            ch.pipeline().addLast(new NettyServerHandler()); // 可添加多个\n                        }\n                    });\n\n            System.out.println(\".....服务器 is ready...\");\n\n            //启动服务器并绑定端口，bind是异步操作，可以通过isDone()等方法查看事件执行情况\n            ChannelFuture cf = bootstrap.bind(6668).sync();\n\n            //给cf 注册监听器，监控我们关心的事件\n            cf.addListener((ChannelFutureListener) future -> {\n                if (cf.isSuccess()) {\n                    System.out.println(\"监听端口成功\");\n                } else {\n                    System.out.println(\"监听端口失败\");\n                }\n            });\n\n            //对关闭通道进行监听\n            cf.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}\n```\n\n​\t\t\t2. `NettyServerHandler.java `自定义`ChannelHandler`处理业务，只需根据需要继承指定类型的抽象类，通过重载父类方法实现业务处理：\n\n```java\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.util.CharsetUtil;\n\npublic class NettyServerHandler extends ChannelInboundHandlerAdapter {\n\n    /**\n     * 当客户端连接服务器完成时触发\n     * @param ctx: 上下文对象, 含有 管道pipeline , 通道channel, 地址\n     */\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) {\n        System.out.println(\"客户端连接通道建立完成\");\n    }\n\n    /**\n     * 读取数据实际(这里我们可以读取客户端发送的消息)\n     * @param ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址\n     * @param msg: 就是客户端发送的数据 默认Object\n     */\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\n        Channel channel = ctx.channel();\n        //将 msg 转成一个 ByteBuf,ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.\n        ByteBuf buf = (ByteBuf) msg;\n        System.out.println(\"客户端发送消息是:\" + buf.toString(CharsetUtil.UTF_8));\n        System.out.println(\"客户端地址:\" + channel.remoteAddress());\n    }\n\n    /**\n     *  数据读取完毕\n     */\n    @Override\n    public void channelReadComplete(ChannelHandlerContext ctx) {\n        //将数据写入到缓存，并刷新\n        ctx.writeAndFlush(Unpooled.copiedBuffer(\"hello, 客户端\", CharsetUtil.UTF_8));\n    }\n\n    /**\n     * 处理异常, 一般关闭通道\n     * @param ctx\n     * @param cause\n     */\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n        ctx.close();\n    }\n}\n\n```\n\n- `SpringBoot` + `Netty`实现网络聊天室核心代码([完整代码可前往github下载](https://github.com/VickyLuoLuo/netty.git))：\n\n```java\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Component;\n\n@Component\n@Qualifier(\"somethingChannelInitializer\")\npublic class NettyWebSocketChannelInitializer extends ChannelInitializer<SocketChannel> {\n\n    @Autowired\n    private TextWebSocketFrameHandler textWebSocketFrameHandler;\n\n    @Override\n    public void initChannel(SocketChannel ch) throws Exception {//2\n        ChannelPipeline pipeline = ch.pipeline();\n\n        pipeline.addLast(new HttpServerCodec()); // http解编码器\n        pipeline.addLast(new HttpObjectAggregator(64*1024)); // 补充http解编码器\n        pipeline.addLast(new ChunkedWriteHandler()); // 保证队列中的每一个元素是一次性发送\n        pipeline.addLast(new WebSocketServerProtocolHandler(\"/ws\")); //\n        pipeline.addLast(textWebSocketFrameHandler); // 自定义ChannelHandler\n\n    }\n}\n```\n\n```java\nimport com.lhl.netty.chat.util.RandomName;\nimport com.lhl.netty.chat.util.RedisDao;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.handler.codec.http.websocketx.TextWebSocketFrame;\nimport io.netty.util.concurrent.GlobalEventExecutor;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Component;\n\n@Component\n@Qualifier(\"textWebSocketFrameHandler\")\n@ChannelHandler.Sharable\npublic class TextWebSocketFrameHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {\n\n    public static ChannelGroup channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n\n    @Autowired\n    private RedisDao redisDao;\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx,\n                                TextWebSocketFrame msg) throws Exception {\n        Channel incoming = ctx.channel();\n        String uName = redisDao.getString(incoming.id()+\"\");\n        for (Channel channel : channels) {\n            if (channel != incoming){\n                channel.writeAndFlush(new TextWebSocketFrame(\"[\" + uName + \"]\" + msg.text()));\n            } else {\n                channel.writeAndFlush(new TextWebSocketFrame(\"[我]\" + msg.text() ));\n            }\n        }\n    }\n\n    @Override\n    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n        System.out.println(ctx.channel().remoteAddress());\n        String uName = new RandomName().getRandomName();\n\n        Channel incoming = ctx.channel();\n        for (Channel channel : channels) {\n            channel.writeAndFlush(new TextWebSocketFrame(\"[新用户] - \" + uName + \" 加入群聊\"));\n        }\n        redisDao.saveString(incoming.id()+\"\",uName);\n        channels.add(ctx.channel());\n    }\n\n    @Override\n    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n        Channel incoming = ctx.channel();\n        String uName = redisDao.getString(String.valueOf(incoming.id()));\n        for (Channel channel : channels) {\n            channel.writeAndFlush(new TextWebSocketFrame(\"[用户] - \" + uName + \" 离开\"));\n        }\n        redisDao.deleteString(String.valueOf(incoming.id()));\n\n        channels.remove(ctx.channel());\n    }\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        Channel incoming = ctx.channel();\n        System.out.println(\"用户:\"+redisDao.getString(incoming.id()+\"\")+\"在线\");\n    }\n\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        Channel incoming = ctx.channel();\n        System.out.println(\"用户:\"+redisDao.getString(incoming.id()+\"\")+\"掉线\");\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)\n            throws Exception {\n        Channel incoming = ctx.channel();\n        System.out.println(\"用户:\"+redisDao.getString(incoming.id()+\"\")+\"异常\");\n        cause.printStackTrace();\n        ctx.close();\n    }\n\n}\n```\n\n### 3.5 Netty常用类及属性\n\n#### Bootstrap、ServerBootstrap\n\n1. `Bootstrap` 意思是引导，一个 `Netty` 应用通常由一个 `Bootstrap` 开始，主要作用是配置整个 `Netty` 程序，串联各个组件，`Netty` 中 `Bootstrap` 类是客户端程序的启动引导类，`ServerBootstrap` 是服务端启动引导类。\n2. 常见的方法有\n    - `public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)`，该方法用于服务器端，用来设置两个 `EventLoop`\n    - `public B group(EventLoopGroup group)`，该方法用于客户端，用来设置一个 `EventLoop`\n    - `public B channel(Class<? extends C> channelClass)`，该方法用来设置一个服务器端的通道实现\n    - `public <T> B option(ChannelOption<T> option, T value)`，用来给 `ServerChannel` 添加配置\n    - `public <T> ServerBootstrap childOption(ChannelOption<T> childOption, T value)`，用来给接收到的通道添加配置\n    - `public ServerBootstrap childHandler(ChannelHandler childHandler)`，该方法用来设置业务处理类（自定义的`handler`）\n    - `public ChannelFuture bind(int inetPort)`，该方法用于服务器端，用来设置占用的端口号\n    - `public ChannelFuture connect(String inetHost, int inetPort)`，该方法用于客户端，用来连接服务器端\n\n####  Future、ChannelFuture\n\n`Netty` 中所有的 `IO` 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 `Future` 和 `ChannelFutures`，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件\n\n常见的方法有\n\n- `Channel channel()`，返回当前正在进行 `IO` 操作的通道\n- `ChannelFuture sync()`，等待异步操作执行完毕\n\n#### Channel\n\n1. `Netty` 网络通信的组件，能够用于执行网络 `I/O` 操作。\n2. 通过 `Channel` 可获得当前网络连接的通道的状态\n3. 通过 `Channel` 可获得网络连接的配置参数（例如接收缓冲区大小）\n4. `Channel` 提供异步的网络 `I/O` 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 `I/O` 调用都将立即返回，并且不保证在调用结束时所请求的 `I/O` 操作已完成\n5. 调用立即返回一个 `ChannelFuture` 实例，通过注册监听器到 `ChannelFuture` 上，可以 `I/O` 操作成功、失败或取消时回调通知调用方\n6. 支持关联 `I/O` 操作与对应的处理程序\n7. 不同协议、不同的阻塞类型的连接都有不同的 `Channel` 类型与之对应，常用的 `Channel` 类型：\n    - `NioSocketChannel`，异步的客户端 `TCP` `Socket` 连接。\n    - `NioServerSocketChannel`，异步的服务器端 `TCP` `Socket` 连接。\n    - `NioDatagramChannel`，异步的 `UDP` 连接。\n    - `NioSctpChannel`，异步的客户端 `Sctp` 连接。\n    - `NioSctpServerChannel`，异步的 `Sctp` 服务器端连接，这些通道涵盖了 `UDP` 和 `TCP` 网络 `IO` 以及文件 `IO`。\n\n#### Selector\n\n1. `Netty` 基于 `Selector` 对象实现 `I/O` 多路复用，通过 `Selector` 一个线程可以监听多个连接的 `Channel` 事件。\n2. 当向一个 `Selector` 中注册 `Channel` 后，`Selector` 内部的机制就可以自动不断地查询（`Select`）这些注册的 `Channel` 是否有已就绪的 `I/O` 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 `Channel`\n\n#### ChannelHandler \n\n1. `ChannelHandler` 是一个接口，处理 `I/O` 事件或拦截 `I/O` 操作，并将其转发到其 `ChannelPipeline`（业务处理链）中的下一个处理程序。\n2. `ChannelHandler` 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类\n\n#### Pipeline 和 ChannelPipeline\n\n1. `ChannelPipeline` 是一个 `Handler` 的集合，它负责处理和拦截 `inbound` 或者 `outbound` 的事件和操作，相当于一个贯穿 `Netty` 的链。（也可以这样理解：`ChannelPipeline` 是保存 `ChannelHandler` 的 `List`，用于处理或拦截 `Channel` 的入站事件和出站操作）\n2. `ChannelPipeline` 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 `Channel` 中各个的 `ChannelHandler` 如何相互交互\n3. 在 `Netty` 中每个 `Channel` 都有且仅有一个 `ChannelPipeline` 与之对应，它们的组成关系如下\n\n![](https://i.loli.net/2021/10/18/oZARqLONHzbaGiP.png)\n\n​\t![](https://i.loli.net/2021/10/18/KeR8OM6uTVqhjFZ.png)\n\n4. 常用方法\n    `ChannelPipeline addFirst(ChannelHandler... handlers)`，把一个业务处理类（`handler`）添加到链中的第一个位置`ChannelPipeline addLast(ChannelHandler... handlers)`，把一个业务处理类（`handler`）添加到链中的最后一个位置\n\n#### ChannelHandlerContext\n\n1. 保存 `Channel` 相关的所有上下文信息，同时关联一个 `ChannelHandler` 对象\n2. 即 `ChannelHandlerContext` 中包含一个具体的事件处理器 `ChannelHandler`，同时 `ChannelHandlerContext` 中也绑定了对应的 `pipeline` 和 `Channel` 的信息，方便对 `ChannelHandler` 进行调用。\n3. 常用方法\n    - `ChannelFuture close()`，关闭通道\n    - `ChannelOutboundInvoker flush()`，刷新\n    - `ChannelFuture writeAndFlush(Object msg)`，将数据写到 \n    - `ChannelPipeline` 中当前 `ChannelHandler` 的下一个 `ChannelHandler` 开始处理（出站）\n\n![](https://i.loli.net/2021/10/18/qRSk7ezATLQtKV5.png)\n\n#### ChannelOption\n\n1. `Netty` 在创建 `Channel` 实例后，一般都需要设置 `ChannelOption` 参数。\n2. `ChannelOption` 参数如下：\n\n![](https://i.loli.net/2021/10/18/Z6pAFyCjhOU5dvg.png)\n\n#### EventLoopGroup\n\n1. `EventLoopGroup` 是一组 `EventLoop` 的抽象，`Netty` 为了更好的利用多核 `CPU` 资源，一般会有多个 `EventLoop` 同时工作，每个 `EventLoop` 维护着一个 `Selector` 实例。\n2. `EventLoopGroup` 提供 `next` 接口，可以从组里面按照一定规则获取其中一个 `EventLoop` 来处理任务。在 `Netty` 服务器端编程中，我们一般都需要提供两个 `EventLoopGroup`，例如：`BossEventLoopGroup` 和 `WorkerEventLoopGroup`。\n3. 通常一个服务端口即一个 `ServerSocketChannel` 对应一个 `Selector` 和一个 `EventLoop` 线程。`BossEventLoop` 负责接收客户端的连接并将 `SocketChannel` 交给 `WorkerEventLoopGroup` 来进行 `IO` 处理，如下图所示\n\n![](https://i.loli.net/2021/10/18/zoQgpkliDMshRN1.png)\n\n4. 常用方法\n    `public NioEventLoopGroup()`，构造方法\n    `public Future<?> shutdownGracefully()`，断开连接，关闭线程\n\n#### Unpooled \n\n1. `Netty` 提供一个专门用来操作缓冲区（即 `Netty` 的数据容器）的工具类\n2. 常用方法如下所示\n\n![](https://i.loli.net/2021/10/18/yQbHkAGRs7fqYX2.png)\n\n3.  `Unpooled` 获取 `Netty` 的数据容器 `ByteBuf` 的基本使用\n\n![](https://i.loli.net/2021/10/18/CpM4xhrFYE1IdVB.png)","slug":"bio-nio-netty","published":1,"updated":"2021-12-10T09:30:44.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx07v1cs002facbfaswrccqv","content":"<h1 id=\"BIO、NIO与Netty\"><a href=\"#BIO、NIO与Netty\" class=\"headerlink\" title=\"BIO、NIO与Netty\"></a>BIO、NIO与Netty</h1><blockquote>\n<h3 id=\"网络编程：\"><a href=\"#网络编程：\" class=\"headerlink\" title=\"网络编程：\"></a>网络编程：</h3><p>​        网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定的IP地址和监听端口），客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果连接建立成功，双方就可以通过网络套接字（Socket）进行通信。</p>\n<h3 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO:\"></a>BIO:</h3><p>​        在1.4版本之前，Java IO类库是阻塞IO（Blocking IO），建立网络连接的时候采用BIO模式。</p>\n<h3 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO:\"></a>NIO:</h3><p>​        为了支持非阻塞IO，Java引进了新的IO库，简称为JAVA NIO（Non-Blocking IO）。Java NIO属于 IO多路复用模型。</p>\n<h3 id=\"Netty\"><a href=\"#Netty\" class=\"headerlink\" title=\"Netty:\"></a>Netty:</h3><p>​        Netty是一个异步的、<a href=\"https://baike.baidu.com/item/事件驱动/9597519\" target=\"_blank\" rel=\"noopener\">事件驱动</a>的网络应用程序框架，基于NIO，使用Netty 可以快速开发出一个网络应用，例如实现了某种协议的客户、<a href=\"https://baike.baidu.com/item/服务端/6492316\" target=\"_blank\" rel=\"noopener\">服务端</a>应用。</p>\n</blockquote>\n<h2 id=\"1-Java-BIO\"><a href=\"#1-Java-BIO\" class=\"headerlink\" title=\"1. Java BIO\"></a>1. Java BIO</h2><h3 id=\"1-1-Java-BIO模型\"><a href=\"#1-1-Java-BIO模型\" class=\"headerlink\" title=\"1.1 Java BIO模型\"></a>1.1 Java BIO模型</h3><ul>\n<li><p>同步阻塞IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，在高并发的应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。</p>\n<p>  <img src=\"https://i.loli.net/2021/10/18/6jJxcVENwszR8Wd.png\" alt=\"bio-model\"></p>\n</li>\n</ul>\n<h3 id=\"1-2-Java-BIO-工作流程\"><a href=\"#1-2-Java-BIO-工作流程\" class=\"headerlink\" title=\"1.2 Java BIO 工作流程\"></a>1.2 Java BIO 工作流程</h3><ol>\n<li>服务器端启动一个 <code>ServerSocket</code>，监听端口。</li>\n<li>客户端启动 <code>Socket</code> 与服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯。</li>\n<li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待或被拒绝，如果有响应，客户端线程会等待请求结束后继续执行。</li>\n</ol>\n<h3 id=\"1-3-Java-BIO代码示例-所有代码可前往github下载\"><a href=\"#1-3-Java-BIO代码示例-所有代码可前往github下载\" class=\"headerlink\" title=\"1.3 Java BIO代码示例(所有代码可前往github下载)\"></a>1.3 Java BIO代码示例(<a href=\"https://github.com/VickyLuoLuo/netty.git\" target=\"_blank\" rel=\"noopener\">所有代码可前往github下载</a>)</h3><ul>\n<li>最简单的BIO服务器：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.ServerSocket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.Socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BioServer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建ServerSocket</span></span><br><span class=\"line\">        ServerSocket serverSocket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">9090</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"服务器启动\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//监听，等待客户端连接</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"等待连接....\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Socket socket = serverSocket.accept(); <span class=\"comment\">// 阻塞</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"连接到一个客户端\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">            socket.getInputStream().read(bytes); <span class=\"comment\">// 阻塞</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"收到客户端消息：\"</span> + <span class=\"keyword\">new</span> String(bytes));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们可以对上述代码进行优化，将<code>socket.getInputStream().read(bytes)</code>消息处理部分改成线程池异步处理：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.ServerSocket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.Socket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BioServer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建ServerSocket</span></span><br><span class=\"line\">        ServerSocket serverSocket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">9090</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"服务器启动\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 线程池机制,思路: 1. 创建一个线程池 2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class=\"line\">        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//监听，等待客户端连接</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"等待连接....\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Socket socket = serverSocket.accept(); <span class=\"comment\">// 阻塞</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"连接到一个客户端\"</span>);</span><br><span class=\"line\">            newCachedThreadPool.execute(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 通讯处理</span></span><br><span class=\"line\">                handler(socket);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handler</span><span class=\"params\">(Socket socket)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">            <span class=\"comment\">//通过socket获取输入流</span></span><br><span class=\"line\">            InputStream inputStream = socket.getInputStream();</span><br><span class=\"line\">            <span class=\"comment\">//循环的读取客户端发送的数据</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"handler线程：id = \"</span> + Thread.currentThread().getId() + <span class=\"string\">\"等待接收消息\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> read = inputStream.read(bytes); <span class=\"comment\">// 阻塞</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (read != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"handler线程：id = \"</span> + Thread.currentThread().getId() + <span class=\"string\">\"收到消息：\"</span> + <span class=\"keyword\">new</span> String(bytes, <span class=\"number\">0</span>, read));</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"handler线程：id = \"</span> + Thread.currentThread().getId() + <span class=\"string\">\"关闭连接\"</span>); </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                socket.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        这样可以同时处理多个连接请求，但是由于<code>inputStream.read(bytes)</code>是阻塞的，当有多个连接请求时，每个连接占用一个线程，此时如果大部分连接都没有发送消息，线程就一直被占用，造成资源浪费。</p>\n<h2 id=\"2-Java-NIO\"><a href=\"#2-Java-NIO\" class=\"headerlink\" title=\"2. Java NIO\"></a>2. Java NIO</h2><h3 id=\"2-1-Java-NIO模型\"><a href=\"#2-1-Java-NIO模型\" class=\"headerlink\" title=\"2.1 Java NIO模型\"></a>2.1 Java NIO模型</h3><ul>\n<li><p>同步非阻塞IO，服务器实现模式为一个线程处理多个连接请求，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <code>I/O</code> 请求就进行处理。</p>\n<p>  <img src=\"https://i.loli.net/2021/10/18/ABy7qJoGhwaSzip.png\" alt=\"nio-model\"></p>\n</li>\n</ul>\n<h3 id=\"2-2-Java-NIO的三大核心组件\"><a href=\"#2-2-Java-NIO的三大核心组件\" class=\"headerlink\" title=\"2.2 Java NIO的三大核心组件\"></a>2.2 Java NIO的三大核心组件</h3><ol>\n<li><h4 id=\"通道（Channel）\"><a href=\"#通道（Channel）\" class=\"headerlink\" title=\"通道（Channel）\"></a>通道（Channel）</h4><p> 在BIO中，同一个网络连接会通过输入流（Input Stream）和输出流（Output Stream）不断地进行输入和输出的操作。在NIO中，同一个网络连接使用一个通道表示，所有的NIO的IO操作都是从通道开始的。一个通道类似于BIO中的两个流的结合体，既可以从通道读取，也可以向通道写入。</p>\n</li>\n<li><h4 id=\"选择器（Selector）\"><a href=\"#选择器（Selector）\" class=\"headerlink\" title=\"选择器（Selector）\"></a>选择器（Selector）</h4><blockquote>\n<p>IO多路复用指的是一个进程/线程可以同时监视多个文件描述符（一个网络连接，操作系统底层使用一个文件描述符来表示），一旦其中的一个或者多个文件描述符可读或者可写，系统内核就通知该进程/线程。</p>\n</blockquote>\n<p> 通过选择器，一个线程可以查询多个通道的IO事件的就绪状态，即监视多个文件描述符。具体的开发层面来说，首先把通道注册到选择器中，然后通过选择器内部的机制，可以查询（select）这些注册的通道是否有已经就绪的IO事件（例如可读、可写、网络连接完成等）。一个选择器只需要一个线程进行监控，系统不必为每一个网络连接（文件描述符）创建进程/线程，从而大大减小了系统的开销。</p>\n</li>\n<li><h4 id=\"缓冲区（Buffer）\"><a href=\"#缓冲区（Buffer）\" class=\"headerlink\" title=\"缓冲区（Buffer）\"></a>缓冲区（Buffer）</h4><p> 应用程序与通道（Channel）主要的交互操作，就是进行数据的read读取和write写入。通道的读取，就是将数据从通道读取到缓冲区中；通道的写入，就是将数据从缓冲区中写入到通道中。</p>\n</li>\n</ol>\n<h3 id=\"2-3-Selector、Channel-和-Buffer的-关系\"><a href=\"#2-3-Selector、Channel-和-Buffer的-关系\" class=\"headerlink\" title=\"2.3 Selector、Channel 和 Buffer的 关系\"></a>2.3 Selector、Channel 和 Buffer的 关系</h3><ol>\n<li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li>\n<li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li>\n<li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li>\n<li><code>Buffer</code> 就是一个内存块，底层是一个数组。</li>\n<li>数据通过 <code>Buffer</code>进行读写，<code>BIO</code> 中要么是输入流，要么是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换 。<code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/10/18/4F5pSqTYbayDgsJ.png\" alt=\"nio-element\"></p>\n<h3 id=\"2-4-Java-NIO-工作流程\"><a href=\"#2-4-Java-NIO-工作流程\" class=\"headerlink\" title=\"2.4 Java NIO 工作流程\"></a>2.4 Java NIO 工作流程</h3><ol>\n<li><p>服务器端启动一个 <code>ServerSocketChannel</code>，监听端口。—类似BIO中的ServerSocket。</p>\n</li>\n<li><p>客户端启动 <code>SocketChannel</code>与服务器进行通信。—类似BIO中的Socket。</p>\n</li>\n<li><p>获取<code>Selector</code>选择器，并将<code>ServerSocketChannel</code>注册到<code>Selector</code>上，接收新连接。注册后返回一个 <code>SelectionKey</code>（集合），会和该 <code>Selector</code> 关联。一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</p>\n</li>\n<li><p>当客户端连接时，服务端会通过 <code>ServerSocketChannel</code> 得到<code>SocketChannel</code>。</p>\n</li>\n<li><p><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</p>\n</li>\n<li><p>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，进一步得到各个 <code>SelectionKey</code>（有事件发生）。</p>\n</li>\n<li><p>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>。</p>\n</li>\n<li><p>可以通过得到的 <code>channel</code>，完成业务处理。</p>\n<p> <img src=\"https://i.loli.net/2021/10/18/ybcGt7zRT459L8Z.png\" alt=\"nio-workflow\"></p>\n</li>\n</ol>\n<h3 id=\"2-4-Java-NIO-代码示例-所有代码可前往github下载\"><a href=\"#2-4-Java-NIO-代码示例-所有代码可前往github下载\" class=\"headerlink\" title=\"2.4 Java NIO 代码示例(所有代码可前往github下载)\"></a>2.4 Java NIO 代码示例(<a href=\"https://github.com/VickyLuoLuo/netty.git\" target=\"_blank\" rel=\"noopener\">所有代码可前往github下载</a>)</h3><ul>\n<li>简单的NIO服务器，使用一个集合<code>List&lt;SocketChannel&gt;</code>来存放所有从客户端接收到的<code>SocketChannel</code>，并一直轮询处理IO事件</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.InetSocketAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.ByteBuffer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioServer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> List&lt;SocketChannel&gt; channelList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startServer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\">        <span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">        serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 绑定连接</span></span><br><span class=\"line\">        serverSocketChannel.bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">5252</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"服务器启动成功\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 轮询感兴趣的IO就绪事件（选择键集合）</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 获取客户端连接</span></span><br><span class=\"line\">            SocketChannel socketChannel = serverSocketChannel.accept(); <span class=\"comment\">// 非阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != socketChannel) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"连接成功\"</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 设置SocketChannel为非阻塞模式。NIO的非阻塞是由操作系统内部实现的，底层调用了系统内核的accept方法</span></span><br><span class=\"line\">                socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                channelList.add(socketChannel);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 获取选择键集合</span></span><br><span class=\"line\">            Iterator&lt;SocketChannel&gt; channels = channelList.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (channels.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取单个的选择键并处理</span></span><br><span class=\"line\">                SocketChannel channel = channels.next();</span><br><span class=\"line\">                ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 调用通道的read方法，从通道读取数据写入缓冲区，并返回读取到的数据</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> length = channel.read(byteBuffer); <span class=\"comment\">// 非阻塞</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"接收到消息：\"</span> + <span class=\"keyword\">new</span> String(byteBuffer.array(), <span class=\"number\">0</span>, length));</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (length == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    channels.remove();</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"客户端断开连接\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        startServer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>上述代码有个很严重的问题，由于关键的两个方法：接收连接<code>serverSocketChannel.accept()</code>和读取消息<code>channel.read(byteBuffer)</code>都是非阻塞的，<code>while(true)</code>就会无限循环直到内存溢出，<code>Selector</code>很好的解决了这个问题，<code>selector.select()</code>会阻塞，直到有事件发生：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.InetSocketAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.ByteBuffer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SelectionKey;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.Selector;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioSelectorServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startServer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\">        <span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">        serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 绑定连接</span></span><br><span class=\"line\">        serverSocketChannel.bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">5656</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"服务器启动成功\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取选择器</span></span><br><span class=\"line\">        Selector selector = Selector.open(); <span class=\"comment\">// epoll</span></span><br><span class=\"line\">        <span class=\"comment\">// 将通道注册的“接收新连接”IO事件注册到选择器上</span></span><br><span class=\"line\">        SelectionKey selectionKey = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 轮询感兴趣的IO就绪事件（选择键集合）</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (selector.select() &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 阻塞 epoll-wait</span></span><br><span class=\"line\">            <span class=\"comment\">// 获取选择键集合</span></span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (selectedKeys.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取单个的选择键并处理</span></span><br><span class=\"line\">                SelectionKey selectedKey = selectedKeys.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (selectedKey.isAcceptable()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 若选择键的IO事件是“连接就绪”，就获取客户端连接</span></span><br><span class=\"line\">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class=\"line\">                    <span class=\"comment\">// 切换为非阻塞模式</span></span><br><span class=\"line\">                    socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 将新连接的通道可读事件注册到选择器上</span></span><br><span class=\"line\">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"连接成功\"</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isReadable()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 若选择键的IO事件是“可读”，就读取数据</span></span><br><span class=\"line\">                    SocketChannel socketChannel = (SocketChannel) selectedKey.channel();</span><br><span class=\"line\">                    <span class=\"comment\">// 读取数据，然后丢弃</span></span><br><span class=\"line\">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 调用通道的read方法，从通道读取数据写入缓冲区，并返回读取到的数据</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> length = socketChannel.read(byteBuffer);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"接收到消息：\"</span> + <span class=\"keyword\">new</span> String(byteBuffer.array(), <span class=\"number\">0</span>, length));</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (length == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"客户端断开连接\"</span>);</span><br><span class=\"line\">                        socketChannel.close();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 移除选择键</span></span><br><span class=\"line\">                selectedKeys.remove();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\">        serverSocketChannel.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        startServer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-多路复用器Selector\"><a href=\"#2-5-多路复用器Selector\" class=\"headerlink\" title=\"2.5 多路复用器Selector\"></a>2.5 多路复用器<code>Selector</code></h3><p>​    通过<code>Selector</code>，可以使用一个线程查询多个通道的IO事件的就绪状态，并在没有事件发生时阻塞。其原理依赖于<code>epoll</code>系统调用(Linux系统为例)，<code>epoll</code>系统调用的主要方法：</p>\n<ol>\n<li><p>epoll_create</p>\n<p> 创建一个epoll文件描述符。可简单理解为channel 集合。</p>\n</li>\n<li><p>epoll_ctl</p>\n<p> 添加/修改/删除需要侦听的文件描述符及其事件。可简单理解为channel事件集合。</p>\n</li>\n<li><p>epoll_wait</p>\n<p> 接收发生在被侦听的描述符上的，用户感兴趣的IO事件。可简单理解为 channel事件集合为空时阻塞。</p>\n</li>\n</ol>\n<h3 id=\"2-6-Java-NIO-常用类及属性\"><a href=\"#2-6-Java-NIO-常用类及属性\" class=\"headerlink\" title=\"2.6 Java NIO 常用类及属性\"></a>2.6 Java NIO 常用类及属性</h3><p>​        参见另一篇博客：<a href=\"https://vickyluoluo.github.io/2021/03/31/57bd.html\">Java NIO通信基础</a></p>\n<h2 id=\"3-Netty\"><a href=\"#3-Netty\" class=\"headerlink\" title=\"3. Netty\"></a>3. Netty</h2><h3 id=\"3-1-原生NIO存在的问题\"><a href=\"#3-1-原生NIO存在的问题\" class=\"headerlink\" title=\"3.1 原生NIO存在的问题\"></a>3.1 原生NIO存在的问题</h3><ol>\n<li><code>NIO</code> 的类库和 <code>API</code> 繁杂，使用麻烦：需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code>等。</li>\n<li>需要具备其他的额外技能：要熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 <code>NIO</code> 程序。</li>\n<li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。</li>\n<li><code>JDK NIO</code> 的 <code>Bug</code>：例如臭名昭著的 <code>Epoll Bug</code>，它会导致 <code>Selector</code> 空轮询，最终导致 <code>CPU100%</code>。直到 <code>JDK1.7</code> 版本该问题仍旧存在，没有被根本解决</li>\n</ol>\n<h3 id=\"3-2-Netty-的优点\"><a href=\"#3-2-Netty-的优点\" class=\"headerlink\" title=\"3.2 Netty 的优点\"></a>3.2 Netty 的优点</h3><p><code>Netty</code> 对 <code>JDK</code> 自带的 <code>NIO</code> 的 <code>API</code> 进行了封装，解决了上述问题。</p>\n<ol>\n<li>设计优雅：适用于各种传输类型的统一 <code>API</code> 阻塞和非阻塞 <code>Socket</code>；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。</li>\n<li>使用方便：详细记录的 <code>Javadoc</code>，用户指南和示例；没有其他依赖项，<code>JDK5（Netty3.x）</code>或 <code>6（Netty4.x）</code>就足够了。</li>\n<li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li>\n<li>安全：完整的 <code>SSL/TLS</code> 和 <code>StartTLS</code> 支持。</li>\n<li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 <code>Bug</code> 可以被及时修复，同时，更多的新功能会被加入。</li>\n</ol>\n<h3 id=\"3-3-Netty工作原理\"><a href=\"#3-3-Netty工作原理\" class=\"headerlink\" title=\"3.3 Netty工作原理\"></a>3.3 Netty工作原理</h3><p><img src=\"https://i.loli.net/2021/10/18/3cnCUJG4yerixqK.png\" alt=\"\"></p>\n<p><code>Netty</code> 线程模型基于主从 <code>Reactors</code> 多线程模型，<code>BossGroup</code> 线程维护 <code>Selector</code>，只关注 <code>Accecpt</code> 当接收到 <code>Accept</code> 事件，获取到对应的 <code>SocketChannel</code>，封装成 <code>NIOScoketChannel</code> 并注册到 <code>Worker</code> 线程（事件循环），并进行维护当 <code>Worker</code> 线程监听到 <code>Selector</code> 中通道发生自己感兴趣的事件后，由 <code>handler</code>进行处理。</p>\n<p><img src=\"https://i.loli.net/2021/10/18/chLyW8ko5aRuPqN.png\" alt=\"\"></p>\n<p>说明：</p>\n<ol>\n<li><code>Netty</code> 抽象出两组线程池 <code>BossGroup</code> 专门负责接收客户端的连接，<code>WorkerGroup</code> 专门负责网络的读写</li>\n<li><code>BossGroup</code> 和 <code>WorkerGroup</code> 类型都是 <code>NioEventLoopGroup</code> </li>\n<li><code>NioEventLoopGroup</code> 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 <code>NioEventLoop</code> </li>\n<li><code>NioEventLoop</code> 表示一个不断循环的执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code> 的网络通讯</li>\n<li><code>NioEventLoopGroup</code> 可以有多个线程，即可以含有多个 <code>NioEventLoop</code> </li>\n<li>每个 <code>BossNioEventLoop</code> 循环执行的步骤有 <code>3</code> 步<ul>\n<li>轮询 <code>accept</code> 事件</li>\n<li>处理 <code>accept</code> 事件，与 <code>client</code> 建立连接，生成 <code>NioScocketChannel</code>，并将其注册到某个 <code>worker</code> <code>NIOEventLoop</code> 上的 <code>Selector</code></li>\n<li>处理任务队列的任务，即 <code>runAllTasks</code></li>\n</ul>\n</li>\n<li>每个 <code>Worker</code> <code>NIOEventLoop</code> 循环执行的步骤<ul>\n<li>轮询 <code>read</code>，<code>write</code> 事件</li>\n<li>处理 <code>I/O</code> 事件，即 <code>read</code>，<code>write</code> 事件，在对应 <code>NioScocketChannel</code> 处理</li>\n<li>处理任务队列的任务，即 <code>runAllTasks</code></li>\n</ul>\n</li>\n<li>每个 <code>Worker</code> <code>NIOEventLoop</code> 处理业务时，会使用 <code>pipeline</code>（管道），<code>pipeline</code> 中包含了 <code>channel</code>，即通过 <code>pipeline</code> 可以获取到对应通道，管道中维护了很多的处理器</li>\n</ol>\n<h3 id=\"3-4-Netty-代码示例-所有代码可前往github下载\"><a href=\"#3-4-Netty-代码示例-所有代码可前往github下载\" class=\"headerlink\" title=\"3.4 Netty 代码示例(所有代码可前往github下载)\"></a>3.4 Netty 代码示例(<a href=\"https://github.com/VickyLuoLuo/netty.git\" target=\"_blank\" rel=\"noopener\">所有代码可前往github下载</a>)</h3><ul>\n<li>简单的Netty服务器实现：<ol>\n<li><code>NettyServer.java</code> 服务器启动类，通过链式编程配置启动参数并监听端口</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyServer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建两个线程组bossGroup和workerGroup，默认子线程个数为cpu核数 * 2，bossGroup只处理连接请求,真正的客户端业务处理会交给workerGroup</span></span><br><span class=\"line\">        EventLoopGroup bossGroup = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">1</span>);</span><br><span class=\"line\">        EventLoopGroup workerGroup = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建服务器端的启动对象，配置参数</span></span><br><span class=\"line\">            ServerBootstrap bootstrap = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\">            <span class=\"comment\">//使用链式编程来进行设置</span></span><br><span class=\"line\">            bootstrap.group(bossGroup, workerGroup) <span class=\"comment\">//设置两个线程组</span></span><br><span class=\"line\">                    .channel(NioServerSocketChannel<span class=\"class\">.<span class=\"keyword\">class</span>) //使用<span class=\"title\">NioSocketChannel</span> 作为服务器的通道实现</span></span><br><span class=\"line\"><span class=\"class\">                    .<span class=\"title\">option</span>(<span class=\"title\">ChannelOption</span>.<span class=\"title\">SO_BACKLOG</span>, 128) // 初始化服务器接收连接的队列大小</span></span><br><span class=\"line\"><span class=\"class\">                    .<span class=\"title\">childHandler</span>(<span class=\"title\">new</span> <span class=\"title\">ChannelInitializer</span>&lt;<span class=\"title\">SocketChannel</span>&gt;() </span>&#123;<span class=\"comment\">//创建一个通道初始化对象(匿名对象)</span></span><br><span class=\"line\">                        <span class=\"comment\">//给workGroup的SocketChannel设置处理器</span></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> </span>&#123;</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">\"客户socketchannel hashcode=\"</span> + ch.hashCode()); <span class=\"comment\">//可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue</span></span><br><span class=\"line\">                            ch.pipeline().addLast(<span class=\"keyword\">new</span> NettyServerHandler()); <span class=\"comment\">// 可添加多个</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\".....服务器 is ready...\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//启动服务器并绑定端口，bind是异步操作，可以通过isDone()等方法查看事件执行情况</span></span><br><span class=\"line\">            ChannelFuture cf = bootstrap.bind(<span class=\"number\">6668</span>).sync();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//给cf 注册监听器，监控我们关心的事件</span></span><br><span class=\"line\">            cf.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cf.isSuccess()) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"监听端口成功\"</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"监听端口失败\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//对关闭通道进行监听</span></span><br><span class=\"line\">            cf.channel().closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            bossGroup.shutdownGracefully();</span><br><span class=\"line\">            workerGroup.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​            2. <code>NettyServerHandler.java</code>自定义<code>ChannelHandler</code>处理业务，只需根据需要继承指定类型的抽象类，通过重载父类方法实现业务处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> io.netty.buffer.ByteBuf;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.buffer.Unpooled;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.util.CharsetUtil;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyServerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当客户端连接服务器完成时触发</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ctx: 上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端连接通道建立完成\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 读取数据实际(这里我们可以读取客户端发送的消息)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> msg: 就是客户端发送的数据 默认Object</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Channel channel = ctx.channel();</span><br><span class=\"line\">        <span class=\"comment\">//将 msg 转成一个 ByteBuf,ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span></span><br><span class=\"line\">        ByteBuf buf = (ByteBuf) msg;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端发送消息是:\"</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端地址:\"</span> + channel.remoteAddress());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  数据读取完毕</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelReadComplete</span><span class=\"params\">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//将数据写入到缓存，并刷新</span></span><br><span class=\"line\">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class=\"string\">\"hello, 客户端\"</span>, CharsetUtil.UTF_8));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 处理异常, 一般关闭通道</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ctx</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> cause</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">        ctx.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>SpringBoot</code> + <code>Netty</code>实现网络聊天室核心代码(<a href=\"https://github.com/VickyLuoLuo/netty.git\" target=\"_blank\" rel=\"noopener\">完整代码可前往github下载</a>)：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelInitializer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelPipeline;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.stream.ChunkedWriteHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"somethingChannelInitializer\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyWebSocketChannelInitializer</span> <span class=\"keyword\">extends</span> <span class=\"title\">ChannelInitializer</span>&lt;<span class=\"title\">SocketChannel</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextWebSocketFrameHandler textWebSocketFrameHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;<span class=\"comment\">//2</span></span><br><span class=\"line\">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class=\"line\"></span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> HttpServerCodec()); <span class=\"comment\">// http解编码器</span></span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> HttpObjectAggregator(<span class=\"number\">64</span>*<span class=\"number\">1024</span>)); <span class=\"comment\">// 补充http解编码器</span></span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> ChunkedWriteHandler()); <span class=\"comment\">// 保证队列中的每一个元素是一次性发送</span></span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> WebSocketServerProtocolHandler(<span class=\"string\">\"/ws\"</span>)); <span class=\"comment\">//</span></span><br><span class=\"line\">        pipeline.addLast(textWebSocketFrameHandler); <span class=\"comment\">// 自定义ChannelHandler</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.lhl.netty.chat.util.RandomName;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.lhl.netty.chat.util.RedisDao;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.http.websocketx.TextWebSocketFrame;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"textWebSocketFrameHandler\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextWebSocketFrameHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleChannelInboundHandler</span>&lt;<span class=\"title\">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ChannelGroup channels = <span class=\"keyword\">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisDao redisDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                TextWebSocketFrame msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel incoming = ctx.channel();</span><br><span class=\"line\">        String uName = redisDao.getString(incoming.id()+<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Channel channel : channels) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (channel != incoming)&#123;</span><br><span class=\"line\">                channel.writeAndFlush(<span class=\"keyword\">new</span> TextWebSocketFrame(<span class=\"string\">\"[\"</span> + uName + <span class=\"string\">\"]\"</span> + msg.text()));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                channel.writeAndFlush(<span class=\"keyword\">new</span> TextWebSocketFrame(<span class=\"string\">\"[我]\"</span> + msg.text() ));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handlerAdded</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(ctx.channel().remoteAddress());</span><br><span class=\"line\">        String uName = <span class=\"keyword\">new</span> RandomName().getRandomName();</span><br><span class=\"line\"></span><br><span class=\"line\">        Channel incoming = ctx.channel();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Channel channel : channels) &#123;</span><br><span class=\"line\">            channel.writeAndFlush(<span class=\"keyword\">new</span> TextWebSocketFrame(<span class=\"string\">\"[新用户] - \"</span> + uName + <span class=\"string\">\" 加入群聊\"</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        redisDao.saveString(incoming.id()+<span class=\"string\">\"\"</span>,uName);</span><br><span class=\"line\">        channels.add(ctx.channel());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handlerRemoved</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel incoming = ctx.channel();</span><br><span class=\"line\">        String uName = redisDao.getString(String.valueOf(incoming.id()));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Channel channel : channels) &#123;</span><br><span class=\"line\">            channel.writeAndFlush(<span class=\"keyword\">new</span> TextWebSocketFrame(<span class=\"string\">\"[用户] - \"</span> + uName + <span class=\"string\">\" 离开\"</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        redisDao.deleteString(String.valueOf(incoming.id()));</span><br><span class=\"line\"></span><br><span class=\"line\">        channels.remove(ctx.channel());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel incoming = ctx.channel();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"用户:\"</span>+redisDao.getString(incoming.id()+<span class=\"string\">\"\"</span>)+<span class=\"string\">\"在线\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelInactive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel incoming = ctx.channel();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"用户:\"</span>+redisDao.getString(incoming.id()+<span class=\"string\">\"\"</span>)+<span class=\"string\">\"掉线\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel incoming = ctx.channel();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"用户:\"</span>+redisDao.getString(incoming.id()+<span class=\"string\">\"\"</span>)+<span class=\"string\">\"异常\"</span>);</span><br><span class=\"line\">        cause.printStackTrace();</span><br><span class=\"line\">        ctx.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-Netty常用类及属性\"><a href=\"#3-5-Netty常用类及属性\" class=\"headerlink\" title=\"3.5 Netty常用类及属性\"></a>3.5 Netty常用类及属性</h3><h4 id=\"Bootstrap、ServerBootstrap\"><a href=\"#Bootstrap、ServerBootstrap\" class=\"headerlink\" title=\"Bootstrap、ServerBootstrap\"></a>Bootstrap、ServerBootstrap</h4><ol>\n<li><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类。</li>\n<li>常见的方法有<ul>\n<li><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>，该方法用于服务器端，用来设置两个 <code>EventLoop</code></li>\n<li><code>public B group(EventLoopGroup group)</code>，该方法用于客户端，用来设置一个 <code>EventLoop</code></li>\n<li><code>public B channel(Class&lt;? extends C&gt; channelClass)</code>，该方法用来设置一个服务器端的通道实现</li>\n<li><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code>，用来给 <code>ServerChannel</code> 添加配置</li>\n<li><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code>，用来给接收到的通道添加配置</li>\n<li><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code>，该方法用来设置业务处理类（自定义的<code>handler</code>）</li>\n<li><code>public ChannelFuture bind(int inetPort)</code>，该方法用于服务器端，用来设置占用的端口号</li>\n<li><code>public ChannelFuture connect(String inetHost, int inetPort)</code>，该方法用于客户端，用来连接服务器端</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"Future、ChannelFuture\"><a href=\"#Future、ChannelFuture\" class=\"headerlink\" title=\"Future、ChannelFuture\"></a>Future、ChannelFuture</h4><p><code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <code>Future</code> 和 <code>ChannelFutures</code>，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p>\n<p>常见的方法有</p>\n<ul>\n<li><code>Channel channel()</code>，返回当前正在进行 <code>IO</code> 操作的通道</li>\n<li><code>ChannelFuture sync()</code>，等待异步操作执行完毕</li>\n</ul>\n<h4 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h4><ol>\n<li><code>Netty</code> 网络通信的组件，能够用于执行网络 <code>I/O</code> 操作。</li>\n<li>通过 <code>Channel</code> 可获得当前网络连接的通道的状态</li>\n<li>通过 <code>Channel</code> 可获得网络连接的配置参数（例如接收缓冲区大小）</li>\n<li><code>Channel</code> 提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成</li>\n<li>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</li>\n<li>支持关联 <code>I/O</code> 操作与对应的处理程序</li>\n<li>不同协议、不同的阻塞类型的连接都有不同的 <code>Channel</code> 类型与之对应，常用的 <code>Channel</code> 类型：<ul>\n<li><code>NioSocketChannel</code>，异步的客户端 <code>TCP</code> <code>Socket</code> 连接。</li>\n<li><code>NioServerSocketChannel</code>，异步的服务器端 <code>TCP</code> <code>Socket</code> 连接。</li>\n<li><code>NioDatagramChannel</code>，异步的 <code>UDP</code> 连接。</li>\n<li><code>NioSctpChannel</code>，异步的客户端 <code>Sctp</code> 连接。</li>\n<li><code>NioSctpServerChannel</code>，异步的 <code>Sctp</code> 服务器端连接，这些通道涵盖了 <code>UDP</code> 和 <code>TCP</code> 网络 <code>IO</code> 以及文件 <code>IO</code>。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"Selector\"><a href=\"#Selector\" class=\"headerlink\" title=\"Selector\"></a>Selector</h4><ol>\n<li><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</li>\n<li>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询（<code>Select</code>）这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 <code>Channel</code></li>\n</ol>\n<h4 id=\"ChannelHandler\"><a href=\"#ChannelHandler\" class=\"headerlink\" title=\"ChannelHandler\"></a>ChannelHandler</h4><ol>\n<li><code>ChannelHandler</code> 是一个接口，处理 <code>I/O</code> 事件或拦截 <code>I/O</code> 操作，并将其转发到其 <code>ChannelPipeline</code>（业务处理链）中的下一个处理程序。</li>\n<li><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</li>\n</ol>\n<h4 id=\"Pipeline-和-ChannelPipeline\"><a href=\"#Pipeline-和-ChannelPipeline\" class=\"headerlink\" title=\"Pipeline 和 ChannelPipeline\"></a>Pipeline 和 ChannelPipeline</h4><ol>\n<li><code>ChannelPipeline</code> 是一个 <code>Handler</code> 的集合，它负责处理和拦截 <code>inbound</code> 或者 <code>outbound</code> 的事件和操作，相当于一个贯穿 <code>Netty</code> 的链。（也可以这样理解：<code>ChannelPipeline</code> 是保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作）</li>\n<li><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互</li>\n<li>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应，它们的组成关系如下</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/10/18/oZARqLONHzbaGiP.png\" alt=\"\"></p>\n<p>​    <img src=\"https://i.loli.net/2021/10/18/KeR8OM6uTVqhjFZ.png\" alt=\"\"></p>\n<ol start=\"4\">\n<li>常用方法<br> <code>ChannelPipeline addFirst(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的第一个位置<code>ChannelPipeline addLast(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的最后一个位置</li>\n</ol>\n<h4 id=\"ChannelHandlerContext\"><a href=\"#ChannelHandlerContext\" class=\"headerlink\" title=\"ChannelHandlerContext\"></a>ChannelHandlerContext</h4><ol>\n<li>保存 <code>Channel</code> 相关的所有上下文信息，同时关联一个 <code>ChannelHandler</code> 对象</li>\n<li>即 <code>ChannelHandlerContext</code> 中包含一个具体的事件处理器 <code>ChannelHandler</code>，同时 <code>ChannelHandlerContext</code> 中也绑定了对应的 <code>pipeline</code> 和 <code>Channel</code> 的信息，方便对 <code>ChannelHandler</code> 进行调用。</li>\n<li>常用方法<ul>\n<li><code>ChannelFuture close()</code>，关闭通道</li>\n<li><code>ChannelOutboundInvoker flush()</code>，刷新</li>\n<li><code>ChannelFuture writeAndFlush(Object msg)</code>，将数据写到 </li>\n<li><code>ChannelPipeline</code> 中当前 <code>ChannelHandler</code> 的下一个 <code>ChannelHandler</code> 开始处理（出站）</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/10/18/qRSk7ezATLQtKV5.png\" alt=\"\"></p>\n<h4 id=\"ChannelOption\"><a href=\"#ChannelOption\" class=\"headerlink\" title=\"ChannelOption\"></a>ChannelOption</h4><ol>\n<li><code>Netty</code> 在创建 <code>Channel</code> 实例后，一般都需要设置 <code>ChannelOption</code> 参数。</li>\n<li><code>ChannelOption</code> 参数如下：</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/10/18/Z6pAFyCjhOU5dvg.png\" alt=\"\"></p>\n<h4 id=\"EventLoopGroup\"><a href=\"#EventLoopGroup\" class=\"headerlink\" title=\"EventLoopGroup\"></a>EventLoopGroup</h4><ol>\n<li><code>EventLoopGroup</code> 是一组 <code>EventLoop</code> 的抽象，<code>Netty</code> 为了更好的利用多核 <code>CPU</code> 资源，一般会有多个 <code>EventLoop</code> 同时工作，每个 <code>EventLoop</code> 维护着一个 <code>Selector</code> 实例。</li>\n<li><code>EventLoopGroup</code> 提供 <code>next</code> 接口，可以从组里面按照一定规则获取其中一个 <code>EventLoop</code> 来处理任务。在 <code>Netty</code> 服务器端编程中，我们一般都需要提供两个 <code>EventLoopGroup</code>，例如：<code>BossEventLoopGroup</code> 和 <code>WorkerEventLoopGroup</code>。</li>\n<li>通常一个服务端口即一个 <code>ServerSocketChannel</code> 对应一个 <code>Selector</code> 和一个 <code>EventLoop</code> 线程。<code>BossEventLoop</code> 负责接收客户端的连接并将 <code>SocketChannel</code> 交给 <code>WorkerEventLoopGroup</code> 来进行 <code>IO</code> 处理，如下图所示</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/10/18/zoQgpkliDMshRN1.png\" alt=\"\"></p>\n<ol start=\"4\">\n<li>常用方法<br> <code>public NioEventLoopGroup()</code>，构造方法<br> <code>public Future&lt;?&gt; shutdownGracefully()</code>，断开连接，关闭线程</li>\n</ol>\n<h4 id=\"Unpooled\"><a href=\"#Unpooled\" class=\"headerlink\" title=\"Unpooled\"></a>Unpooled</h4><ol>\n<li><code>Netty</code> 提供一个专门用来操作缓冲区（即 <code>Netty</code> 的数据容器）的工具类</li>\n<li>常用方法如下所示</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/10/18/yQbHkAGRs7fqYX2.png\" alt=\"\"></p>\n<ol start=\"3\">\n<li><code>Unpooled</code> 获取 <code>Netty</code> 的数据容器 <code>ByteBuf</code> 的基本使用</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/10/18/CpM4xhrFYE1IdVB.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"BIO、NIO与Netty\"><a href=\"#BIO、NIO与Netty\" class=\"headerlink\" title=\"BIO、NIO与Netty\"></a>BIO、NIO与Netty</h1><blockquote>\n<h3 id=\"网络编程：\"><a href=\"#网络编程：\" class=\"headerlink\" title=\"网络编程：\"></a>网络编程：</h3><p>​        网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定的IP地址和监听端口），客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果连接建立成功，双方就可以通过网络套接字（Socket）进行通信。</p>\n<h3 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO:\"></a>BIO:</h3><p>​        在1.4版本之前，Java IO类库是阻塞IO（Blocking IO），建立网络连接的时候采用BIO模式。</p>\n<h3 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO:\"></a>NIO:</h3><p>​        为了支持非阻塞IO，Java引进了新的IO库，简称为JAVA NIO（Non-Blocking IO）。Java NIO属于 IO多路复用模型。</p>\n<h3 id=\"Netty\"><a href=\"#Netty\" class=\"headerlink\" title=\"Netty:\"></a>Netty:</h3><p>​        Netty是一个异步的、<a href=\"https://baike.baidu.com/item/事件驱动/9597519\" target=\"_blank\" rel=\"noopener\">事件驱动</a>的网络应用程序框架，基于NIO，使用Netty 可以快速开发出一个网络应用，例如实现了某种协议的客户、<a href=\"https://baike.baidu.com/item/服务端/6492316\" target=\"_blank\" rel=\"noopener\">服务端</a>应用。</p>\n</blockquote>\n<h2 id=\"1-Java-BIO\"><a href=\"#1-Java-BIO\" class=\"headerlink\" title=\"1. Java BIO\"></a>1. Java BIO</h2><h3 id=\"1-1-Java-BIO模型\"><a href=\"#1-1-Java-BIO模型\" class=\"headerlink\" title=\"1.1 Java BIO模型\"></a>1.1 Java BIO模型</h3><ul>\n<li><p>同步阻塞IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，在高并发的应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。</p>\n<p>  <img src=\"https://i.loli.net/2021/10/18/6jJxcVENwszR8Wd.png\" alt=\"bio-model\"></p>\n</li>\n</ul>\n<h3 id=\"1-2-Java-BIO-工作流程\"><a href=\"#1-2-Java-BIO-工作流程\" class=\"headerlink\" title=\"1.2 Java BIO 工作流程\"></a>1.2 Java BIO 工作流程</h3><ol>\n<li>服务器端启动一个 <code>ServerSocket</code>，监听端口。</li>\n<li>客户端启动 <code>Socket</code> 与服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯。</li>\n<li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待或被拒绝，如果有响应，客户端线程会等待请求结束后继续执行。</li>\n</ol>\n<h3 id=\"1-3-Java-BIO代码示例-所有代码可前往github下载\"><a href=\"#1-3-Java-BIO代码示例-所有代码可前往github下载\" class=\"headerlink\" title=\"1.3 Java BIO代码示例(所有代码可前往github下载)\"></a>1.3 Java BIO代码示例(<a href=\"https://github.com/VickyLuoLuo/netty.git\" target=\"_blank\" rel=\"noopener\">所有代码可前往github下载</a>)</h3><ul>\n<li>最简单的BIO服务器：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.ServerSocket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.Socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BioServer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建ServerSocket</span></span><br><span class=\"line\">        ServerSocket serverSocket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">9090</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"服务器启动\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//监听，等待客户端连接</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"等待连接....\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Socket socket = serverSocket.accept(); <span class=\"comment\">// 阻塞</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"连接到一个客户端\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">            socket.getInputStream().read(bytes); <span class=\"comment\">// 阻塞</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"收到客户端消息：\"</span> + <span class=\"keyword\">new</span> String(bytes));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们可以对上述代码进行优化，将<code>socket.getInputStream().read(bytes)</code>消息处理部分改成线程池异步处理：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.ServerSocket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.Socket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BioServer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建ServerSocket</span></span><br><span class=\"line\">        ServerSocket serverSocket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">9090</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"服务器启动\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 线程池机制,思路: 1. 创建一个线程池 2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class=\"line\">        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//监听，等待客户端连接</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"等待连接....\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Socket socket = serverSocket.accept(); <span class=\"comment\">// 阻塞</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"连接到一个客户端\"</span>);</span><br><span class=\"line\">            newCachedThreadPool.execute(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 通讯处理</span></span><br><span class=\"line\">                handler(socket);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handler</span><span class=\"params\">(Socket socket)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">            <span class=\"comment\">//通过socket获取输入流</span></span><br><span class=\"line\">            InputStream inputStream = socket.getInputStream();</span><br><span class=\"line\">            <span class=\"comment\">//循环的读取客户端发送的数据</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"handler线程：id = \"</span> + Thread.currentThread().getId() + <span class=\"string\">\"等待接收消息\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> read = inputStream.read(bytes); <span class=\"comment\">// 阻塞</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (read != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"handler线程：id = \"</span> + Thread.currentThread().getId() + <span class=\"string\">\"收到消息：\"</span> + <span class=\"keyword\">new</span> String(bytes, <span class=\"number\">0</span>, read));</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"handler线程：id = \"</span> + Thread.currentThread().getId() + <span class=\"string\">\"关闭连接\"</span>); </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                socket.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        这样可以同时处理多个连接请求，但是由于<code>inputStream.read(bytes)</code>是阻塞的，当有多个连接请求时，每个连接占用一个线程，此时如果大部分连接都没有发送消息，线程就一直被占用，造成资源浪费。</p>\n<h2 id=\"2-Java-NIO\"><a href=\"#2-Java-NIO\" class=\"headerlink\" title=\"2. Java NIO\"></a>2. Java NIO</h2><h3 id=\"2-1-Java-NIO模型\"><a href=\"#2-1-Java-NIO模型\" class=\"headerlink\" title=\"2.1 Java NIO模型\"></a>2.1 Java NIO模型</h3><ul>\n<li><p>同步非阻塞IO，服务器实现模式为一个线程处理多个连接请求，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <code>I/O</code> 请求就进行处理。</p>\n<p>  <img src=\"https://i.loli.net/2021/10/18/ABy7qJoGhwaSzip.png\" alt=\"nio-model\"></p>\n</li>\n</ul>\n<h3 id=\"2-2-Java-NIO的三大核心组件\"><a href=\"#2-2-Java-NIO的三大核心组件\" class=\"headerlink\" title=\"2.2 Java NIO的三大核心组件\"></a>2.2 Java NIO的三大核心组件</h3><ol>\n<li><h4 id=\"通道（Channel）\"><a href=\"#通道（Channel）\" class=\"headerlink\" title=\"通道（Channel）\"></a>通道（Channel）</h4><p> 在BIO中，同一个网络连接会通过输入流（Input Stream）和输出流（Output Stream）不断地进行输入和输出的操作。在NIO中，同一个网络连接使用一个通道表示，所有的NIO的IO操作都是从通道开始的。一个通道类似于BIO中的两个流的结合体，既可以从通道读取，也可以向通道写入。</p>\n</li>\n<li><h4 id=\"选择器（Selector）\"><a href=\"#选择器（Selector）\" class=\"headerlink\" title=\"选择器（Selector）\"></a>选择器（Selector）</h4><blockquote>\n<p>IO多路复用指的是一个进程/线程可以同时监视多个文件描述符（一个网络连接，操作系统底层使用一个文件描述符来表示），一旦其中的一个或者多个文件描述符可读或者可写，系统内核就通知该进程/线程。</p>\n</blockquote>\n<p> 通过选择器，一个线程可以查询多个通道的IO事件的就绪状态，即监视多个文件描述符。具体的开发层面来说，首先把通道注册到选择器中，然后通过选择器内部的机制，可以查询（select）这些注册的通道是否有已经就绪的IO事件（例如可读、可写、网络连接完成等）。一个选择器只需要一个线程进行监控，系统不必为每一个网络连接（文件描述符）创建进程/线程，从而大大减小了系统的开销。</p>\n</li>\n<li><h4 id=\"缓冲区（Buffer）\"><a href=\"#缓冲区（Buffer）\" class=\"headerlink\" title=\"缓冲区（Buffer）\"></a>缓冲区（Buffer）</h4><p> 应用程序与通道（Channel）主要的交互操作，就是进行数据的read读取和write写入。通道的读取，就是将数据从通道读取到缓冲区中；通道的写入，就是将数据从缓冲区中写入到通道中。</p>\n</li>\n</ol>\n<h3 id=\"2-3-Selector、Channel-和-Buffer的-关系\"><a href=\"#2-3-Selector、Channel-和-Buffer的-关系\" class=\"headerlink\" title=\"2.3 Selector、Channel 和 Buffer的 关系\"></a>2.3 Selector、Channel 和 Buffer的 关系</h3><ol>\n<li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li>\n<li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li>\n<li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li>\n<li><code>Buffer</code> 就是一个内存块，底层是一个数组。</li>\n<li>数据通过 <code>Buffer</code>进行读写，<code>BIO</code> 中要么是输入流，要么是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换 。<code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/10/18/4F5pSqTYbayDgsJ.png\" alt=\"nio-element\"></p>\n<h3 id=\"2-4-Java-NIO-工作流程\"><a href=\"#2-4-Java-NIO-工作流程\" class=\"headerlink\" title=\"2.4 Java NIO 工作流程\"></a>2.4 Java NIO 工作流程</h3><ol>\n<li><p>服务器端启动一个 <code>ServerSocketChannel</code>，监听端口。—类似BIO中的ServerSocket。</p>\n</li>\n<li><p>客户端启动 <code>SocketChannel</code>与服务器进行通信。—类似BIO中的Socket。</p>\n</li>\n<li><p>获取<code>Selector</code>选择器，并将<code>ServerSocketChannel</code>注册到<code>Selector</code>上，接收新连接。注册后返回一个 <code>SelectionKey</code>（集合），会和该 <code>Selector</code> 关联。一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</p>\n</li>\n<li><p>当客户端连接时，服务端会通过 <code>ServerSocketChannel</code> 得到<code>SocketChannel</code>。</p>\n</li>\n<li><p><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</p>\n</li>\n<li><p>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，进一步得到各个 <code>SelectionKey</code>（有事件发生）。</p>\n</li>\n<li><p>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>。</p>\n</li>\n<li><p>可以通过得到的 <code>channel</code>，完成业务处理。</p>\n<p> <img src=\"https://i.loli.net/2021/10/18/ybcGt7zRT459L8Z.png\" alt=\"nio-workflow\"></p>\n</li>\n</ol>\n<h3 id=\"2-4-Java-NIO-代码示例-所有代码可前往github下载\"><a href=\"#2-4-Java-NIO-代码示例-所有代码可前往github下载\" class=\"headerlink\" title=\"2.4 Java NIO 代码示例(所有代码可前往github下载)\"></a>2.4 Java NIO 代码示例(<a href=\"https://github.com/VickyLuoLuo/netty.git\" target=\"_blank\" rel=\"noopener\">所有代码可前往github下载</a>)</h3><ul>\n<li>简单的NIO服务器，使用一个集合<code>List&lt;SocketChannel&gt;</code>来存放所有从客户端接收到的<code>SocketChannel</code>，并一直轮询处理IO事件</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.InetSocketAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.ByteBuffer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioServer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> List&lt;SocketChannel&gt; channelList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startServer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\">        <span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">        serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 绑定连接</span></span><br><span class=\"line\">        serverSocketChannel.bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">5252</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"服务器启动成功\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 轮询感兴趣的IO就绪事件（选择键集合）</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 获取客户端连接</span></span><br><span class=\"line\">            SocketChannel socketChannel = serverSocketChannel.accept(); <span class=\"comment\">// 非阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != socketChannel) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"连接成功\"</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 设置SocketChannel为非阻塞模式。NIO的非阻塞是由操作系统内部实现的，底层调用了系统内核的accept方法</span></span><br><span class=\"line\">                socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                channelList.add(socketChannel);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 获取选择键集合</span></span><br><span class=\"line\">            Iterator&lt;SocketChannel&gt; channels = channelList.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (channels.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取单个的选择键并处理</span></span><br><span class=\"line\">                SocketChannel channel = channels.next();</span><br><span class=\"line\">                ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 调用通道的read方法，从通道读取数据写入缓冲区，并返回读取到的数据</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> length = channel.read(byteBuffer); <span class=\"comment\">// 非阻塞</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"接收到消息：\"</span> + <span class=\"keyword\">new</span> String(byteBuffer.array(), <span class=\"number\">0</span>, length));</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (length == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    channels.remove();</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"客户端断开连接\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        startServer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>上述代码有个很严重的问题，由于关键的两个方法：接收连接<code>serverSocketChannel.accept()</code>和读取消息<code>channel.read(byteBuffer)</code>都是非阻塞的，<code>while(true)</code>就会无限循环直到内存溢出，<code>Selector</code>很好的解决了这个问题，<code>selector.select()</code>会阻塞，直到有事件发生：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.InetSocketAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.ByteBuffer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SelectionKey;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.Selector;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioSelectorServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startServer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\">        <span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">        serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 绑定连接</span></span><br><span class=\"line\">        serverSocketChannel.bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">5656</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"服务器启动成功\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取选择器</span></span><br><span class=\"line\">        Selector selector = Selector.open(); <span class=\"comment\">// epoll</span></span><br><span class=\"line\">        <span class=\"comment\">// 将通道注册的“接收新连接”IO事件注册到选择器上</span></span><br><span class=\"line\">        SelectionKey selectionKey = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 轮询感兴趣的IO就绪事件（选择键集合）</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (selector.select() &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 阻塞 epoll-wait</span></span><br><span class=\"line\">            <span class=\"comment\">// 获取选择键集合</span></span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (selectedKeys.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取单个的选择键并处理</span></span><br><span class=\"line\">                SelectionKey selectedKey = selectedKeys.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (selectedKey.isAcceptable()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 若选择键的IO事件是“连接就绪”，就获取客户端连接</span></span><br><span class=\"line\">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class=\"line\">                    <span class=\"comment\">// 切换为非阻塞模式</span></span><br><span class=\"line\">                    socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 将新连接的通道可读事件注册到选择器上</span></span><br><span class=\"line\">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"连接成功\"</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedKey.isReadable()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 若选择键的IO事件是“可读”，就读取数据</span></span><br><span class=\"line\">                    SocketChannel socketChannel = (SocketChannel) selectedKey.channel();</span><br><span class=\"line\">                    <span class=\"comment\">// 读取数据，然后丢弃</span></span><br><span class=\"line\">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 调用通道的read方法，从通道读取数据写入缓冲区，并返回读取到的数据</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> length = socketChannel.read(byteBuffer);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"接收到消息：\"</span> + <span class=\"keyword\">new</span> String(byteBuffer.array(), <span class=\"number\">0</span>, length));</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (length == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"客户端断开连接\"</span>);</span><br><span class=\"line\">                        socketChannel.close();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 移除选择键</span></span><br><span class=\"line\">                selectedKeys.remove();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\">        serverSocketChannel.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        startServer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-多路复用器Selector\"><a href=\"#2-5-多路复用器Selector\" class=\"headerlink\" title=\"2.5 多路复用器Selector\"></a>2.5 多路复用器<code>Selector</code></h3><p>​    通过<code>Selector</code>，可以使用一个线程查询多个通道的IO事件的就绪状态，并在没有事件发生时阻塞。其原理依赖于<code>epoll</code>系统调用(Linux系统为例)，<code>epoll</code>系统调用的主要方法：</p>\n<ol>\n<li><p>epoll_create</p>\n<p> 创建一个epoll文件描述符。可简单理解为channel 集合。</p>\n</li>\n<li><p>epoll_ctl</p>\n<p> 添加/修改/删除需要侦听的文件描述符及其事件。可简单理解为channel事件集合。</p>\n</li>\n<li><p>epoll_wait</p>\n<p> 接收发生在被侦听的描述符上的，用户感兴趣的IO事件。可简单理解为 channel事件集合为空时阻塞。</p>\n</li>\n</ol>\n<h3 id=\"2-6-Java-NIO-常用类及属性\"><a href=\"#2-6-Java-NIO-常用类及属性\" class=\"headerlink\" title=\"2.6 Java NIO 常用类及属性\"></a>2.6 Java NIO 常用类及属性</h3><p>​        参见另一篇博客：<a href=\"https://vickyluoluo.github.io/2021/03/31/57bd.html\">Java NIO通信基础</a></p>\n<h2 id=\"3-Netty\"><a href=\"#3-Netty\" class=\"headerlink\" title=\"3. Netty\"></a>3. Netty</h2><h3 id=\"3-1-原生NIO存在的问题\"><a href=\"#3-1-原生NIO存在的问题\" class=\"headerlink\" title=\"3.1 原生NIO存在的问题\"></a>3.1 原生NIO存在的问题</h3><ol>\n<li><code>NIO</code> 的类库和 <code>API</code> 繁杂，使用麻烦：需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code>等。</li>\n<li>需要具备其他的额外技能：要熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 <code>NIO</code> 程序。</li>\n<li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。</li>\n<li><code>JDK NIO</code> 的 <code>Bug</code>：例如臭名昭著的 <code>Epoll Bug</code>，它会导致 <code>Selector</code> 空轮询，最终导致 <code>CPU100%</code>。直到 <code>JDK1.7</code> 版本该问题仍旧存在，没有被根本解决</li>\n</ol>\n<h3 id=\"3-2-Netty-的优点\"><a href=\"#3-2-Netty-的优点\" class=\"headerlink\" title=\"3.2 Netty 的优点\"></a>3.2 Netty 的优点</h3><p><code>Netty</code> 对 <code>JDK</code> 自带的 <code>NIO</code> 的 <code>API</code> 进行了封装，解决了上述问题。</p>\n<ol>\n<li>设计优雅：适用于各种传输类型的统一 <code>API</code> 阻塞和非阻塞 <code>Socket</code>；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。</li>\n<li>使用方便：详细记录的 <code>Javadoc</code>，用户指南和示例；没有其他依赖项，<code>JDK5（Netty3.x）</code>或 <code>6（Netty4.x）</code>就足够了。</li>\n<li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li>\n<li>安全：完整的 <code>SSL/TLS</code> 和 <code>StartTLS</code> 支持。</li>\n<li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 <code>Bug</code> 可以被及时修复，同时，更多的新功能会被加入。</li>\n</ol>\n<h3 id=\"3-3-Netty工作原理\"><a href=\"#3-3-Netty工作原理\" class=\"headerlink\" title=\"3.3 Netty工作原理\"></a>3.3 Netty工作原理</h3><p><img src=\"https://i.loli.net/2021/10/18/3cnCUJG4yerixqK.png\" alt=\"\"></p>\n<p><code>Netty</code> 线程模型基于主从 <code>Reactors</code> 多线程模型，<code>BossGroup</code> 线程维护 <code>Selector</code>，只关注 <code>Accecpt</code> 当接收到 <code>Accept</code> 事件，获取到对应的 <code>SocketChannel</code>，封装成 <code>NIOScoketChannel</code> 并注册到 <code>Worker</code> 线程（事件循环），并进行维护当 <code>Worker</code> 线程监听到 <code>Selector</code> 中通道发生自己感兴趣的事件后，由 <code>handler</code>进行处理。</p>\n<p><img src=\"https://i.loli.net/2021/10/18/chLyW8ko5aRuPqN.png\" alt=\"\"></p>\n<p>说明：</p>\n<ol>\n<li><code>Netty</code> 抽象出两组线程池 <code>BossGroup</code> 专门负责接收客户端的连接，<code>WorkerGroup</code> 专门负责网络的读写</li>\n<li><code>BossGroup</code> 和 <code>WorkerGroup</code> 类型都是 <code>NioEventLoopGroup</code> </li>\n<li><code>NioEventLoopGroup</code> 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 <code>NioEventLoop</code> </li>\n<li><code>NioEventLoop</code> 表示一个不断循环的执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code> 的网络通讯</li>\n<li><code>NioEventLoopGroup</code> 可以有多个线程，即可以含有多个 <code>NioEventLoop</code> </li>\n<li>每个 <code>BossNioEventLoop</code> 循环执行的步骤有 <code>3</code> 步<ul>\n<li>轮询 <code>accept</code> 事件</li>\n<li>处理 <code>accept</code> 事件，与 <code>client</code> 建立连接，生成 <code>NioScocketChannel</code>，并将其注册到某个 <code>worker</code> <code>NIOEventLoop</code> 上的 <code>Selector</code></li>\n<li>处理任务队列的任务，即 <code>runAllTasks</code></li>\n</ul>\n</li>\n<li>每个 <code>Worker</code> <code>NIOEventLoop</code> 循环执行的步骤<ul>\n<li>轮询 <code>read</code>，<code>write</code> 事件</li>\n<li>处理 <code>I/O</code> 事件，即 <code>read</code>，<code>write</code> 事件，在对应 <code>NioScocketChannel</code> 处理</li>\n<li>处理任务队列的任务，即 <code>runAllTasks</code></li>\n</ul>\n</li>\n<li>每个 <code>Worker</code> <code>NIOEventLoop</code> 处理业务时，会使用 <code>pipeline</code>（管道），<code>pipeline</code> 中包含了 <code>channel</code>，即通过 <code>pipeline</code> 可以获取到对应通道，管道中维护了很多的处理器</li>\n</ol>\n<h3 id=\"3-4-Netty-代码示例-所有代码可前往github下载\"><a href=\"#3-4-Netty-代码示例-所有代码可前往github下载\" class=\"headerlink\" title=\"3.4 Netty 代码示例(所有代码可前往github下载)\"></a>3.4 Netty 代码示例(<a href=\"https://github.com/VickyLuoLuo/netty.git\" target=\"_blank\" rel=\"noopener\">所有代码可前往github下载</a>)</h3><ul>\n<li>简单的Netty服务器实现：<ol>\n<li><code>NettyServer.java</code> 服务器启动类，通过链式编程配置启动参数并监听端口</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyServer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建两个线程组bossGroup和workerGroup，默认子线程个数为cpu核数 * 2，bossGroup只处理连接请求,真正的客户端业务处理会交给workerGroup</span></span><br><span class=\"line\">        EventLoopGroup bossGroup = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">1</span>);</span><br><span class=\"line\">        EventLoopGroup workerGroup = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建服务器端的启动对象，配置参数</span></span><br><span class=\"line\">            ServerBootstrap bootstrap = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\">            <span class=\"comment\">//使用链式编程来进行设置</span></span><br><span class=\"line\">            bootstrap.group(bossGroup, workerGroup) <span class=\"comment\">//设置两个线程组</span></span><br><span class=\"line\">                    .channel(NioServerSocketChannel<span class=\"class\">.<span class=\"keyword\">class</span>) //使用<span class=\"title\">NioSocketChannel</span> 作为服务器的通道实现</span></span><br><span class=\"line\"><span class=\"class\">                    .<span class=\"title\">option</span>(<span class=\"title\">ChannelOption</span>.<span class=\"title\">SO_BACKLOG</span>, 128) // 初始化服务器接收连接的队列大小</span></span><br><span class=\"line\"><span class=\"class\">                    .<span class=\"title\">childHandler</span>(<span class=\"title\">new</span> <span class=\"title\">ChannelInitializer</span>&lt;<span class=\"title\">SocketChannel</span>&gt;() </span>&#123;<span class=\"comment\">//创建一个通道初始化对象(匿名对象)</span></span><br><span class=\"line\">                        <span class=\"comment\">//给workGroup的SocketChannel设置处理器</span></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> </span>&#123;</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">\"客户socketchannel hashcode=\"</span> + ch.hashCode()); <span class=\"comment\">//可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue</span></span><br><span class=\"line\">                            ch.pipeline().addLast(<span class=\"keyword\">new</span> NettyServerHandler()); <span class=\"comment\">// 可添加多个</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\".....服务器 is ready...\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//启动服务器并绑定端口，bind是异步操作，可以通过isDone()等方法查看事件执行情况</span></span><br><span class=\"line\">            ChannelFuture cf = bootstrap.bind(<span class=\"number\">6668</span>).sync();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//给cf 注册监听器，监控我们关心的事件</span></span><br><span class=\"line\">            cf.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cf.isSuccess()) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"监听端口成功\"</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"监听端口失败\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//对关闭通道进行监听</span></span><br><span class=\"line\">            cf.channel().closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            bossGroup.shutdownGracefully();</span><br><span class=\"line\">            workerGroup.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​            2. <code>NettyServerHandler.java</code>自定义<code>ChannelHandler</code>处理业务，只需根据需要继承指定类型的抽象类，通过重载父类方法实现业务处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> io.netty.buffer.ByteBuf;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.buffer.Unpooled;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.util.CharsetUtil;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyServerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当客户端连接服务器完成时触发</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ctx: 上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端连接通道建立完成\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 读取数据实际(这里我们可以读取客户端发送的消息)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> msg: 就是客户端发送的数据 默认Object</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Channel channel = ctx.channel();</span><br><span class=\"line\">        <span class=\"comment\">//将 msg 转成一个 ByteBuf,ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span></span><br><span class=\"line\">        ByteBuf buf = (ByteBuf) msg;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端发送消息是:\"</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端地址:\"</span> + channel.remoteAddress());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  数据读取完毕</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelReadComplete</span><span class=\"params\">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//将数据写入到缓存，并刷新</span></span><br><span class=\"line\">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class=\"string\">\"hello, 客户端\"</span>, CharsetUtil.UTF_8));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 处理异常, 一般关闭通道</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ctx</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> cause</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">        ctx.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>SpringBoot</code> + <code>Netty</code>实现网络聊天室核心代码(<a href=\"https://github.com/VickyLuoLuo/netty.git\" target=\"_blank\" rel=\"noopener\">完整代码可前往github下载</a>)：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelInitializer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelPipeline;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.stream.ChunkedWriteHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"somethingChannelInitializer\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyWebSocketChannelInitializer</span> <span class=\"keyword\">extends</span> <span class=\"title\">ChannelInitializer</span>&lt;<span class=\"title\">SocketChannel</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextWebSocketFrameHandler textWebSocketFrameHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;<span class=\"comment\">//2</span></span><br><span class=\"line\">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class=\"line\"></span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> HttpServerCodec()); <span class=\"comment\">// http解编码器</span></span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> HttpObjectAggregator(<span class=\"number\">64</span>*<span class=\"number\">1024</span>)); <span class=\"comment\">// 补充http解编码器</span></span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> ChunkedWriteHandler()); <span class=\"comment\">// 保证队列中的每一个元素是一次性发送</span></span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> WebSocketServerProtocolHandler(<span class=\"string\">\"/ws\"</span>)); <span class=\"comment\">//</span></span><br><span class=\"line\">        pipeline.addLast(textWebSocketFrameHandler); <span class=\"comment\">// 自定义ChannelHandler</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.lhl.netty.chat.util.RandomName;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.lhl.netty.chat.util.RedisDao;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.http.websocketx.TextWebSocketFrame;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"textWebSocketFrameHandler\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextWebSocketFrameHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleChannelInboundHandler</span>&lt;<span class=\"title\">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ChannelGroup channels = <span class=\"keyword\">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisDao redisDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                TextWebSocketFrame msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel incoming = ctx.channel();</span><br><span class=\"line\">        String uName = redisDao.getString(incoming.id()+<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Channel channel : channels) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (channel != incoming)&#123;</span><br><span class=\"line\">                channel.writeAndFlush(<span class=\"keyword\">new</span> TextWebSocketFrame(<span class=\"string\">\"[\"</span> + uName + <span class=\"string\">\"]\"</span> + msg.text()));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                channel.writeAndFlush(<span class=\"keyword\">new</span> TextWebSocketFrame(<span class=\"string\">\"[我]\"</span> + msg.text() ));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handlerAdded</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(ctx.channel().remoteAddress());</span><br><span class=\"line\">        String uName = <span class=\"keyword\">new</span> RandomName().getRandomName();</span><br><span class=\"line\"></span><br><span class=\"line\">        Channel incoming = ctx.channel();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Channel channel : channels) &#123;</span><br><span class=\"line\">            channel.writeAndFlush(<span class=\"keyword\">new</span> TextWebSocketFrame(<span class=\"string\">\"[新用户] - \"</span> + uName + <span class=\"string\">\" 加入群聊\"</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        redisDao.saveString(incoming.id()+<span class=\"string\">\"\"</span>,uName);</span><br><span class=\"line\">        channels.add(ctx.channel());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handlerRemoved</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel incoming = ctx.channel();</span><br><span class=\"line\">        String uName = redisDao.getString(String.valueOf(incoming.id()));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Channel channel : channels) &#123;</span><br><span class=\"line\">            channel.writeAndFlush(<span class=\"keyword\">new</span> TextWebSocketFrame(<span class=\"string\">\"[用户] - \"</span> + uName + <span class=\"string\">\" 离开\"</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        redisDao.deleteString(String.valueOf(incoming.id()));</span><br><span class=\"line\"></span><br><span class=\"line\">        channels.remove(ctx.channel());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel incoming = ctx.channel();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"用户:\"</span>+redisDao.getString(incoming.id()+<span class=\"string\">\"\"</span>)+<span class=\"string\">\"在线\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelInactive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel incoming = ctx.channel();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"用户:\"</span>+redisDao.getString(incoming.id()+<span class=\"string\">\"\"</span>)+<span class=\"string\">\"掉线\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel incoming = ctx.channel();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"用户:\"</span>+redisDao.getString(incoming.id()+<span class=\"string\">\"\"</span>)+<span class=\"string\">\"异常\"</span>);</span><br><span class=\"line\">        cause.printStackTrace();</span><br><span class=\"line\">        ctx.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-Netty常用类及属性\"><a href=\"#3-5-Netty常用类及属性\" class=\"headerlink\" title=\"3.5 Netty常用类及属性\"></a>3.5 Netty常用类及属性</h3><h4 id=\"Bootstrap、ServerBootstrap\"><a href=\"#Bootstrap、ServerBootstrap\" class=\"headerlink\" title=\"Bootstrap、ServerBootstrap\"></a>Bootstrap、ServerBootstrap</h4><ol>\n<li><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类。</li>\n<li>常见的方法有<ul>\n<li><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>，该方法用于服务器端，用来设置两个 <code>EventLoop</code></li>\n<li><code>public B group(EventLoopGroup group)</code>，该方法用于客户端，用来设置一个 <code>EventLoop</code></li>\n<li><code>public B channel(Class&lt;? extends C&gt; channelClass)</code>，该方法用来设置一个服务器端的通道实现</li>\n<li><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code>，用来给 <code>ServerChannel</code> 添加配置</li>\n<li><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code>，用来给接收到的通道添加配置</li>\n<li><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code>，该方法用来设置业务处理类（自定义的<code>handler</code>）</li>\n<li><code>public ChannelFuture bind(int inetPort)</code>，该方法用于服务器端，用来设置占用的端口号</li>\n<li><code>public ChannelFuture connect(String inetHost, int inetPort)</code>，该方法用于客户端，用来连接服务器端</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"Future、ChannelFuture\"><a href=\"#Future、ChannelFuture\" class=\"headerlink\" title=\"Future、ChannelFuture\"></a>Future、ChannelFuture</h4><p><code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <code>Future</code> 和 <code>ChannelFutures</code>，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p>\n<p>常见的方法有</p>\n<ul>\n<li><code>Channel channel()</code>，返回当前正在进行 <code>IO</code> 操作的通道</li>\n<li><code>ChannelFuture sync()</code>，等待异步操作执行完毕</li>\n</ul>\n<h4 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h4><ol>\n<li><code>Netty</code> 网络通信的组件，能够用于执行网络 <code>I/O</code> 操作。</li>\n<li>通过 <code>Channel</code> 可获得当前网络连接的通道的状态</li>\n<li>通过 <code>Channel</code> 可获得网络连接的配置参数（例如接收缓冲区大小）</li>\n<li><code>Channel</code> 提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成</li>\n<li>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</li>\n<li>支持关联 <code>I/O</code> 操作与对应的处理程序</li>\n<li>不同协议、不同的阻塞类型的连接都有不同的 <code>Channel</code> 类型与之对应，常用的 <code>Channel</code> 类型：<ul>\n<li><code>NioSocketChannel</code>，异步的客户端 <code>TCP</code> <code>Socket</code> 连接。</li>\n<li><code>NioServerSocketChannel</code>，异步的服务器端 <code>TCP</code> <code>Socket</code> 连接。</li>\n<li><code>NioDatagramChannel</code>，异步的 <code>UDP</code> 连接。</li>\n<li><code>NioSctpChannel</code>，异步的客户端 <code>Sctp</code> 连接。</li>\n<li><code>NioSctpServerChannel</code>，异步的 <code>Sctp</code> 服务器端连接，这些通道涵盖了 <code>UDP</code> 和 <code>TCP</code> 网络 <code>IO</code> 以及文件 <code>IO</code>。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"Selector\"><a href=\"#Selector\" class=\"headerlink\" title=\"Selector\"></a>Selector</h4><ol>\n<li><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</li>\n<li>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询（<code>Select</code>）这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 <code>Channel</code></li>\n</ol>\n<h4 id=\"ChannelHandler\"><a href=\"#ChannelHandler\" class=\"headerlink\" title=\"ChannelHandler\"></a>ChannelHandler</h4><ol>\n<li><code>ChannelHandler</code> 是一个接口，处理 <code>I/O</code> 事件或拦截 <code>I/O</code> 操作，并将其转发到其 <code>ChannelPipeline</code>（业务处理链）中的下一个处理程序。</li>\n<li><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</li>\n</ol>\n<h4 id=\"Pipeline-和-ChannelPipeline\"><a href=\"#Pipeline-和-ChannelPipeline\" class=\"headerlink\" title=\"Pipeline 和 ChannelPipeline\"></a>Pipeline 和 ChannelPipeline</h4><ol>\n<li><code>ChannelPipeline</code> 是一个 <code>Handler</code> 的集合，它负责处理和拦截 <code>inbound</code> 或者 <code>outbound</code> 的事件和操作，相当于一个贯穿 <code>Netty</code> 的链。（也可以这样理解：<code>ChannelPipeline</code> 是保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作）</li>\n<li><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互</li>\n<li>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应，它们的组成关系如下</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/10/18/oZARqLONHzbaGiP.png\" alt=\"\"></p>\n<p>​    <img src=\"https://i.loli.net/2021/10/18/KeR8OM6uTVqhjFZ.png\" alt=\"\"></p>\n<ol start=\"4\">\n<li>常用方法<br> <code>ChannelPipeline addFirst(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的第一个位置<code>ChannelPipeline addLast(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的最后一个位置</li>\n</ol>\n<h4 id=\"ChannelHandlerContext\"><a href=\"#ChannelHandlerContext\" class=\"headerlink\" title=\"ChannelHandlerContext\"></a>ChannelHandlerContext</h4><ol>\n<li>保存 <code>Channel</code> 相关的所有上下文信息，同时关联一个 <code>ChannelHandler</code> 对象</li>\n<li>即 <code>ChannelHandlerContext</code> 中包含一个具体的事件处理器 <code>ChannelHandler</code>，同时 <code>ChannelHandlerContext</code> 中也绑定了对应的 <code>pipeline</code> 和 <code>Channel</code> 的信息，方便对 <code>ChannelHandler</code> 进行调用。</li>\n<li>常用方法<ul>\n<li><code>ChannelFuture close()</code>，关闭通道</li>\n<li><code>ChannelOutboundInvoker flush()</code>，刷新</li>\n<li><code>ChannelFuture writeAndFlush(Object msg)</code>，将数据写到 </li>\n<li><code>ChannelPipeline</code> 中当前 <code>ChannelHandler</code> 的下一个 <code>ChannelHandler</code> 开始处理（出站）</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/10/18/qRSk7ezATLQtKV5.png\" alt=\"\"></p>\n<h4 id=\"ChannelOption\"><a href=\"#ChannelOption\" class=\"headerlink\" title=\"ChannelOption\"></a>ChannelOption</h4><ol>\n<li><code>Netty</code> 在创建 <code>Channel</code> 实例后，一般都需要设置 <code>ChannelOption</code> 参数。</li>\n<li><code>ChannelOption</code> 参数如下：</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/10/18/Z6pAFyCjhOU5dvg.png\" alt=\"\"></p>\n<h4 id=\"EventLoopGroup\"><a href=\"#EventLoopGroup\" class=\"headerlink\" title=\"EventLoopGroup\"></a>EventLoopGroup</h4><ol>\n<li><code>EventLoopGroup</code> 是一组 <code>EventLoop</code> 的抽象，<code>Netty</code> 为了更好的利用多核 <code>CPU</code> 资源，一般会有多个 <code>EventLoop</code> 同时工作，每个 <code>EventLoop</code> 维护着一个 <code>Selector</code> 实例。</li>\n<li><code>EventLoopGroup</code> 提供 <code>next</code> 接口，可以从组里面按照一定规则获取其中一个 <code>EventLoop</code> 来处理任务。在 <code>Netty</code> 服务器端编程中，我们一般都需要提供两个 <code>EventLoopGroup</code>，例如：<code>BossEventLoopGroup</code> 和 <code>WorkerEventLoopGroup</code>。</li>\n<li>通常一个服务端口即一个 <code>ServerSocketChannel</code> 对应一个 <code>Selector</code> 和一个 <code>EventLoop</code> 线程。<code>BossEventLoop</code> 负责接收客户端的连接并将 <code>SocketChannel</code> 交给 <code>WorkerEventLoopGroup</code> 来进行 <code>IO</code> 处理，如下图所示</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/10/18/zoQgpkliDMshRN1.png\" alt=\"\"></p>\n<ol start=\"4\">\n<li>常用方法<br> <code>public NioEventLoopGroup()</code>，构造方法<br> <code>public Future&lt;?&gt; shutdownGracefully()</code>，断开连接，关闭线程</li>\n</ol>\n<h4 id=\"Unpooled\"><a href=\"#Unpooled\" class=\"headerlink\" title=\"Unpooled\"></a>Unpooled</h4><ol>\n<li><code>Netty</code> 提供一个专门用来操作缓冲区（即 <code>Netty</code> 的数据容器）的工具类</li>\n<li>常用方法如下所示</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/10/18/yQbHkAGRs7fqYX2.png\" alt=\"\"></p>\n<ol start=\"3\">\n<li><code>Unpooled</code> 获取 <code>Netty</code> 的数据容器 <code>ByteBuf</code> 的基本使用</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/10/18/CpM4xhrFYE1IdVB.png\" alt=\"\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckx07v1ah0001acbf9gged9mf","category_id":"ckx07v1al0003acbf5cqqalcq","_id":"ckx07v1at000dacbfbyr13hzv"},{"post_id":"ckx07v1ap0007acbf3j2w7yu8","category_id":"ckx07v1al0003acbf5cqqalcq","_id":"ckx07v1av000gacbfhcrfa2u6"},{"post_id":"ckx07v1ar000aacbfevk46d3k","category_id":"ckx07v1al0003acbf5cqqalcq","_id":"ckx07v1ax000kacbf8kh81xyg"},{"post_id":"ckx07v1ak0002acbf2ygx0lsd","category_id":"ckx07v1al0003acbf5cqqalcq","_id":"ckx07v1az000oacbf2snbbmzd"},{"post_id":"ckx07v1as000bacbf7l65628y","category_id":"ckx07v1al0003acbf5cqqalcq","_id":"ckx07v1b0000racbfdqto0axf"},{"post_id":"ckx07v1au000facbf9v2y2x5y","category_id":"ckx07v1al0003acbf5cqqalcq","_id":"ckx07v1b1000vacbfbp8nggdh"},{"post_id":"ckx07v1an0005acbfg61og3ve","category_id":"ckx07v1al0003acbf5cqqalcq","_id":"ckx07v1b2000yacbfbeif2o1d"},{"post_id":"ckx07v1aw000iacbf4dcv52x1","category_id":"ckx07v1al0003acbf5cqqalcq","_id":"ckx07v1b30012acbfhjpm1ch4"},{"post_id":"ckx07v1ay000nacbf7nyoexnk","category_id":"ckx07v1al0003acbf5cqqalcq","_id":"ckx07v1b40015acbf5ejk3ut1"},{"post_id":"ckx07v1ao0006acbfgtbj08oa","category_id":"ckx07v1aw000jacbf39na7hxg","_id":"ckx07v1b50017acbf8ppee2pt"},{"post_id":"ckx07v1az000qacbfesi5egem","category_id":"ckx07v1al0003acbf5cqqalcq","_id":"ckx07v1b50019acbf3nk60yx9"},{"post_id":"ckx07v1b0000uacbf2fj0a0ev","category_id":"ckx07v1al0003acbf5cqqalcq","_id":"ckx07v1b5001aacbf6ffzft26"},{"post_id":"ckx07v1b1000xacbf6mwm4aid","category_id":"ckx07v1al0003acbf5cqqalcq","_id":"ckx07v1b5001dacbf57hp5yz2"},{"post_id":"ckx07v1b30011acbf5a2sf56i","category_id":"ckx07v1aw000jacbf39na7hxg","_id":"ckx07v1b6001eacbfbjax27rp"},{"post_id":"ckx07v1b40014acbfb0yjfuzw","category_id":"ckx07v1al0003acbf5cqqalcq","_id":"ckx07v1b6001hacbfapq5asgw"},{"post_id":"ckx07v1bp001tacbf1wwe1omc","category_id":"ckx07v1al0003acbf5cqqalcq","_id":"ckx07v1bv0020acbfgjuz5up3"},{"post_id":"ckx07v1br001vacbffqei8bdp","category_id":"ckx07v1al0003acbf5cqqalcq","_id":"ckx07v1bx0023acbf5mxbb1yr"},{"post_id":"ckx07v1bt001yacbf64wl34n1","category_id":"ckx07v1aw000jacbf39na7hxg","_id":"ckx07v1by0027acbf76mn3n4a"},{"post_id":"ckx07v1cs002facbfaswrccqv","category_id":"ckx07v1al0003acbf5cqqalcq","_id":"ckx07v1cu002hacbfh7ts0hoc"}],"PostTag":[{"post_id":"ckx07v1ah0001acbf9gged9mf","tag_id":"ckx07v1am0004acbf1et2980t","_id":"ckx07v1av000hacbfhc34av2k"},{"post_id":"ckx07v1ah0001acbf9gged9mf","tag_id":"ckx07v1aq0009acbf9jrsc9o9","_id":"ckx07v1ax000lacbfdxfl4v6p"},{"post_id":"ckx07v1as000bacbf7l65628y","tag_id":"ckx07v1am0004acbf1et2980t","_id":"ckx07v1az000pacbf0khe4k1b"},{"post_id":"ckx07v1ak0002acbf2ygx0lsd","tag_id":"ckx07v1am0004acbf1et2980t","_id":"ckx07v1b0000sacbf5puggmxk"},{"post_id":"ckx07v1an0005acbfg61og3ve","tag_id":"ckx07v1am0004acbf1et2980t","_id":"ckx07v1b1000wacbfh0im59v9"},{"post_id":"ckx07v1az000qacbfesi5egem","tag_id":"ckx07v1am0004acbf1et2980t","_id":"ckx07v1b2000zacbfe3438vpy"},{"post_id":"ckx07v1ao0006acbfgtbj08oa","tag_id":"ckx07v1b0000tacbfdjm04nj2","_id":"ckx07v1b30013acbffnvdgbga"},{"post_id":"ckx07v1ap0007acbf3j2w7yu8","tag_id":"ckx07v1b20010acbfeucbatg9","_id":"ckx07v1b50018acbf1dtq251h"},{"post_id":"ckx07v1ar000aacbfevk46d3k","tag_id":"ckx07v1b40016acbf0nos2e5f","_id":"ckx07v1b5001cacbf2rj98wqt"},{"post_id":"ckx07v1au000facbf9v2y2x5y","tag_id":"ckx07v1b40016acbf0nos2e5f","_id":"ckx07v1b6001gacbf2m0zglm0"},{"post_id":"ckx07v1aw000iacbf4dcv52x1","tag_id":"ckx07v1b6001facbfaeh6bqjz","_id":"ckx07v1b6001jacbffvs8etp3"},{"post_id":"ckx07v1ay000nacbf7nyoexnk","tag_id":"ckx07v1b6001facbfaeh6bqjz","_id":"ckx07v1b7001lacbf9ztabk8k"},{"post_id":"ckx07v1b0000uacbf2fj0a0ev","tag_id":"ckx07v1b6001kacbfaminaphk","_id":"ckx07v1b9001nacbffpt99uvl"},{"post_id":"ckx07v1b1000xacbf6mwm4aid","tag_id":"ckx07v1b7001macbf285ggvv7","_id":"ckx07v1ba001pacbffohp3gt4"},{"post_id":"ckx07v1b30011acbf5a2sf56i","tag_id":"ckx07v1ba001oacbf3nbzbbb9","_id":"ckx07v1ba001racbf2vrxcgzy"},{"post_id":"ckx07v1b40014acbfb0yjfuzw","tag_id":"ckx07v1b40016acbf0nos2e5f","_id":"ckx07v1ba001sacbf6ane68kp"},{"post_id":"ckx07v1bt001yacbf64wl34n1","tag_id":"ckx07v1ba001oacbf3nbzbbb9","_id":"ckx07v1bw0022acbf5cl5gm8r"},{"post_id":"ckx07v1bp001tacbf1wwe1omc","tag_id":"ckx07v1bt001xacbff1vx6o0a","_id":"ckx07v1by0026acbf8hsr7woo"},{"post_id":"ckx07v1br001vacbffqei8bdp","tag_id":"ckx07v1bx0024acbf4sr8glx3","_id":"ckx07v1c0002bacbf1qqfh9yd"},{"post_id":"ckx07v1br001vacbffqei8bdp","tag_id":"ckx07v1by0028acbf6wdi5hu7","_id":"ckx07v1c1002cacbf91sj8ss6"},{"post_id":"ckx07v1br001vacbffqei8bdp","tag_id":"ckx07v1bz0029acbf0i7nb7g7","_id":"ckx07v1c1002dacbfg60x0wrp"},{"post_id":"ckx07v1br001vacbffqei8bdp","tag_id":"ckx07v1c0002aacbf77il3kgm","_id":"ckx07v1c1002eacbfhwg34mmd"},{"post_id":"ckx07v1cs002facbfaswrccqv","tag_id":"ckx07v1b6001facbfaeh6bqjz","_id":"ckx07v1cv002iacbf8keb27p6"},{"post_id":"ckx07v1cs002facbfaswrccqv","tag_id":"ckx07v1ct002gacbf7gpv91pn","_id":"ckx07v1cv002jacbf2i0s54uy"}],"Tag":[{"name":"algorithm","_id":"ckx07v1am0004acbf1et2980t"},{"name":"data structure","_id":"ckx07v1aq0009acbf9jrsc9o9"},{"name":"map","_id":"ckx07v1b0000tacbfdjm04nj2"},{"name":"tools","_id":"ckx07v1b20010acbfeucbatg9"},{"name":"git","_id":"ckx07v1b40016acbf0nos2e5f"},{"name":"IO","_id":"ckx07v1b6001facbfaeh6bqjz"},{"name":"nginx","_id":"ckx07v1b6001kacbfaminaphk"},{"name":"redis","_id":"ckx07v1b7001macbf285ggvv7"},{"name":"finance","_id":"ckx07v1ba001oacbf3nbzbbb9"},{"name":"source code","_id":"ckx07v1bt001xacbff1vx6o0a"},{"name":"java","_id":"ckx07v1bx0024acbf4sr8glx3"},{"name":"spring","_id":"ckx07v1by0028acbf6wdi5hu7"},{"name":"mysql","_id":"ckx07v1bz0029acbf0i7nb7g7"},{"name":"http","_id":"ckx07v1c0002aacbf77il3kgm"},{"name":"netty","_id":"ckx07v1ct002gacbf7gpv91pn"}]}}